# ====================================================================
# Helix Sandbox - Unified Container
# Architecture: Wolf + Moonlight Web + RevDial Client + Docker-in-Docker
# Based on: ~/pm/wolf/docker/wolf.Dockerfile (uses GOW base-app + cont-init.d)
# ====================================================================

# Use same base as Wolf (GOW gstreamer base-app with init system)
ARG BASE_IMAGE=ghcr.io/games-on-whales/gstreamer:1.26.7

# ====================================================================
# Stage 1: Build Go binaries (revdial-client, hydra, sandbox-heartbeat)
# ====================================================================
FROM golang:1.24 AS go-builder
WORKDIR /build
COPY go.mod go.sum ./
RUN --mount=type=cache,target=/go/pkg/mod \
    go mod download
COPY api/ ./api/
# Build revdial-client
RUN --mount=type=cache,target=/go/pkg/mod \
    --mount=type=cache,target=/root/.cache/go-build \
    CGO_ENABLED=0 go build -ldflags "-s -w" -o /revdial-client ./api/cmd/revdial-client
# Build hydra (multi-Docker isolation daemon)
RUN --mount=type=cache,target=/go/pkg/mod \
    --mount=type=cache,target=/root/.cache/go-build \
    CGO_ENABLED=0 go build -ldflags "-s -w" -o /hydra ./api/cmd/hydra
# Build sandbox-heartbeat (disk monitoring)
RUN --mount=type=cache,target=/go/pkg/mod \
    --mount=type=cache,target=/root/.cache/go-build \
    CGO_ENABLED=0 go build -ldflags "-s -w" -o /sandbox-heartbeat ./api/cmd/sandbox-heartbeat

# Alias for backward compatibility
FROM go-builder AS revdial-builder

# ====================================================================
# Stage 2: Build Moonlight Web
# ====================================================================
FROM rust:latest AS moonlight-web-builder

# Use release mode for production (or debug for faster builds)
ARG BUILD_MODE=release

# Install Rust nightly (required by moonlight-web-stream)
RUN rustup default nightly

# Install build dependencies
RUN apt-get update && apt-get install -y \
    procps \
    curl \
    cmake \
    libssl-dev \
    pkg-config \
    clang \
    libclang-dev \
    nodejs \
    npm \
    && rm -rf /var/lib/apt/lists/*

# Use system OpenSSL (prevents slow perl-based OpenSSL compilation)
ENV OPENSSL_NO_VENDOR=1
ENV OPENSSL_DIR=/usr
ENV OPENSSL_LIB_DIR=/usr/lib/x86_64-linux-gnu
ENV OPENSSL_INCLUDE_DIR=/usr/include

WORKDIR /build

# NOTE: In production, copy Moonlight Web source here
# For now, we'll copy from upstream image in final stage
# COPY moonlight-web-stream/ .
# RUN --mount=type=cache,target=/usr/local/cargo/registry \
#     --mount=type=cache,target=/build/target \
#     cargo build --release && \
#     cp /build/target/release/web-server /tmp/web-server && \
#     cp /build/target/release/streamer /tmp/streamer

# ====================================================================
# Stage 3: Get Wolf binary (use local image)
# ====================================================================
FROM wolf:helix-fixed AS wolf-upstream
# Using local Wolf image built from ~/pm/wolf

# ====================================================================
# Stage 4: Get Moonlight Web binaries (use local image)
# ====================================================================
FROM helix-moonlight-web:helix-fixed AS moonlight-web-upstream
# Using local Moonlight Web image

# ====================================================================
# Stage 5: Final unified sandbox image
# ====================================================================
FROM $BASE_IMAGE AS sandbox

ENV DEBIAN_FRONTEND=noninteractive

# ====================================================================
# Install all runtime dependencies (Wolf + Moonlight Web + Docker)
# ====================================================================

# Wolf runtime dependencies (from wolf.Dockerfile lines 99-110)
RUN apt-get update -y && \
    apt-get install -y --no-install-recommends \
    ca-certificates \
    libssl3 \
    libicu76 \
    libevdev2 \
    libudev1 \
    libcurl4 \
    libdrm2 \
    libpci3 \
    libunwind8 \
    && rm -rf /var/lib/apt/lists/*

# Debug tools for deadlock investigation (from wolf.Dockerfile lines 113-122)
RUN apt-get update -y && \
    apt-get install -y --no-install-recommends \
    gdb \
    strace \
    ltrace \
    lsof \
    procps \
    htop \
    binutils \
    && rm -rf /var/lib/apt/lists/*

# ROCm SMI for AMD GPU monitoring (used by Wolf's GPU stats endpoint)
# Install from ROCm repo for AMD GPU support
RUN apt-get update -y && \
    apt-get install -y --no-install-recommends \
    wget gnupg \
    && mkdir -p /etc/apt/keyrings \
    && wget -qO - https://repo.radeon.com/rocm/rocm.gpg.key | gpg --dearmor > /etc/apt/keyrings/rocm.gpg \
    && echo "deb [arch=amd64 signed-by=/etc/apt/keyrings/rocm.gpg] https://repo.radeon.com/rocm/apt/6.2 noble main" > /etc/apt/sources.list.d/rocm.list \
    && apt-get update -y \
    && apt-get install -y --no-install-recommends rocm-smi-lib \
    && rm -rf /var/lib/apt/lists/*

# gst-plugin-wayland runtime dependencies (from wolf.Dockerfile lines 147-151)
RUN apt-get update -y && \
    apt-get install -y --no-install-recommends \
    libwayland-server0 libinput10 libxkbcommon0 libgbm1 \
    libglvnd0 libgl1 libglx0 libegl1 libgles2 xwayland hwdata \
    && rm -rf /var/lib/apt/lists/*

# Docker + NVIDIA Container Toolkit (from wolf.Dockerfile lines 154-182)
RUN apt-get update -y && \
    apt-get install -y --no-install-recommends \
    ca-certificates \
    curl \
    gnupg \
    lsb-release \
    && mkdir -p /etc/apt/keyrings \
    && curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /etc/apt/keyrings/docker.gpg \
    && echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | tee /etc/apt/sources.list.d/docker.list > /dev/null \
    && apt-get update -y \
    && apt-get install -y --no-install-recommends \
    docker-ce-cli \
    docker-ce \
    containerd.io \
    docker-buildx-plugin \
    docker-compose-plugin \
    && rm -rf /var/lib/apt/lists/*

# NVIDIA Container Toolkit (from wolf.Dockerfile lines 174-182)
RUN curl -fsSL https://nvidia.github.io/libnvidia-container/gpgkey | gpg --dearmor -o /usr/share/keyrings/nvidia-container-toolkit-keyring.gpg \
    && curl -s -L https://nvidia.github.io/libnvidia-container/stable/deb/nvidia-container-toolkit.list | \
        sed 's#deb https://#deb [signed-by=/usr/share/keyrings/nvidia-container-toolkit-keyring.gpg] https://#g' | \
        tee /etc/apt/sources.list.d/nvidia-container-toolkit.list \
    && apt-get update -y \
    && apt-get install -y --no-install-recommends \
    nvidia-container-toolkit \
    nvidia-container-runtime \
    && rm -rf /var/lib/apt/lists/*

# ====================================================================
# Copy helix-sway tarball EARLY (rarely changes, ~3GB)
# This maximizes cache hits - changes to scripts/binaries below won't
# invalidate this large layer, making pushes much faster
# ====================================================================
RUN mkdir -p /opt/images
COPY helix-sway.tar /opt/images/helix-sway.tar
COPY helix-sway.tar.hash /opt/images/helix-sway.tar.hash
COPY helix-sway.version /opt/images/helix-sway.version

# ====================================================================
# Copy Wolf binaries and setup
# ====================================================================

WORKDIR /wolf
ENV WOLF_CFG_FOLDER=/etc/wolf/cfg

# Copy Wolf binaries from upstream (or from wolf-builder if building from source)
COPY --from=wolf-upstream /wolf/wolf /wolf/wolf
COPY --from=wolf-upstream /wolf/fake-udev /wolf/fake-udev

# Copy Wolf's GStreamer plugins (custom compositor)
ENV GST_PLUGIN_PATH=/usr/local/lib/x86_64-linux-gnu/gstreamer-1.0/
COPY --from=wolf-upstream $GST_PLUGIN_PATH /usr/local/lib/x86_64-linux-gnu/gstreamer-1.0/
COPY --from=wolf-upstream /usr/local/lib/liblibgstwaylanddisplay* /usr/local/lib/

# Copy Wolf's init scripts and config template
# Note: /etc/wolf/cfg is created for prod (in dev it's bind-mounted from ./wolf)
RUN mkdir -p /opt/wolf-defaults /etc/wolf/cfg
COPY --from=wolf-upstream /opt/wolf-defaults/config.toml.template /opt/wolf-defaults/config.toml.template
COPY --from=wolf-upstream /etc/cont-init.d/05-init-wolf-config.sh /etc/cont-init.d/05-init-wolf-config.sh
RUN chmod +x /etc/cont-init.d/05-init-wolf-config.sh

# Create complete start-dockerd.sh script (based on ~/pm/wolf/docker/start-dockerd.sh with Helix additions)
COPY <<'DOCKERD_SCRIPT' /etc/cont-init.d/04-start-dockerd.sh
#!/bin/bash
set -e

echo "üê≥ Starting Wolf's isolated dockerd..."

# Clean up stale PID files (common issue with Docker restarts)
if [ -f /var/run/docker.pid ]; then
    echo "üßπ Cleaning up stale docker.pid file"
    rm -f /var/run/docker.pid
fi

# Clean up stale containerd PID file (prevents "timeout waiting for containerd to start")
if [ -f /run/docker/containerd/containerd.pid ]; then
    echo "üßπ Cleaning up stale containerd.pid file"
    rm -f /run/docker/containerd/containerd.pid
fi

# Use iptables-legacy for DinD compatibility
export PATH="/usr/local/sbin/.iptables-legacy:$PATH"
echo "Using iptables-legacy for Docker-in-Docker networking compatibility"

# Configure dockerd with NVIDIA runtime
mkdir -p /etc/docker
cat > /etc/docker/daemon.json <<'DAEMON_JSON'
{
  "runtimes": {
    "nvidia": {
      "path": "nvidia-container-runtime",
      "runtimeArgs": []
    }
  },
  "storage-driver": "overlay2",
  "log-level": "error"
}
DAEMON_JSON

echo "Configured Wolf's dockerd with nvidia runtime support"

# Start dockerd in background (redirect to stdout with prefix for unified logs)
dockerd --config-file /etc/docker/daemon.json \
    --host=unix:///var/run/docker.sock \
    2>&1 | sed -u 's/^/[DOCKERD] /' &

DOCKERD_PID=$!
echo "Started dockerd with PID: $DOCKERD_PID"

# Wait for dockerd to be ready
TIMEOUT=30
ELAPSED=0
until docker info >/dev/null 2>&1; do
    if [ $ELAPSED -ge $TIMEOUT ]; then
        echo "‚ùå ERROR: dockerd failed to start within $TIMEOUT seconds"
        echo "Check dockerd logs above for details"
        exit 1
    fi
    echo "Waiting for dockerd... ($ELAPSED/$TIMEOUT)"
    sleep 1
    ELAPSED=$((ELAPSED + 1))
done

echo "‚úÖ Wolf's dockerd is ready!"
docker info 2>&1 | head -5

# Enable forwarding for nested containers
iptables -P FORWARD ACCEPT
echo "‚úÖ iptables FORWARD policy set to ACCEPT"

# Create helix_default network
if ! docker network inspect helix_default >/dev/null 2>&1; then
    echo "Creating helix_default network (subnet 172.20.0.0/16)..."
    docker network create helix_default --subnet 172.20.0.0/16 --gateway 172.20.0.1
    echo "‚úÖ helix_default network created"
else
    echo "helix_default network already exists"
fi

# Load helix-sway image into sandbox's dockerd (with version-based management)
if [ -f /opt/images/helix-sway.tar ]; then
    # Read expected version from embedded metadata
    SWAY_VERSION="latest"
    if [ -f /opt/images/helix-sway.version ]; then
        SWAY_VERSION=$(cat /opt/images/helix-sway.version)
        echo "üì¶ helix-sway version: ${SWAY_VERSION}"
    fi

    # Check if versioned image already loaded (optimization to skip expensive docker load)
    SHOULD_LOAD=true
    EXPECTED_HASH=""
    if [ -f /opt/images/helix-sway.tar.hash ]; then
        EXPECTED_HASH=$(cat /opt/images/helix-sway.tar.hash)
    fi

    # Check for versioned tag first (more reliable than :latest)
    CURRENT_HASH=$(docker images "helix-sway:${SWAY_VERSION}" --format '{{.ID}}' 2>/dev/null || echo "")

    if [ "$CURRENT_HASH" = "$EXPECTED_HASH" ] && [ -n "$CURRENT_HASH" ]; then
        echo "‚úÖ helix-sway:${SWAY_VERSION} already loaded (hash: $CURRENT_HASH) - skipping docker load"
        SHOULD_LOAD=false
    else
        echo "üì¶ Loading helix-sway:${SWAY_VERSION} into sandbox's dockerd (current: ${CURRENT_HASH:-none}, expected: ${EXPECTED_HASH:-unknown})..."
    fi

    if [ "$SHOULD_LOAD" = true ]; then
        if docker load -i /opt/images/helix-sway.tar 2>&1 | tee /tmp/docker-load.log; then
            # Verify both tags exist after load
            if docker images "helix-sway:${SWAY_VERSION}" --format '{{.ID}}' | grep -q .; then
                echo "‚úÖ helix-sway:${SWAY_VERSION} loaded successfully"
            else
                # Tarball may be from before versioning - tag it now
                echo "üè∑Ô∏è  Tagging helix-sway:latest as helix-sway:${SWAY_VERSION}"
                docker tag helix-sway:latest "helix-sway:${SWAY_VERSION}" 2>/dev/null || true
            fi
        else
            echo "‚ö†Ô∏è  Failed to load helix-sway tarball (may be corrupted or out of memory)"
            echo "   Container will continue startup - transfer fresh image with './stack build-sway'"
        fi
    fi

    # Note: Wolf executor reads /opt/images/helix-sway.version directly
    echo "‚úÖ helix-sway:${SWAY_VERSION} ready for Wolf executor"
else
    echo "‚ö†Ô∏è  helix-sway tarball not found (sandboxes may fail to start)"
fi
DOCKERD_SCRIPT
RUN chmod +x /etc/cont-init.d/04-start-dockerd.sh

# ====================================================================
# Copy Moonlight Web binaries and setup
# ====================================================================

WORKDIR /opt/moonlight-web

# Copy Moonlight Web binaries from upstream
COPY --from=moonlight-web-upstream /app/web-server /opt/moonlight-web/moonlight-web
COPY --from=moonlight-web-upstream /app/streamer /opt/moonlight-web/streamer
COPY --from=moonlight-web-upstream /app/dist /opt/moonlight-web/dist
COPY --from=moonlight-web-upstream /app/static /opt/moonlight-web/static

# Copy Moonlight Web templates (init script is inline below)
RUN mkdir -p /opt/moonlight-web/templates /opt/moonlight-web/server
COPY --from=moonlight-web-upstream /app/templates/ /opt/moonlight-web/templates/

# Create symlinks for Moonlight Web init script compatibility
# The upstream init script expects binaries in /app/, but we have them in /opt/moonlight-web/
RUN mkdir -p /app && \
    ln -s /opt/moonlight-web/moonlight-web /app/web-server && \
    ln -s /opt/moonlight-web/streamer /app/streamer && \
    ln -s /opt/moonlight-web/dist /app/dist && \
    ln -s /opt/moonlight-web/static /app/static && \
    ln -s /opt/moonlight-web/templates /app/templates && \
    ln -s /opt/moonlight-web/server /app/server

# ====================================================================
# Copy revdial-client and hydra binaries
# ====================================================================

COPY --from=go-builder /revdial-client /usr/local/bin/revdial-client
COPY --from=go-builder /hydra /usr/local/bin/hydra
COPY --from=go-builder /sandbox-heartbeat /usr/local/bin/sandbox-heartbeat
RUN chmod +x /usr/local/bin/revdial-client /usr/local/bin/hydra /usr/local/bin/sandbox-heartbeat

# ====================================================================
# Create cont-init.d scripts for Moonlight Web and RevDial
# (Following Wolf's pattern: /etc/cont-init.d/*.sh runs before main process)
# ====================================================================

# 06: Initialize Moonlight Web config (startup moved to startup-app.sh to run AFTER Wolf)
# Use the upstream init script with modified Wolf address (127.0.0.1 instead of wolf)
RUN cat > /etc/cont-init.d/06-init-moonlight-config.sh << 'EOF'
#!/bin/bash
set -e
echo "üåô Initializing Moonlight Web config..."

DATA_FILE="/opt/moonlight-web/server/data.json"
CONFIG_FILE="/opt/moonlight-web/server/config.json"
DATA_TEMPLATE="/opt/moonlight-web/templates/data.json.template"
CONFIG_TEMPLATE="/opt/moonlight-web/templates/config.json.template"

mkdir -p /opt/moonlight-web/server

# Initialize data.json if it doesn't exist or is empty
if [ ! -f "$DATA_FILE" ] || [ ! -s "$DATA_FILE" ]; then
    echo "üîß Initializing moonlight-web data.json from template..."
    # Wolf is on 127.0.0.1 in unified sandbox container
    # Must use 127.0.0.1 NOT localhost - Wolf only listens on IPv4, and "localhost"
    # resolves to IPv6 first on modern Linux, causing "LikelyOffline" errors
    sed 's/"address": "wolf"/"address": "127.0.0.1"/' "$DATA_TEMPLATE" > "$DATA_FILE"
    # Use WOLF_INSTANCE_ID for consistency with Wolf hostname
    WOLF_INSTANCE_ID=${WOLF_INSTANCE_ID:-local}
    sed -i "s/{{HELIX_HOSTNAME}}/$WOLF_INSTANCE_ID/g" "$DATA_FILE"
    echo "‚úÖ moonlight-web data.json initialized"
fi

# Initialize config.json with dynamic TURN server IP
if [ ! -f "$CONFIG_FILE" ] || [ ! -s "$CONFIG_FILE" ]; then
    echo "üîß Initializing moonlight-web config.json from template..."

    # Use environment variables or defaults for dev mode
    MOONLIGHT_CREDENTIALS=${MOONLIGHT_CREDENTIALS:-helix:helix}
    TURN_PASSWORD=${TURN_PASSWORD:-helix-turn-secret}
    TURN_PUBLIC_IP=${TURN_PUBLIC_IP:-}

    # Auto-detect public IP if TURN_PUBLIC_IP not set
    if [ -z "$TURN_PUBLIC_IP" ]; then
        echo "‚è≥ Auto-detecting public IP for TURN server..."
        TURN_PUBLIC_IP=$(curl -s --max-time 2 https://api.ipify.org 2>/dev/null || echo "127.0.0.1")
        echo "‚úÖ Using TURN IP: $TURN_PUBLIC_IP"
    fi

    # Substitute template variables
    sed -e "s/{{TURN_PUBLIC_IP}}/$TURN_PUBLIC_IP/g" \
        -e "s/{{MOONLIGHT_CREDENTIALS}}/$MOONLIGHT_CREDENTIALS/g" \
        -e "s/{{TURN_PASSWORD}}/$TURN_PASSWORD/g" \
        "$CONFIG_TEMPLATE" > "$CONFIG_FILE"
    echo "‚úÖ moonlight-web config.json initialized"
fi

# NOTE: Moonlight Web startup moved to startup-app.sh to ensure Wolf is running first
# This avoids the "LikelyOffline" error caused by Moonlight trying to connect before Wolf
echo "‚úÖ Moonlight Web config ready (startup deferred to after Wolf)"
EOF
RUN chmod +x /etc/cont-init.d/06-init-moonlight-config.sh

# 06b: Auto-pair Moonlight Web with Wolf (runs AFTER both are started)
# This script is sourced by startup-app.sh after Wolf starts
RUN cat > /opt/moonlight-web/auto-pair.sh << 'EOF'
#!/bin/bash
# Auto-pair Moonlight Web with Wolf
# Based on original moonlight-web-stream/server-templates/init-moonlight-config.sh logic

DATA_FILE="/opt/moonlight-web/server/data.json"

# Check if already paired (skip if paired section exists in data.json)
if grep -q '"paired"' "$DATA_FILE" 2>/dev/null; then
    echo "‚ÑπÔ∏è  moonlight-web already paired with Wolf, skipping auto-pair"
    exit 0
fi

echo "üîó Auto-pairing moonlight-web with Wolf..."

# Wait for Wolf to be ready (check if Wolf's Moonlight port 47989 is accepting connections)
# Original script checked TCP port, not API endpoint (API takes longer to init)
echo "‚è≥ Waiting for Wolf to be ready..."
for i in {1..60}; do
    if timeout 1 bash -c 'cat < /dev/null > /dev/tcp/localhost/47989' 2>/dev/null; then
        echo "‚úÖ Wolf port 47989 is responding"
        # Wait additional 5 seconds for HTTPS endpoint to fully initialize
        # Wolf's TCP port responds before HTTPS is ready, causing pairing failures
        echo "‚è≥ Waiting 5s for Wolf HTTPS endpoint to initialize..."
        sleep 5
        echo "‚úÖ Wolf is ready for pairing"
        break
    fi
    if [ $i -eq 60 ]; then
        echo "‚ùå Wolf failed to start within 60 seconds, skipping auto-pair"
        exit 0  # Don't fail the container, just skip pairing
    fi
    sleep 1
done

# Trigger pairing via Moonlight Web API (which will connect to Wolf and complete pairing)
CREDS="${MOONLIGHT_CREDENTIALS:-helix}"
PAIR_RESPONSE=$(curl -s -X POST http://localhost:8080/api/pair \
    -H "Authorization: Bearer $CREDS" \
    -H "Content-Type: application/json" \
    -d '{"host_id":0}' 2>&1)

echo "üì° Pairing response: $PAIR_RESPONSE"

# Wait a moment for pairing to complete and data.json to be updated
sleep 1

# Check if pairing succeeded by looking for paired section in data.json
# (more reliable than parsing chunked HTTP response)
if grep -q '"paired"' "$DATA_FILE"; then
    echo "‚úÖ Auto-pairing with Wolf completed successfully"
else
    echo "‚ùå Auto-pairing failed - paired section not found in data.json"
    echo "   This may be expected if Wolf is not fully initialized yet"
    echo "   Pairing can be completed manually via Moonlight Web UI"
fi
EOF
RUN chmod +x /opt/moonlight-web/auto-pair.sh

# 07: Start Wolf RevDial client (optional, only if HELIX_API_URL is set)
# NOTE: Moonlight Web RevDial client is started in startup-app.sh AFTER Moonlight Web
RUN cat > /etc/cont-init.d/07-start-revdial-clients.sh << 'EOF'
#!/bin/bash
set -e

# Skip if no control plane configured (local dev mode)
if [ -z "$HELIX_API_URL" ] || [ -z "$RUNNER_TOKEN" ]; then
    echo "‚ÑπÔ∏è  No HELIX_API_URL set, skipping RevDial clients (local mode)"
    exit 0
fi

WOLF_INSTANCE_ID=${WOLF_INSTANCE_ID:-local}
echo "üîó Starting Wolf RevDial client..."
echo "   Control Plane: $HELIX_API_URL"
echo "   Wolf Instance ID: $WOLF_INSTANCE_ID"

# Start Wolf API RevDial client with automatic restart (proxies Wolf Unix socket)
# Use cgo DNS resolver to work around Go DNS issues in Docker
# Use sed -u for unbuffered output (otherwise logs don't appear)
(
    while true; do
        echo "[$(date -Iseconds)] Starting Wolf RevDial client..."
        GODEBUG=netdns=cgo /usr/local/bin/revdial-client \
            -server "$HELIX_API_URL/api/v1/revdial" \
            -runner-id "wolf-$WOLF_INSTANCE_ID" \
            -token "$RUNNER_TOKEN" \
            -local "unix:///var/run/wolf/wolf.sock"
        EXIT_CODE=$?
        echo "[$(date -Iseconds)] ‚ö†Ô∏è  Wolf RevDial client exited with code $EXIT_CODE, restarting in 2s..."
        sleep 2
    done
) 2>&1 | sed -u 's/^/[WOLF-REVDIAL] /' &
echo "‚úÖ Wolf RevDial client started with auto-restart"

# NOTE: Moonlight Web RevDial client is started in startup-app.sh AFTER Moonlight Web starts
# This ensures Moonlight Web is ready to accept connections before RevDial connects
echo "‚ÑπÔ∏è  Moonlight Web RevDial will start after Moonlight Web (in startup-app.sh)"
EOF
RUN chmod +x /etc/cont-init.d/07-start-revdial-clients.sh

# 08: Start Wolf instance heartbeat daemon (Go binary with disk space monitoring)
RUN cat > /etc/cont-init.d/08-start-wolf-heartbeat.sh << 'EOF'
#!/bin/bash
set -e

# Skip if no control plane configured (local dev mode)
if [ -z "$HELIX_API_URL" ] || [ -z "$RUNNER_TOKEN" ]; then
    echo "‚ÑπÔ∏è  No HELIX_API_URL set, skipping Wolf heartbeat (local mode)"
    exit 0
fi

WOLF_INSTANCE_ID=${WOLF_INSTANCE_ID:-local}
echo "üíì Starting Wolf heartbeat daemon for instance: $WOLF_INSTANCE_ID"

# Start the Go heartbeat daemon in background
# It monitors disk space on /var and / and reports to API
/usr/local/bin/sandbox-heartbeat 2>&1 | sed -u 's/^/[HEARTBEAT] /' &

HEARTBEAT_PID=$!
echo "‚úÖ Wolf heartbeat daemon started (PID: $HEARTBEAT_PID)"
EOF
RUN chmod +x /etc/cont-init.d/08-start-wolf-heartbeat.sh

# 09: Setup telemetry firewall for nested agent containers
# Fixed: Create /wolf/sway-config directory before writing update script
COPY wolf/sway-config/setup-telemetry-firewall.sh /etc/cont-init.d/09-setup-telemetry-firewall.sh
RUN chmod +x /etc/cont-init.d/09-setup-telemetry-firewall.sh

# 10: Start Hydra multi-Docker isolation daemon (optional, only if HYDRA_ENABLED is set)
RUN cat > /etc/cont-init.d/10-start-hydra.sh << 'EOF'
#!/bin/bash
set -e

# Skip if Hydra is not enabled
if [ "$HYDRA_ENABLED" != "true" ]; then
    echo "‚ÑπÔ∏è  Hydra not enabled (HYDRA_ENABLED != true), skipping multi-Docker isolation"
    exit 0
fi

echo "üêâ Starting Hydra multi-Docker isolation daemon..."

# Create required directories
mkdir -p /var/run/hydra/active
mkdir -p /filestore/hydra

# Start Hydra daemon in background with auto-restart
(
    while true; do
        echo "[$(date -Iseconds)] Starting Hydra daemon..."
        /usr/local/bin/hydra \
            --socket /var/run/hydra/hydra.sock \
            --socket-dir /var/run/hydra/active \
            --data-dir /filestore/hydra \
            --log-level info
        EXIT_CODE=$?
        echo "[$(date -Iseconds)] ‚ö†Ô∏è  Hydra exited with code $EXIT_CODE, restarting in 2s..."
        sleep 2
    done
) 2>&1 | sed -u 's/^/[HYDRA] /' &

HYDRA_PID=$!
echo "‚úÖ Hydra daemon started (PID: $HYDRA_PID)"

# Wait for Hydra socket to be ready
TIMEOUT=30
ELAPSED=0
until [ -S /var/run/hydra/hydra.sock ]; do
    if [ $ELAPSED -ge $TIMEOUT ]; then
        echo "‚ùå ERROR: Hydra socket not ready within $TIMEOUT seconds"
        exit 1
    fi
    echo "Waiting for Hydra socket... ($ELAPSED/$TIMEOUT)"
    sleep 1
    ELAPSED=$((ELAPSED + 1))
done

echo "‚úÖ Hydra socket ready at /var/run/hydra/hydra.sock"

# Log privileged mode status
if [ "$HYDRA_PRIVILEGED_MODE_ENABLED" = "true" ]; then
    echo "‚ö†Ô∏è  Hydra PRIVILEGED MODE ENABLED - host Docker access available for Helix development"
else
    echo "‚ÑπÔ∏è  Hydra running in normal mode (isolated Docker instances per scope)"
fi

# Note: Hydra includes its own built-in RevDial client
# It reads HELIX_API_URL, RUNNER_TOKEN, WOLF_INSTANCE_ID from environment
echo "‚úÖ Hydra daemon ready (RevDial client built-in)"
EOF
RUN chmod +x /etc/cont-init.d/10-start-hydra.sh

# ====================================================================
# Create main startup script (starts Wolf in foreground)
# (Replaces /opt/gow/startup-app.sh - Wolf is the main process)
# ====================================================================

RUN cat > /opt/gow/startup-app.sh << 'EOF'
#!/bin/bash
set -e

# This script is executed by GOW's /entrypoint.sh after all cont-init.d scripts
# At this point:
#   - dockerd is running (started by 04-start-dockerd.sh)
#   - Wolf config is initialized (05-init-wolf-config.sh)
#   - Moonlight Web config is initialized (06-init-moonlight-config.sh)
#   - RevDial clients started (07-start-revdial-clients.sh) - Wolf RevDial only
#
# IMPORTANT: Moonlight Web MUST start AFTER Wolf to avoid "LikelyOffline" errors
# Moonlight Web tries to connect to Wolf on startup to cache host info.
# If Wolf isn't ready, the connection fails and is cached as "offline".

echo "üê∫ Starting Wolf (main process with automatic restart)..."

# Make sure Wolf config folder and socket directory exist
export WOLF_CFG_FOLDER=$HOST_APPS_STATE_FOLDER/cfg
mkdir -p $WOLF_CFG_FOLDER
mkdir -p /var/run/wolf
export WOLF_CFG_FILE=$WOLF_CFG_FOLDER/config.toml
export WOLF_PRIVATE_KEY_FILE=$WOLF_CFG_FOLDER/key.pem
export WOLF_PRIVATE_CERT_FILE=$WOLF_CFG_FOLDER/cert.pem

# Set default values for environment variables
export WOLF_RENDER_NODE=${WOLF_RENDER_NODE:-/dev/dri/renderD128}
export WOLF_ENCODER_NODE=${WOLF_ENCODER_NODE:-$WOLF_RENDER_NODE}
export GST_GL_DRM_DEVICE=${GST_GL_DRM_DEVICE:-$WOLF_ENCODER_NODE}

# Update fake-udev path
export WOLF_DOCKER_FAKE_UDEV_PATH=${WOLF_DOCKER_FAKE_UDEV_PATH:-$HOST_APPS_STATE_FOLDER/fake-udev}
cp /wolf/fake-udev $WOLF_DOCKER_FAKE_UDEV_PATH

# Track restart state
WOLF_RESTART_COUNT=0
MAX_RESTARTS=10
RESTART_WINDOW=300  # 5 minutes
RESTART_TIMESTAMPS=()

# Function to start Wolf with supervision
start_wolf() {
    cd /wolf
    /wolf/wolf &
    WOLF_PID=$!
    echo "üê∫ Wolf started (PID: $WOLF_PID)"
}

# Function to wait for Wolf HTTP server
wait_for_wolf() {
    echo "‚è≥ Waiting for Wolf HTTP server..."
    for i in {1..30}; do
        if timeout 1 bash -c 'cat < /dev/null > /dev/tcp/127.0.0.1/47989' 2>/dev/null; then
            echo "‚úÖ Wolf HTTP server is ready"
            return 0
        fi
        if [ $i -eq 30 ]; then
            echo "‚ö†Ô∏è  Wolf HTTP server not ready after 30s"
            return 1
        fi
        sleep 1
    done
}

# Function to start Moonlight Web with auto-restart (called once on first Wolf start)
MOONLIGHT_STARTED=false
start_moonlight_web() {
    if [ "$MOONLIGHT_STARTED" = true ]; then
        return
    fi

    echo "üåô Starting Moonlight Web with auto-restart..."
    (
        cd /opt/moonlight-web
        while true; do
            echo "[$(date -Iseconds)] Starting Moonlight Web..."
            ./moonlight-web
            EXIT_CODE=$?
            echo "[$(date -Iseconds)] ‚ö†Ô∏è  Moonlight Web exited with code $EXIT_CODE, restarting in 2s..."
            sleep 2
        done
    ) 2>&1 | sed -u 's/^/[MOONLIGHT] /' &
    echo "‚úÖ Moonlight Web started with auto-restart"

    # Start Moonlight Web RevDial client with auto-restart (if HELIX_API_URL is set)
    if [ -n "$HELIX_API_URL" ]; then
        echo "üîó Starting Moonlight Web RevDial client with auto-restart..."
        (
            while true; do
                echo "[$(date -Iseconds)] Starting Moonlight Web RevDial client..."
                /usr/local/bin/revdial-client \
                    -server "$HELIX_API_URL/api/v1/revdial" \
                    -runner-id "moonlight-${WOLF_INSTANCE_ID:-local}" \
                    -token "${RUNNER_TOKEN:-}" \
                    -local "127.0.0.1:8080"
                EXIT_CODE=$?
                echo "[$(date -Iseconds)] ‚ö†Ô∏è  Moonlight Web RevDial client exited with code $EXIT_CODE, restarting in 2s..."
                sleep 2
            done
        ) 2>&1 | sed -u 's/^/[MOONLIGHT-REVDIAL] /' &
        echo "‚úÖ Moonlight Web RevDial client started with auto-restart"
    fi

    # Start auto-pairing in background (gives Moonlight Web time to fully initialize)
    (sleep 3 && /opt/moonlight-web/auto-pair.sh) 2>&1 | sed -u 's/^/[PAIRING] /' &

    MOONLIGHT_STARTED=true
}

# Function to check if we should restart (rate limiting)
should_restart() {
    local NOW=$(date +%s)

    # Remove old timestamps outside the window
    local NEW_TIMESTAMPS=()
    for TS in "${RESTART_TIMESTAMPS[@]}"; do
        if [ $((NOW - TS)) -lt $RESTART_WINDOW ]; then
            NEW_TIMESTAMPS+=("$TS")
        fi
    done
    RESTART_TIMESTAMPS=("${NEW_TIMESTAMPS[@]}")

    # Check if we've exceeded max restarts in window
    if [ ${#RESTART_TIMESTAMPS[@]} -ge $MAX_RESTARTS ]; then
        echo "‚ùå Wolf has crashed $MAX_RESTARTS times in the last $RESTART_WINDOW seconds"
        echo "   Giving up to prevent crash loop. Check logs for root cause."
        return 1
    fi

    # Record this restart
    RESTART_TIMESTAMPS+=("$NOW")
    return 0
}

# Initial Wolf start
start_wolf
wait_for_wolf

# Start Moonlight Web after Wolf is ready
start_moonlight_web

# Main supervision loop - restart Wolf if it crashes
while true; do
    wait $WOLF_PID
    EXIT_CODE=$?

    echo "‚ö†Ô∏è  Wolf exited with code $EXIT_CODE at $(date -Iseconds)"

    # Check if we should restart
    if ! should_restart; then
        echo "üõë Too many restarts, exiting container"
        exit 1
    fi

    WOLF_RESTART_COUNT=$((WOLF_RESTART_COUNT + 1))
    echo "üîÑ Restarting Wolf (restart #$WOLF_RESTART_COUNT)..."

    # Brief pause before restart
    sleep 2

    # Restart Wolf
    start_wolf
    wait_for_wolf || echo "‚ö†Ô∏è  Wolf may not be fully ready, continuing supervision..."
done
EOF
RUN chmod +x /opt/gow/startup-app.sh

# ====================================================================
# Wolf environment variables (from wolf.Dockerfile lines 207-225)
# ====================================================================

ENV GST_GL_API=gles2 \
    GST_GL_PLATFORM=egl \
    GST_GL_WINDOW=surfaceless \
    WOLF_USE_ZERO_COPY=TRUE \
    WOLF_LOG_LEVEL=INFO \
    WOLF_CFG_FILE=$WOLF_CFG_FOLDER/config.toml \
    WOLF_PRIVATE_KEY_FILE=$WOLF_CFG_FOLDER/key.pem \
    WOLF_PRIVATE_CERT_FILE=$WOLF_CFG_FOLDER/cert.pem \
    WOLF_PULSE_IMAGE=ghcr.io/games-on-whales/pulseaudio:master \
    WOLF_RENDER_NODE=/dev/dri/renderD128 \
    WOLF_STOP_CONTAINER_ON_EXIT=TRUE \
    WOLF_DOCKER_SOCKET=/var/run/docker.sock \
    RUST_BACKTRACE=full \
    RUST_LOG=WARN \
    HOST_APPS_STATE_FOLDER=/etc/wolf \
    GST_DEBUG=2 \
    PUID=0 \
    PGID=0 \
    UNAME="root"

# Helix sandbox environment variables
ENV HELIX_API_URL="" \
    WOLF_INSTANCE_ID="" \
    RUNNER_TOKEN="" \
    GPU_TYPE="nvidia" \
    MAX_SANDBOXES="10" \
    HELIX_DEV_MODE="false" \
    ZED_IMAGE="helix-sway:latest" \
    TURN_PUBLIC_IP="" \
    TURN_PASSWORD="" \
    HELIX_HOSTNAME="" \
    MOONLIGHT_CREDENTIALS="helix" \
    HYDRA_ENABLED="true" \
    HYDRA_PRIVILEGED_MODE_ENABLED="false"

# XDG_RUNTIME_DIR (creates volume when starting container)
VOLUME /run/user/wolf/
ENV XDG_RUNTIME_DIR=/run/user/wolf

# ====================================================================
# Expose ports (Wolf + Moonlight Web)
# ====================================================================

# Moonlight protocol (Wolf)
EXPOSE 47984/tcp 47989/tcp 48010/tcp 47415/udp 47999/udp 48100/udp 48200/udp
# Moonlight Web UI + WebRTC
EXPOSE 8080/tcp 40000-40100/udp

# ====================================================================
# Labels
# ====================================================================

LABEL org.opencontainers.image.source="https://github.com/helixml/helix"
LABEL org.opencontainers.image.description="Helix Sandbox: Wolf + Moonlight Web + RevDial + DinD"

# ====================================================================
# Entrypoint (from GOW base-app, runs cont-init.d scripts then startup-app.sh)
# ====================================================================

ENTRYPOINT ["/entrypoint.sh"]
