# ====================================================================
# Helix Sandbox - Unified Container
# Architecture: Wolf + Moonlight Web + RevDial Client + Docker-in-Docker
# Based on: ~/pm/wolf/docker/wolf.Dockerfile (uses GOW base-app + cont-init.d)
# ====================================================================

# Use same base as Wolf (GOW gstreamer base-app with init system)
ARG BASE_IMAGE=ghcr.io/games-on-whales/gstreamer:1.26.7

# ====================================================================
# Stage 1: Build revdial-client (for Wolf, Moonlight Web, and sandbox connections)
# ====================================================================
FROM golang:1.24 AS revdial-builder
WORKDIR /build
COPY go.mod go.sum ./
RUN --mount=type=cache,target=/go/pkg/mod \
    go mod download
COPY api/ ./api/
RUN --mount=type=cache,target=/go/pkg/mod \
    --mount=type=cache,target=/root/.cache/go-build \
    CGO_ENABLED=0 go build -ldflags "-s -w" -o /revdial-client ./api/cmd/revdial-client

# ====================================================================
# Stage 2: Build Moonlight Web
# ====================================================================
FROM rust:latest AS moonlight-web-builder

# Use release mode for production (or debug for faster builds)
ARG BUILD_MODE=release

# Install Rust nightly (required by moonlight-web-stream)
RUN rustup default nightly

# Install build dependencies
RUN apt-get update && apt-get install -y \
    procps \
    curl \
    cmake \
    libssl-dev \
    pkg-config \
    clang \
    libclang-dev \
    nodejs \
    npm \
    && rm -rf /var/lib/apt/lists/*

# Use system OpenSSL (prevents slow perl-based OpenSSL compilation)
ENV OPENSSL_NO_VENDOR=1
ENV OPENSSL_DIR=/usr
ENV OPENSSL_LIB_DIR=/usr/lib/x86_64-linux-gnu
ENV OPENSSL_INCLUDE_DIR=/usr/include

WORKDIR /build

# NOTE: In production, copy Moonlight Web source here
# For now, we'll copy from upstream image in final stage
# COPY moonlight-web-stream/ .
# RUN --mount=type=cache,target=/usr/local/cargo/registry \
#     --mount=type=cache,target=/build/target \
#     cargo build --release && \
#     cp /build/target/release/web-server /tmp/web-server && \
#     cp /build/target/release/streamer /tmp/streamer

# ====================================================================
# Stage 3: Get Wolf binary (use local image)
# ====================================================================
FROM wolf:helix-fixed AS wolf-upstream
# Using local Wolf image built from ~/pm/wolf

# ====================================================================
# Stage 4: Get Moonlight Web binaries (use local image)
# ====================================================================
FROM helix-moonlight-web:helix-fixed AS moonlight-web-upstream
# Using local Moonlight Web image

# ====================================================================
# Stage 5: Final unified sandbox image
# ====================================================================
FROM $BASE_IMAGE AS sandbox

ENV DEBIAN_FRONTEND=noninteractive

# ====================================================================
# Install all runtime dependencies (Wolf + Moonlight Web + Docker)
# ====================================================================

# Wolf runtime dependencies (from wolf.Dockerfile lines 99-110)
RUN apt-get update -y && \
    apt-get install -y --no-install-recommends \
    ca-certificates \
    libssl3 \
    libicu76 \
    libevdev2 \
    libudev1 \
    libcurl4 \
    libdrm2 \
    libpci3 \
    libunwind8 \
    && rm -rf /var/lib/apt/lists/*

# Debug tools for deadlock investigation (from wolf.Dockerfile lines 113-122)
RUN apt-get update -y && \
    apt-get install -y --no-install-recommends \
    gdb \
    strace \
    ltrace \
    lsof \
    procps \
    htop \
    binutils \
    && rm -rf /var/lib/apt/lists/*

# gst-plugin-wayland runtime dependencies (from wolf.Dockerfile lines 147-151)
RUN apt-get update -y && \
    apt-get install -y --no-install-recommends \
    libwayland-server0 libinput10 libxkbcommon0 libgbm1 \
    libglvnd0 libgl1 libglx0 libegl1 libgles2 xwayland hwdata \
    && rm -rf /var/lib/apt/lists/*

# Docker + NVIDIA Container Toolkit (from wolf.Dockerfile lines 154-182)
RUN apt-get update -y && \
    apt-get install -y --no-install-recommends \
    ca-certificates \
    curl \
    gnupg \
    lsb-release \
    && mkdir -p /etc/apt/keyrings \
    && curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /etc/apt/keyrings/docker.gpg \
    && echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | tee /etc/apt/sources.list.d/docker.list > /dev/null \
    && apt-get update -y \
    && apt-get install -y --no-install-recommends \
    docker-ce-cli \
    docker-ce \
    containerd.io \
    docker-buildx-plugin \
    docker-compose-plugin \
    && rm -rf /var/lib/apt/lists/*

# NVIDIA Container Toolkit (from wolf.Dockerfile lines 174-182)
RUN curl -fsSL https://nvidia.github.io/libnvidia-container/gpgkey | gpg --dearmor -o /usr/share/keyrings/nvidia-container-toolkit-keyring.gpg \
    && curl -s -L https://nvidia.github.io/libnvidia-container/stable/deb/nvidia-container-toolkit.list | \
        sed 's#deb https://#deb [signed-by=/usr/share/keyrings/nvidia-container-toolkit-keyring.gpg] https://#g' | \
        tee /etc/apt/sources.list.d/nvidia-container-toolkit.list \
    && apt-get update -y \
    && apt-get install -y --no-install-recommends \
    nvidia-container-toolkit \
    nvidia-container-runtime \
    && rm -rf /var/lib/apt/lists/*

# ====================================================================
# Copy Wolf binaries and setup
# ====================================================================

WORKDIR /wolf
ENV WOLF_CFG_FOLDER=/etc/wolf/cfg

# Copy Wolf binaries from upstream (or from wolf-builder if building from source)
COPY --from=wolf-upstream /wolf/wolf /wolf/wolf
COPY --from=wolf-upstream /wolf/fake-udev /wolf/fake-udev

# Copy Wolf's GStreamer plugins (custom compositor)
ENV GST_PLUGIN_PATH=/usr/local/lib/x86_64-linux-gnu/gstreamer-1.0/
COPY --from=wolf-upstream $GST_PLUGIN_PATH /usr/local/lib/x86_64-linux-gnu/gstreamer-1.0/
COPY --from=wolf-upstream /usr/local/lib/liblibgstwaylanddisplay* /usr/local/lib/

# Copy Wolf's init scripts and config template
RUN mkdir -p /opt/wolf-defaults /opt/images
COPY --from=wolf-upstream /opt/wolf-defaults/config.toml.template /opt/wolf-defaults/config.toml.template
COPY --from=wolf-upstream /etc/cont-init.d/05-init-wolf-config.sh /etc/cont-init.d/05-init-wolf-config.sh
RUN chmod +x /etc/cont-init.d/05-init-wolf-config.sh

# Copy helix-sway tarball and hash file (will be loaded by start-dockerd.sh)
COPY helix-sway.tar.gz /opt/images/helix-sway.tar.gz
COPY helix-sway.tar.gz.hash /opt/images/helix-sway.tar.gz.hash

# Create complete start-dockerd.sh script (based on ~/pm/wolf/docker/start-dockerd.sh with Helix additions)
COPY <<'DOCKERD_SCRIPT' /etc/cont-init.d/04-start-dockerd.sh
#!/bin/bash
set -e

echo "ðŸ³ Starting Wolf's isolated dockerd..."

# Clean up stale PID files (common issue with Docker restarts)
if [ -f /var/run/docker.pid ]; then
    echo "ðŸ§¹ Cleaning up stale docker.pid file"
    rm -f /var/run/docker.pid
fi

# Clean up stale containerd PID file (prevents "timeout waiting for containerd to start")
if [ -f /run/docker/containerd/containerd.pid ]; then
    echo "ðŸ§¹ Cleaning up stale containerd.pid file"
    rm -f /run/docker/containerd/containerd.pid
fi

# Use iptables-legacy for DinD compatibility
export PATH="/usr/local/sbin/.iptables-legacy:$PATH"
echo "Using iptables-legacy for Docker-in-Docker networking compatibility"

# Configure dockerd with NVIDIA runtime
mkdir -p /etc/docker
cat > /etc/docker/daemon.json <<'DAEMON_JSON'
{
  "runtimes": {
    "nvidia": {
      "path": "nvidia-container-runtime",
      "runtimeArgs": []
    }
  },
  "storage-driver": "overlay2",
  "log-level": "error"
}
DAEMON_JSON

echo "Configured Wolf's dockerd with nvidia runtime support"

# Start dockerd in background (redirect to stdout with prefix for unified logs)
dockerd --config-file /etc/docker/daemon.json \
    --host=unix:///var/run/docker.sock \
    2>&1 | sed 's/^/[DOCKERD] /' &

DOCKERD_PID=$!
echo "Started dockerd with PID: $DOCKERD_PID"

# Wait for dockerd to be ready
TIMEOUT=30
ELAPSED=0
until docker info >/dev/null 2>&1; do
    if [ $ELAPSED -ge $TIMEOUT ]; then
        echo "âŒ ERROR: dockerd failed to start within $TIMEOUT seconds"
        echo "Check dockerd logs above for details"
        exit 1
    fi
    echo "Waiting for dockerd... ($ELAPSED/$TIMEOUT)"
    sleep 1
    ELAPSED=$((ELAPSED + 1))
done

echo "âœ… Wolf's dockerd is ready!"
docker info 2>&1 | head -5

# Enable forwarding for nested containers
iptables -P FORWARD ACCEPT
echo "âœ… iptables FORWARD policy set to ACCEPT"

# Create helix_default network
if ! docker network inspect helix_default >/dev/null 2>&1; then
    echo "Creating helix_default network (subnet 172.20.0.0/16)..."
    docker network create helix_default --subnet 172.20.0.0/16 --gateway 172.20.0.1
    echo "âœ… helix_default network created"
else
    echo "helix_default network already exists"
fi

# Load helix-sway image into sandbox's dockerd (with hash-based skip optimization)
if [ -f /opt/images/helix-sway.tar.gz ]; then
    # Check if image already loaded with same hash (optimization to skip expensive docker load)
    SHOULD_LOAD=true
    if [ -f /opt/images/helix-sway.tar.gz.hash ]; then
        EXPECTED_HASH=$(cat /opt/images/helix-sway.tar.gz.hash)
        CURRENT_HASH=$(docker images helix-sway:latest --format '{{.ID}}' 2>/dev/null || echo "")

        if [ "$CURRENT_HASH" = "$EXPECTED_HASH" ] && [ -n "$CURRENT_HASH" ]; then
            echo "âœ… helix-sway:latest already loaded (hash: $CURRENT_HASH) - skipping docker load"
            SHOULD_LOAD=false
        else
            echo "ðŸ“¦ Loading helix-sway image into sandbox's dockerd (current: $CURRENT_HASH, expected: $EXPECTED_HASH)..."
        fi
    else
        echo "ðŸ“¦ Loading helix-sway image into sandbox's dockerd..."
    fi

    if [ "$SHOULD_LOAD" = true ]; then
        if docker load -i /opt/images/helix-sway.tar.gz 2>&1 | tee /tmp/docker-load.log; then
            echo "âœ… helix-sway:latest loaded successfully"
        else
            echo "âš ï¸  Failed to load helix-sway tarball (may be corrupted or out of memory)"
            echo "   Container will continue startup - transfer fresh image with './stack build-sway'"
        fi
    fi
else
    echo "âš ï¸  helix-sway tarball not found (sandboxes may fail to start)"
fi
DOCKERD_SCRIPT
RUN chmod +x /etc/cont-init.d/04-start-dockerd.sh

# ====================================================================
# Copy Moonlight Web binaries and setup
# ====================================================================

WORKDIR /opt/moonlight-web

# Copy Moonlight Web binaries from upstream
COPY --from=moonlight-web-upstream /app/web-server /opt/moonlight-web/moonlight-web
COPY --from=moonlight-web-upstream /app/streamer /opt/moonlight-web/streamer
COPY --from=moonlight-web-upstream /app/dist /opt/moonlight-web/dist
COPY --from=moonlight-web-upstream /app/static /opt/moonlight-web/static

# Copy Moonlight Web templates and init script
RUN mkdir -p /opt/moonlight-web/templates /opt/moonlight-web/server
COPY --from=moonlight-web-upstream /app/templates/ /opt/moonlight-web/templates/
COPY --from=moonlight-web-upstream /app/init-moonlight-config.sh /opt/moonlight-web/init-moonlight-config.sh
RUN chmod +x /opt/moonlight-web/init-moonlight-config.sh

# Create symlinks for Moonlight Web init script compatibility
# The upstream init script expects binaries in /app/, but we have them in /opt/moonlight-web/
RUN mkdir -p /app && \
    ln -s /opt/moonlight-web/moonlight-web /app/web-server && \
    ln -s /opt/moonlight-web/streamer /app/streamer && \
    ln -s /opt/moonlight-web/dist /app/dist && \
    ln -s /opt/moonlight-web/static /app/static && \
    ln -s /opt/moonlight-web/templates /app/templates && \
    ln -s /opt/moonlight-web/server /app/server

# ====================================================================
# Copy revdial-client
# ====================================================================

COPY --from=revdial-builder /revdial-client /usr/local/bin/revdial-client
RUN chmod +x /usr/local/bin/revdial-client

# ====================================================================
# Create cont-init.d scripts for Moonlight Web and RevDial
# (Following Wolf's pattern: /etc/cont-init.d/*.sh runs before main process)
# ====================================================================

# 06: Initialize and start Moonlight Web (runs after Wolf config init)
# Use the upstream init script with modified Wolf address (localhost instead of wolf)
RUN cat > /etc/cont-init.d/06-start-moonlight-web.sh << 'EOF'
#!/bin/bash
set -e
echo "ðŸŒ™ Initializing Moonlight Web..."

DATA_FILE="/opt/moonlight-web/server/data.json"
CONFIG_FILE="/opt/moonlight-web/server/config.json"
DATA_TEMPLATE="/opt/moonlight-web/templates/data.json.template"
CONFIG_TEMPLATE="/opt/moonlight-web/templates/config.json.template"

mkdir -p /opt/moonlight-web/server

# Initialize data.json if it doesn't exist or is empty
if [ ! -f "$DATA_FILE" ] || [ ! -s "$DATA_FILE" ]; then
    echo "ðŸ”§ Initializing moonlight-web data.json from template..."
    # Wolf is on localhost in unified sandbox container
    sed 's/"address": "wolf"/"address": "localhost"/' "$DATA_TEMPLATE" > "$DATA_FILE"
    HELIX_HOSTNAME=${HELIX_HOSTNAME:-local}
    sed -i "s/{{HELIX_HOSTNAME}}/$HELIX_HOSTNAME/g" "$DATA_FILE"
    echo "âœ… moonlight-web data.json initialized"
fi

# Initialize config.json with dynamic TURN server IP
if [ ! -f "$CONFIG_FILE" ] || [ ! -s "$CONFIG_FILE" ]; then
    echo "ðŸ”§ Initializing moonlight-web config.json from template..."

    # Use environment variables or defaults for dev mode
    MOONLIGHT_CREDENTIALS=${MOONLIGHT_CREDENTIALS:-helix:helix}
    TURN_PASSWORD=${TURN_PASSWORD:-helix-turn-secret}
    TURN_PUBLIC_IP=${TURN_PUBLIC_IP:-}

    # Auto-detect public IP if TURN_PUBLIC_IP not set
    if [ -z "$TURN_PUBLIC_IP" ]; then
        echo "â³ Auto-detecting public IP for TURN server..."
        TURN_PUBLIC_IP=$(curl -s --max-time 2 https://api.ipify.org 2>/dev/null || echo "127.0.0.1")
        echo "âœ… Using TURN IP: $TURN_PUBLIC_IP"
    fi

    # Substitute template variables
    sed -e "s/{{TURN_PUBLIC_IP}}/$TURN_PUBLIC_IP/g" \
        -e "s/{{MOONLIGHT_CREDENTIALS}}/$MOONLIGHT_CREDENTIALS/g" \
        -e "s/{{TURN_PASSWORD}}/$TURN_PASSWORD/g" \
        "$CONFIG_TEMPLATE" > "$CONFIG_FILE"
    echo "âœ… moonlight-web config.json initialized"
fi

# Start Moonlight Web daemon in background (redirect to stdout with prefix)
cd /opt/moonlight-web
./moonlight-web 2>&1 | sed 's/^/[MOONLIGHT] /' &
MOONLIGHT_PID=$!
echo "âœ… Moonlight Web started (PID: $MOONLIGHT_PID)"
EOF
RUN chmod +x /etc/cont-init.d/06-start-moonlight-web.sh

# 06b: Auto-pair Moonlight Web with Wolf (runs AFTER both are started)
# This script is sourced by startup-app.sh after Wolf starts
RUN cat > /opt/moonlight-web/auto-pair.sh << 'EOF'
#!/bin/bash
# Auto-pair Moonlight Web with Wolf
# Both services must be running before this executes

echo "ðŸ”— Auto-pairing Moonlight Web with Wolf..."

# Wait for Wolf API to be ready
MAX_ATTEMPTS=10
ATTEMPT=0
while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
    if curl -s --unix-socket /var/run/wolf/wolf.sock http://localhost/api/v1/config >/dev/null 2>&1; then
        echo "âœ… Wolf API is ready"
        break
    fi
    echo "â³ Waiting for Wolf API... ($ATTEMPT/$MAX_ATTEMPTS)"
    sleep 1
    ATTEMPT=$((ATTEMPT + 1))
done

if [ $ATTEMPT -ge $MAX_ATTEMPTS ]; then
    echo "âš ï¸  Wolf API not ready after ${MAX_ATTEMPTS}s, skipping auto-pairing"
    exit 0
fi

# Get Wolf's pairing PIN
WOLF_PIN=$(curl -s --unix-socket /var/run/wolf/wolf.sock http://localhost/api/v1/pairing/pin | jq -r '.pin' 2>/dev/null)
if [ -z "$WOLF_PIN" ] || [ "$WOLF_PIN" = "null" ]; then
    echo "âš ï¸  Failed to get Wolf pairing PIN, skipping auto-pairing"
    exit 0
fi

echo "ðŸ” Got Wolf pairing PIN: $WOLF_PIN"

# Pair Moonlight Web with Wolf
MOONLIGHT_CREDS=${MOONLIGHT_CREDENTIALS:-helix}
PAIR_RESPONSE=$(curl -s -X POST http://localhost:8080/api/host/pair \
    -H "Authorization: Bearer $MOONLIGHT_CREDS" \
    -H "Content-Type: application/json" \
    -d "{\"pin\": \"$WOLF_PIN\"}")

if echo "$PAIR_RESPONSE" | grep -q "success\|paired"; then
    echo "âœ… Moonlight Web auto-paired with Wolf"
else
    echo "âš ï¸  Auto-pairing response: $PAIR_RESPONSE"
fi
EOF
RUN chmod +x /opt/moonlight-web/auto-pair.sh

# 07: Start RevDial clients for Wolf and Moonlight Web (optional, only if HELIX_API_URL is set)
RUN cat > /etc/cont-init.d/07-start-revdial-clients.sh << 'EOF'
#!/bin/bash
set -e

# Skip if no control plane configured (local dev mode)
if [ -z "$HELIX_API_URL" ] || [ -z "$RUNNER_TOKEN" ]; then
    echo "â„¹ï¸  No HELIX_API_URL set, skipping RevDial clients (local mode)"
    exit 0
fi

WOLF_INSTANCE_ID=${WOLF_INSTANCE_ID:-local}
echo "ðŸ”— Starting RevDial clients..."
echo "   Control Plane: $HELIX_API_URL"
echo "   Wolf Instance ID: $WOLF_INSTANCE_ID"

# Start Wolf API RevDial client (proxies Wolf Unix socket, redirect to stdout with prefix)
# Use cgo DNS resolver to work around Go DNS issues in Docker
GODEBUG=netdns=cgo /usr/local/bin/revdial-client \
    -server "$HELIX_API_URL/api/v1/revdial" \
    -runner-id "wolf-$WOLF_INSTANCE_ID" \
    -token "$RUNNER_TOKEN" \
    -local "unix:///var/run/wolf/wolf.sock" \
    2>&1 | sed 's/^/[WOLF-REVDIAL] /' &
WOLF_REVDIAL_PID=$!

# Start Moonlight Web API RevDial client (proxies Moonlight Web HTTP server, redirect to stdout)
# Use cgo DNS resolver to work around Go DNS issues in Docker
GODEBUG=netdns=cgo /usr/local/bin/revdial-client \
    -server "$HELIX_API_URL/api/v1/revdial" \
    -runner-id "moonlight-$WOLF_INSTANCE_ID" \
    -token "$RUNNER_TOKEN" \
    -local "127.0.0.1:8080" \
    2>&1 | sed 's/^/[MOONLIGHT-REVDIAL] /' &
MOONLIGHT_REVDIAL_PID=$!

echo "âœ… Wolf RevDial client started (PID: $WOLF_REVDIAL_PID)"
echo "âœ… Moonlight Web RevDial client started (PID: $MOONLIGHT_REVDIAL_PID)"
EOF
RUN chmod +x /etc/cont-init.d/07-start-revdial-clients.sh

# 08: Start Wolf instance heartbeat (sends periodic heartbeats to API)
RUN cat > /etc/cont-init.d/08-start-wolf-heartbeat.sh << 'EOF'
#!/bin/bash
set -e

# Skip if no control plane configured (local dev mode)
if [ -z "$HELIX_API_URL" ] || [ -z "$RUNNER_TOKEN" ]; then
    echo "â„¹ï¸  No HELIX_API_URL set, skipping Wolf heartbeat (local mode)"
    exit 0
fi

WOLF_INSTANCE_ID=${WOLF_INSTANCE_ID:-local}
echo "ðŸ’“ Starting Wolf heartbeat service for instance: $WOLF_INSTANCE_ID"

# Start heartbeat loop in background
(
    while true; do
        # Send heartbeat to API
        if curl -sf -X POST \
            -H "Authorization: Bearer $RUNNER_TOKEN" \
            "$HELIX_API_URL/api/v1/wolf-instances/$WOLF_INSTANCE_ID/heartbeat" \
            >/dev/null 2>&1; then
            echo "[$(date -Iseconds)] âœ… Heartbeat sent successfully"
        else
            echo "[$(date -Iseconds)] âš ï¸  Heartbeat failed (API may not be ready yet)"
        fi

        # Sleep for 30 seconds before next heartbeat
        sleep 30
    done
) 2>&1 | sed 's/^/[HEARTBEAT] /' &

HEARTBEAT_PID=$!
echo "âœ… Wolf heartbeat service started (PID: $HEARTBEAT_PID)"
EOF
RUN chmod +x /etc/cont-init.d/08-start-wolf-heartbeat.sh

# 09: Setup telemetry firewall for nested agent containers
# Fixed: Create /wolf/sway-config directory before writing update script
COPY wolf/sway-config/setup-telemetry-firewall.sh /etc/cont-init.d/09-setup-telemetry-firewall.sh
RUN chmod +x /etc/cont-init.d/09-setup-telemetry-firewall.sh

# ====================================================================
# Create main startup script (starts Wolf in foreground)
# (Replaces /opt/gow/startup-app.sh - Wolf is the main process)
# ====================================================================

RUN cat > /opt/gow/startup-app.sh << 'EOF'
#!/bin/bash
set -e

# This script is executed by GOW's /entrypoint.sh after all cont-init.d scripts
# At this point:
#   - dockerd is running (started by 04-start-dockerd.sh)
#   - Wolf config is initialized (05-init-wolf-config.sh)
#   - Moonlight Web config is initialized (06-init-moonlight-config.sh)
#   - Moonlight Web daemon is running (07-start-moonlight-web.sh)
#   - RevDial client daemon is running if configured (08-start-revdial-client.sh)

echo "ðŸº Starting Wolf (main process)..."

# Make sure Wolf config folder exists
export WOLF_CFG_FOLDER=$HOST_APPS_STATE_FOLDER/cfg
mkdir -p $WOLF_CFG_FOLDER
export WOLF_CFG_FILE=$WOLF_CFG_FOLDER/config.toml
export WOLF_PRIVATE_KEY_FILE=$WOLF_CFG_FOLDER/key.pem
export WOLF_PRIVATE_CERT_FILE=$WOLF_CFG_FOLDER/cert.pem

# Set default values for environment variables
export WOLF_RENDER_NODE=${WOLF_RENDER_NODE:-/dev/dri/renderD128}
export WOLF_ENCODER_NODE=${WOLF_ENCODER_NODE:-$WOLF_RENDER_NODE}
export GST_GL_DRM_DEVICE=${GST_GL_DRM_DEVICE:-$WOLF_ENCODER_NODE}

# Update fake-udev path
export WOLF_DOCKER_FAKE_UDEV_PATH=${WOLF_DOCKER_FAKE_UDEV_PATH:-$HOST_APPS_STATE_FOLDER/fake-udev}
cp /wolf/fake-udev $WOLF_DOCKER_FAKE_UDEV_PATH

# Start auto-pairing in background (after Wolf starts)
# This runs async so it doesn't block Wolf startup
(sleep 5 && /opt/moonlight-web/auto-pair.sh) 2>&1 | sed 's/^/[PAIRING] /' &

# Start Wolf in foreground (main process, keeps container alive)
cd /wolf
exec /wolf/wolf
EOF
RUN chmod +x /opt/gow/startup-app.sh

# ====================================================================
# Wolf environment variables (from wolf.Dockerfile lines 207-225)
# ====================================================================

ENV GST_GL_API=gles2 \
    GST_GL_PLATFORM=egl \
    GST_GL_WINDOW=surfaceless \
    WOLF_USE_ZERO_COPY=TRUE \
    WOLF_LOG_LEVEL=INFO \
    WOLF_CFG_FILE=$WOLF_CFG_FOLDER/config.toml \
    WOLF_PRIVATE_KEY_FILE=$WOLF_CFG_FOLDER/key.pem \
    WOLF_PRIVATE_CERT_FILE=$WOLF_CFG_FOLDER/cert.pem \
    WOLF_PULSE_IMAGE=ghcr.io/games-on-whales/pulseaudio:master \
    WOLF_RENDER_NODE=/dev/dri/renderD128 \
    WOLF_STOP_CONTAINER_ON_EXIT=TRUE \
    WOLF_DOCKER_SOCKET=/var/run/docker.sock \
    RUST_BACKTRACE=full \
    RUST_LOG=WARN \
    HOST_APPS_STATE_FOLDER=/etc/wolf \
    GST_DEBUG=2 \
    PUID=0 \
    PGID=0 \
    UNAME="root"

# Helix sandbox environment variables
ENV HELIX_API_URL="" \
    WOLF_ID="" \
    RUNNER_TOKEN="" \
    GPU_TYPE="nvidia" \
    MAX_SANDBOXES="10" \
    HELIX_DEV_MODE="false" \
    ZED_IMAGE="helix-sway:latest"

# XDG_RUNTIME_DIR (creates volume when starting container)
VOLUME /run/user/wolf/
ENV XDG_RUNTIME_DIR=/run/user/wolf

# ====================================================================
# Expose ports (Wolf + Moonlight Web)
# ====================================================================

# Moonlight protocol (Wolf)
EXPOSE 47984/tcp 47989/tcp 48010/tcp 47415/udp 47999/udp 48100/udp 48200/udp
# Moonlight Web UI + WebRTC
EXPOSE 8080/tcp 40000-40100/udp

# ====================================================================
# Labels
# ====================================================================

LABEL org.opencontainers.image.source="https://github.com/helixml/helix"
LABEL org.opencontainers.image.description="Helix Sandbox: Wolf + Moonlight Web + RevDial + DinD"

# ====================================================================
# Entrypoint (from GOW base-app, runs cont-init.d scripts then startup-app.sh)
# ====================================================================

ENTRYPOINT ["/entrypoint.sh"]
