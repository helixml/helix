# Wolf API Bug Report: Missing video_producer_buffer_caps Field

## Summary
API-created apps produce malformed GStreamer video producer pipelines due to missing `video_producer_buffer_caps` field in the API schema and handlers, while TOML-loaded apps work correctly.

## Observed Behavior
API-created apps generate this malformed pipeline:
```
waylanddisplaysrc name=wolf_wayland_source render_node=/dev/dri/renderD128 ! , width=3840, height=2160, framerate=60/1 !
interpipesink sync=true async=false name=342532221405053742_video max-buffers=1
```

Note the stray comma after the first `!` - this indicates an empty `buffer_format` parameter.

## Root Cause Analysis

### 1. Pipeline Generation Code
In `src/moonlight-server/streaming/streaming.cpp:75-79`:
```cpp
auto pipeline = fmt::format("waylanddisplaysrc name=wolf_wayland_source "
                            "render_node={render_node} ! "
                            "{buffer_format}, width={width}, height={height}, framerate={fps}/1 ! \n"
                            "interpipesink sync=true async=false name={session_id}_video max-buffers=1",
                            fmt::arg("buffer_format", buffer_format), // <-- This is empty for API apps
                            // ... other args
```

The `buffer_format` parameter comes from `session->app->video_producer_buffer_caps` (wolf.cpp:242).

### 2. TOML Apps Work Correctly
In `src/moonlight-server/state/configTOML.cpp:199-203, 313-314`:
```cpp
std::string default_video_producer_buffer_caps = "video/x-raw";
if (use_zero_copy) {
  switch (video_encoder) {
  case NVIDIA: {
    default_video_producer_buffer_caps = "video/x-raw(memory:DMABuf)";
    break;
  }
  // ... other cases
}

// Later in app creation:
.video_producer_buffer_caps = app_video_settings.producer_buffer_caps.value_or(default_video_producer_buffer_caps)
```

TOML apps get proper defaults based on encoder type.

### 3. API Apps Missing Field
Three locations where `video_producer_buffer_caps` is missing:

#### A. API Schema (`src/moonlight-server/events/reflectors.hpp:29-46`)
```cpp
template <> struct Reflector<events::App> {
  struct ReflType {
    const std::string title;
    const std::string id;
    const bool support_hdr;
    std::optional<std::string> icon_png_path;

    std::string h264_gst_pipeline;
    std::string hevc_gst_pipeline;
    std::string av1_gst_pipeline;
    std::string render_node;
    std::string opus_gst_pipeline;
    bool start_virtual_compositor;
    bool start_audio_server;
    rfl::TaggedUnion<"type", AppCMD, AppDocker, AppChildSession> runner;

    // ❌ MISSING: std::string video_producer_buffer_caps;
  };
```

#### B. API Response Serialization (`src/moonlight-server/events/reflectors.hpp:48-61`)
```cpp
static ReflType from(const events::App &v) {
  return {.title = v.base.title,
          .id = v.base.id,
          .support_hdr = v.base.support_hdr,
          .icon_png_path = v.base.icon_png_path,
          .h264_gst_pipeline = v.h264_gst_pipeline,
          .hevc_gst_pipeline = v.hevc_gst_pipeline,
          .av1_gst_pipeline = v.av1_gst_pipeline,
          .render_node = v.render_node,
          .opus_gst_pipeline = v.opus_gst_pipeline,
          .start_virtual_compositor = v.start_virtual_compositor,
          .start_audio_server = v.start_audio_server,
          .runner = v.runner->serialize()};

  // ❌ MISSING: .video_producer_buffer_caps = v.video_producer_buffer_caps
}
```

#### C. API Request Deserialization (`src/moonlight-server/api/endpoints.cpp:98-108`)
```cpp
return apps.push_back(events::App{
    .base = {.title = app.title, .id = app.id, .support_hdr = app.support_hdr, .icon_png_path = app.icon_png_path},
    .h264_gst_pipeline = app.h264_gst_pipeline,
    .hevc_gst_pipeline = app.hevc_gst_pipeline,
    .av1_gst_pipeline = app.av1_gst_pipeline,
    .render_node = app.render_node,
    .opus_gst_pipeline = app.opus_gst_pipeline,
    .start_virtual_compositor = app.start_virtual_compositor,
    .runner = runner,

    // ❌ MISSING: .video_producer_buffer_caps = app.video_producer_buffer_caps
});
```

### 4. Internal Struct Has the Field
The internal `events::App` struct correctly includes the field (`src/moonlight-server/events/events.hpp:64`):
```cpp
struct App {
  moonlight::App base;
  std::string video_producer_buffer_caps;  // ✅ Exists internally
  // ... other fields
}
```

## Impact
- API-created apps fail to start streaming with GStreamer syntax errors
- Only TOML-loaded apps work for streaming
- This creates API vs configuration file inconsistency

## Fix Required
1. Add `std::string video_producer_buffer_caps;` to `ReflType` in `reflectors.hpp`
2. Add `.video_producer_buffer_caps = v.video_producer_buffer_caps` to `from()` method
3. Add `.video_producer_buffer_caps = app.video_producer_buffer_caps` to `endpoint_AddApp()`
4. Optionally: Add default value logic similar to TOML processing

## Environment
- Wolf version: stable branch (upstream/stable)
- GPU: NVIDIA (expecting "video/x-raw(memory:DMABuf)" format)
- Platform: Linux

## Test Case
Create app via API with all required fields - video producer pipeline will fail due to empty buffer_format causing malformed GStreamer syntax.