kind: pipeline
type: docker
name: default

trigger:
  event:
    - push

workspace:
  base: /go
  path: src/github.com/helix-ml/helix

steps:
- name: build-backend
  image: golang:1.24-alpine3.21
  environment:
    GITHUB_TOKEN:
      from_secret: github_token
  commands:
    - go build
  when:
    event:
    - tag
  depends_on: []

- name: build-frontend
  image: node:23-alpine
  commands:
    - cd frontend
    - yarn install
    - yarn test
    - yarn build
  depends_on: []

- name: run-linter
  image: golangci/golangci-lint:v1.64-alpine
  commands:
    - golangci-lint cache clean
    - golangci-lint run
  when:
    event:
    - push
  depends_on: []

- name: check-for-secrets
  description: "Run gitleaks to detect secrets in the codebase"
  image: ghcr.io/gitleaks/gitleaks:v8.24.0
  commands:
    - gitleaks dir -v
  when:
    event:
    - push
  depends_on: []

- name: unit-test
  image: golang:1.24-alpine3.21
  environment:
    # Disabled until tested with togetherai
    DISABLE_AGENT_TESTS: "true"
    OPENAI_API_KEY:
      from_secret: openai_tools
    TOGETHER_API_KEY:
      from_secret: openai_api_key
    TOGETHER_BASE_URL:
      from_secret: openai_base_url
    # Database config (running in a sidecar)
    POSTGRES_HOST: postgres
    POSTGRES_PORT: "5432"
    POSTGRES_USER: postgres
    POSTGRES_PASSWORD: postgres
    POSTGRES_DATABASE: postgres
    TYPESENSE_URL: http://typesense:8108
    TYPESENSE_API_KEY: typesense
    TEXT_EXTRACTION_TIKA_URL: http://tika:9998
    RAG_CRAWLER_LAUNCHER_URL: http://chrome:7317
    KEYCLOAK_URL: http://keycloak:8080/auth
    KEYCLOAK_FRONTEND_URL: http://keycloak:8080/auth/
    KEYCLOAK_PASSWORD: REPLACE_ME
    
  commands:
    - cd api
    - go test -v -tags='!oauth_integration' ./...
  when:
    event:
    - push
  # depends_on: [unit-test]

- name: api-integration-test
  image: golang:1.24-alpine3.21
  environment:
    OPENAI_API_KEY:
      from_secret: openai_tools
    TOGETHER_API_KEY:
      from_secret: openai_api_key
    TOGETHER_BASE_URL:
      from_secret: openai_base_url
    # Database config (running in a sidecar)
    POSTGRES_HOST: postgres
    POSTGRES_PORT: "5432"
    POSTGRES_USER: postgres
    POSTGRES_PASSWORD: postgres
    POSTGRES_DATABASE: postgres
    TYPESENSE_URL: http://typesense:8108
    TYPESENSE_API_KEY: typesense
    TEXT_EXTRACTION_TIKA_URL: http://tika:9998
    RAG_CRAWLER_LAUNCHER_URL: http://chrome:7317
    KEYCLOAK_URL: http://keycloak:8080/auth
    KEYCLOAK_FRONTEND_URL: http://keycloak:8080/auth/
    KEYCLOAK_PASSWORD: REPLACE_ME
    ORGANIZATIONS_CREATE_ENABLED_FOR_NON_ADMINS: "true"
    START_HELIX_TEST_SERVER: "true"
    # Agent configuration
    REASONING_MODEL_PROVIDER: openai
    REASONING_MODEL: o3-mini    
    REASONING_MODEL_EFFORT: none
    GENERATION_MODEL_PROVIDER: openai
    GENERATION_MODEL: gpt-4o
    SMALL_REASONING_MODEL_PROVIDER: openai
    SMALL_REASONING_MODEL: o3-mini
    SMALL_REASONING_MODEL_EFFORT: none
    SMALL_GENERATION_MODEL_PROVIDER: openai
    SMALL_GENERATION_MODEL: gpt-4o-mini

  commands:
    # Build API server
    - go install ./api/..
    # Run tests
    - cd integration-test/api
    - go test -v ./...
  when:
    event:
    - push
  # depends_on: [unit-test]

- name: oauth-integration-test
  image: golang:1.24-alpine3.21
  volumes:
  - name: oauth-test-results
    path: /tmp/helix-oauth-test-results
  environment:
    # GitHub OAuth test credentials
    GITHUB_SKILL_TEST_OAUTH_CLIENT_ID:
      from_secret: github_skill_test_oauth_client_id
    GITHUB_SKILL_TEST_OAUTH_CLIENT_SECRET:
      from_secret: github_skill_test_oauth_client_secret
    GITHUB_SKILL_TEST_OAUTH_USERNAME:
      from_secret: github_skill_test_oauth_username
    GITHUB_SKILL_TEST_OAUTH_PASSWORD:
      from_secret: github_skill_test_oauth_password
    GITHUB_SKILL_TEST_SETUP_PAT:
      from_secret: github_skill_test_setup_pat
    # Gmail credentials for device verification
    GMAIL_CREDENTIALS_BASE64:
      from_secret: gmail_credentials_base64
    # Database config (running in a sidecar)
    POSTGRES_HOST: postgres
    POSTGRES_PORT: "5432"
    POSTGRES_USER: postgres
    POSTGRES_PASSWORD: postgres
    POSTGRES_DATABASE: postgres
    TYPESENSE_URL: http://typesense:8108
    TYPESENSE_API_KEY: typesense
    TEXT_EXTRACTION_TIKA_URL: http://tika:9998
    RAG_CRAWLER_LAUNCHER_URL: http://chrome:7317
    KEYCLOAK_URL: http://keycloak:8080/auth
    KEYCLOAK_FRONTEND_URL: http://keycloak:8080/auth/
    KEYCLOAK_PASSWORD: REPLACE_ME
    ORGANIZATIONS_CREATE_ENABLED_FOR_NON_ADMINS: "true"
    # CI-specific configuration for OAuth test
    WEB_SERVER_HOST: "localhost"
    # API Keys for LLM providers
    OPENAI_API_KEY:
      from_secret: openai_api_key
    ANTHROPIC_API_KEY:
      from_secret: anthropic_api_key
    # Agent configuration
    REASONING_MODEL_PROVIDER: openai
    REASONING_MODEL: o3-mini    
    REASONING_MODEL_EFFORT: none
    GENERATION_MODEL_PROVIDER: openai
    GENERATION_MODEL: gpt-4o
    SMALL_REASONING_MODEL_PROVIDER: openai
    SMALL_REASONING_MODEL: o3-mini
    SMALL_REASONING_MODEL_EFFORT: none
    SMALL_GENERATION_MODEL_PROVIDER: openai
    SMALL_GENERATION_MODEL: gpt-4o-mini

  commands:
    # Ensure test results directory exists and has proper permissions
    - mkdir -p /tmp/helix-oauth-test-results
    - chmod 755 /tmp/helix-oauth-test-results
    # Run OAuth integration tests from the new location
    - cd integration-test/skills
    - |
      echo "=== Starting OAuth Integration Test ==="
      echo "Test results will be saved to: /tmp/helix-oauth-test-results"
      
      # Record test start time
      TEST_START_TIME=$(date +%s)
      echo "Test started at: $(date -d @$TEST_START_TIME)"
      
      # Run the test and capture exit code, but don't fail the step immediately
      set +e
      go test -v ./...
      TEST_EXIT_CODE=$?
      set -e
      
      # Record test end time and calculate duration
      TEST_END_TIME=$(date +%s)
      TEST_DURATION=$((TEST_END_TIME - TEST_START_TIME))
      echo "Test ended at: $(date -d @$TEST_END_TIME)"
      echo "Test duration: $TEST_DURATION seconds"
      
      # Write test results to file for upload step
      echo "exit_code=$TEST_EXIT_CODE" > /tmp/helix-oauth-test-results/test_result.txt
      echo "duration=$TEST_DURATION" >> /tmp/helix-oauth-test-results/test_result.txt
      echo "start_time=$TEST_START_TIME" >> /tmp/helix-oauth-test-results/test_result.txt
      echo "end_time=$TEST_END_TIME" >> /tmp/helix-oauth-test-results/test_result.txt
      
      # Determine human-readable status
      if [ "$TEST_EXIT_CODE" -eq 0 ]; then
        echo "status=passed" >> /tmp/helix-oauth-test-results/test_result.txt
        echo "=== OAuth Integration Test PASSED ==="
      else
        echo "status=failed" >> /tmp/helix-oauth-test-results/test_result.txt
        echo "=== OAuth Integration Test FAILED (exit code: $TEST_EXIT_CODE) ==="
      fi
      
      # List any artifacts that were created during the test
      echo "=== Test Results Directory Contents ==="
      if [ -d "/tmp/helix-oauth-test-results" ]; then
        ls -la /tmp/helix-oauth-test-results/ || echo "No files in test_results directory"
        echo "=== Screenshot Files ==="
        find /tmp/helix-oauth-test-results -name "*.png" -exec ls -l {} \; || echo "No screenshot files found"
        echo "=== Log Files ==="
        find /tmp/helix-oauth-test-results -name "*.log" -exec ls -l {} \; || echo "No log files found"
        echo "=== Conversation Files ==="
        find /tmp/helix-oauth-test-results -name "*conversation*.txt" -exec ls -l {} \; || echo "No conversation files found"
      else
        echo "test_results directory does not exist"
      fi
      
      # Exit with original test exit code
      exit $TEST_EXIT_CODE
  when:
    event:
    - push
  # depends_on: [unit-test]

- name: upload-oauth-test-artifacts
  image: alpine:latest
  volumes:
  - name: oauth-test-results
    path: /tmp/helix-oauth-test-results
  environment:
    LAUNCHPAD_URL: "https://deploy.helix.ml"
    CI_SHARED_SECRET:
      from_secret: ci_shared_secret
  commands:
    # Install required tools
    - apk add --no-cache curl zip
    # Debug environment variables
    - echo "DEBUG - LAUNCHPAD_URL='${LAUNCHPAD_URL}'"
    - echo "DEBUG - CI_SHARED_SECRET present='${CI_SHARED_SECRET:+YES}'"
    - echo "DEBUG - All environment variables:"
    - env | grep -E "(LAUNCHPAD|CI_)" | sort || echo "No matching environment variables found"
    - echo "DEBUG - Expected value should be 'https://deploy.helix.ml'"
    # Determine test status from actual test results file
    - |
      # Check if we have actual test results from the test step
      if [ -f "/tmp/helix-oauth-test-results/test_result.txt" ]; then
        echo "=== Reading actual test results ==="
        cat /tmp/helix-oauth-test-results/test_result.txt
        
        # Source the test results file to get variables
        . /tmp/helix-oauth-test-results/test_result.txt
        
        TEST_STATUS="$status"
        TEST_DURATION="$duration"
        TEST_EXIT_CODE="$exit_code"
        
        echo "Actual test status: $TEST_STATUS"
        echo "Actual test duration: $TEST_DURATION seconds"
        echo "Actual test exit code: $TEST_EXIT_CODE"
      else
        echo "=== No test results file found, using fallback ==="
        if [ "${DRONE_BUILD_STATUS}" = "success" ]; then
          TEST_STATUS="passed"
        else
          TEST_STATUS="failed"
        fi
        TEST_DURATION="unknown"
        TEST_EXIT_CODE="unknown"
        echo "Fallback test status: $TEST_STATUS"
        echo "Fallback test duration: $TEST_DURATION"
      fi
      
      # Construct Drone build URL
      DRONE_BUILD_URL="https://drone.lukemarsden.net/helixml/helix/${DRONE_BUILD_NUMBER}"
      echo "Drone build URL: $DRONE_BUILD_URL"
    # Create artifacts zip - include basic info even if test didn't run
    - cd /tmp
    - |
      echo "=== OAuth Test Artifacts Collection ==="
      echo "Collecting artifacts from: /tmp/helix-oauth-test-results"
      
      if [ -d "helix-oauth-test-results" ]; then
        echo "Test results directory exists"
        echo "=== Directory Contents ==="
        ls -la helix-oauth-test-results/ || echo "Directory exists but is empty"
        
        # Count different types of artifacts
        SCREENSHOT_COUNT=$(find helix-oauth-test-results -name "*.png" | wc -l)
        LOG_COUNT=$(find helix-oauth-test-results -name "*.log" | wc -l)
        CONVERSATION_COUNT=$(find helix-oauth-test-results -name "*conversation*.txt" | wc -l)
        
        echo "=== Artifact Summary ==="
        echo "Screenshots found: $SCREENSHOT_COUNT"
        echo "Log files found: $LOG_COUNT"
        echo "Conversation files found: $CONVERSATION_COUNT"
        
        if [ "$SCREENSHOT_COUNT" -gt 0 ]; then
          echo "=== Screenshot Files ==="
          find helix-oauth-test-results -name "*.png" -exec ls -l {} \;
        fi
        
        if [ "$LOG_COUNT" -gt 0 ]; then
          echo "=== Log Files ==="
          find helix-oauth-test-results -name "*.log" -exec ls -l {} \;
        fi
        
        if [ "$CONVERSATION_COUNT" -gt 0 ]; then
          echo "=== Conversation Files ==="
          find helix-oauth-test-results -name "*conversation*.txt" -exec ls -l {} \;
        fi
        
        # Check if there are any files at all
        if [ "$(find helix-oauth-test-results -type f | wc -l)" -gt 0 ]; then
          echo "Creating artifacts zip from test results"
          zip -r artifacts.zip helix-oauth-test-results/
          ARTIFACTS_FILE="artifacts.zip"
          echo "Artifacts zip created: $(ls -lh artifacts.zip)"
        else
          echo "No test result files found, creating basic artifact"
          echo "OAuth integration test run at $(date)" > helix-oauth-test-results/test_summary.txt
          echo "Build: ${DRONE_BUILD_NUMBER}" >> helix-oauth-test-results/test_summary.txt
          echo "Build URL: $DRONE_BUILD_URL" >> helix-oauth-test-results/test_summary.txt
          echo "Branch: ${DRONE_BRANCH}" >> helix-oauth-test-results/test_summary.txt
          echo "Commit: ${DRONE_COMMIT}" >> helix-oauth-test-results/test_summary.txt
          echo "Status: ${TEST_STATUS}" >> helix-oauth-test-results/test_summary.txt
          echo "Duration: ${TEST_DURATION} seconds" >> helix-oauth-test-results/test_summary.txt
          echo "Exit Code: ${TEST_EXIT_CODE}" >> helix-oauth-test-results/test_summary.txt
          echo "Note: Test failed before generating artifacts (likely GitHub device verification)" >> helix-oauth-test-results/test_summary.txt
          zip -r artifacts.zip helix-oauth-test-results/
          ARTIFACTS_FILE="artifacts.zip"
        fi
      else
        echo "Test results directory does not exist, creating basic artifact"
        mkdir -p helix-oauth-test-results
        echo "OAuth integration test run at $(date)" > helix-oauth-test-results/test_summary.txt
        echo "Build: ${DRONE_BUILD_NUMBER}" >> helix-oauth-test-results/test_summary.txt
        echo "Build URL: $DRONE_BUILD_URL" >> helix-oauth-test-results/test_summary.txt
        echo "Branch: ${DRONE_BRANCH}" >> helix-oauth-test-results/test_summary.txt
        echo "Commit: ${DRONE_COMMIT}" >> helix-oauth-test-results/test_summary.txt
        echo "Status: ${TEST_STATUS}" >> helix-oauth-test-results/test_summary.txt
        echo "Duration: ${TEST_DURATION} seconds" >> helix-oauth-test-results/test_summary.txt
        echo "Exit Code: ${TEST_EXIT_CODE}" >> helix-oauth-test-results/test_summary.txt
        echo "Note: Test failed before creating test_results directory" >> helix-oauth-test-results/test_summary.txt
        zip -r artifacts.zip helix-oauth-test-results/
        ARTIFACTS_FILE="artifacts.zip"
      fi
    # Upload to Launchpad with explicit URL construction
    - |
      # Don't override LAUNCHPAD_URL if it's already set from environment
      if [ -n "$LAUNCHPAD_URL" ] && [ -n "$CI_SHARED_SECRET" ]; then
        echo "Uploading test results to Launchpad at $LAUNCHPAD_URL"
        UPLOAD_URL="$LAUNCHPAD_URL/api/ci/test-results"
        echo "Upload URL: $UPLOAD_URL"
        echo "Artifact file: $ARTIFACTS_FILE"
        
        # Show curl command for debugging
        echo "curl -X POST -H 'X-CI-Secret: ***' -F 'branch=${DRONE_BRANCH}' -F 'commit=${DRONE_COMMIT}' -F 'build_number=${DRONE_BUILD_NUMBER}' -F 'build_url=$DRONE_BUILD_URL' -F 'test_type=oauth_integration' -F 'status=$TEST_STATUS' -F 'duration=$TEST_DURATION' -F 'exit_code=$TEST_EXIT_CODE' -F 'artifacts=@$ARTIFACTS_FILE' '$UPLOAD_URL'"
        
        # Execute the upload with verbose output
        curl -v -X POST \
          -H "X-CI-Secret: $CI_SHARED_SECRET" \
          -F "branch=${DRONE_BRANCH}" \
          -F "commit=${DRONE_COMMIT}" \
          -F "build_number=${DRONE_BUILD_NUMBER}" \
          -F "build_url=$DRONE_BUILD_URL" \
          -F "test_type=oauth_integration" \
          -F "status=$TEST_STATUS" \
          -F "duration=$TEST_DURATION" \
          -F "exit_code=$TEST_EXIT_CODE" \
          -F "artifacts=@$ARTIFACTS_FILE" \
          "$UPLOAD_URL"
      else
        echo "LAUNCHPAD_URL or CI_SHARED_SECRET not set, skipping test result upload"
        echo "LAUNCHPAD_URL: '${LAUNCHPAD_URL:-'(not set)'}'"
        if [ -n "$CI_SHARED_SECRET" ]; then
          echo "CI_SHARED_SECRET: '(set)'"
        else
          echo "CI_SHARED_SECRET: '(not set)'"
        fi
      fi
  when:
    event:
    - push
    status:
    - success
    - failure
  depends_on: [oauth-integration-test]

- name: release-backend
  image: golang:1.24-bullseye
  when:
    event:
    - tag
  environment:
    GITHUB_TOKEN:
      from_secret: github_token
  commands:
    - go install github.com/mitchellh/gox@latest
    - |
      if [ -n "$DRONE_TAG" ]; then
        VERSION_FLAG="-X github.com/helixml/helix/api/pkg/data.Version=$DRONE_TAG"
      else
        VERSION_FLAG=""
      fi
      CGO_ENABLED=0 gox -osarch="linux/amd64 linux/arm64 darwin/amd64 darwin/arm64 windows/amd64" -ldflags "-w -s -extldflags '-static' $VERSION_FLAG" -output="helix-{{.OS}}-{{.Arch}}"
    - ./helix-linux-amd64 version
    - apt-get update && apt-get install -y curl
    - curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
    - echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | tee /etc/apt/sources.list.d/github-cli.list > /dev/null
    - apt-get update && apt-get install -y gh
    - sed -i "s/:latest/:$DRONE_TAG/g" docker-compose.yaml
    - |
      if [ -n "$DRONE_TAG" ]; then
        # Look for either exact match or tag followed by space and description
        RELEASE=$(gh release list | awk -v tag="$DRONE_TAG" '$1 == tag || $1 ~ "^"tag" " {print $1; exit}')
        if [ -n "$RELEASE" ]; then
          echo "Uploading helix binaries, installer, and docker-compose.yaml to release $RELEASE"
          gh release upload "$RELEASE" helix-linux-amd64 helix-linux-arm64 helix-darwin-amd64 helix-darwin-arm64 helix-windows-amd64.exe docker-compose.yaml
        else
          echo "No matching release found for tag $DRONE_TAG"
        fi
      else
        echo "No tag present, skipping release upload"
      fi
  depends_on: [build-backend, build-frontend]

- name: build-operator
  image: golang:1.24-alpine3.21
  environment:
    GITHUB_TOKEN:
      from_secret: github_token
  commands:
    - cd operator && go build ./...
  depends_on: []

- name: run-linter-operator
  image: golangci/golangci-lint:v1.64-alpine
  commands:
    - cd operator && golangci-lint run
  when:
    event:
    - push
  depends_on: []

services:
- name: postgres
  image: postgres:12.13-alpine
  environment:
    POSTGRES_USER: postgres
    POSTGRES_PASSWORD: postgres
    POSTGRES_DB: postgres
- name: typesense
  image: typesense/typesense:27.0
  command: ["--data-dir", "/tmp", "--api-key", "typesense"]
- name: tika
  image: apache/tika:2.9.2.1
- name: chrome
  image: ghcr.io/go-rod/rod:v0.115.0
- name: pgvector
  image: pgvector/pgvector:pg17
  environment:
    POSTGRES_USER: postgres
    POSTGRES_PASSWORD: postgres
    POSTGRES_DB: postgres
- name: keycloak
  image: quay.io/keycloak/keycloak:23.0
  command: ["start-dev"]
  environment:
    KC_DB: postgres
    KC_DB_URL: jdbc:postgresql://postgres:5432/postgres  # Unable to run scripts to create keycloak database, so using the default instead
    KC_DB_USERNAME: postgres
    KC_DB_PASSWORD: postgres
    KEYCLOAK_ADMIN: admin
    KEYCLOAK_ADMIN_PASSWORD: REPLACE_ME
    KC_HOSTNAME_PATH: /auth
    KC_HTTP_RELATIVE_PATH: /auth/

volumes:
- name: oauth-test-results
  temp: {}
---
kind: pipeline
type: docker
name: build-controlplane

trigger:
  event:
    - tag

volumes:
  - name: dockersocket
    host:
      path: /var/run/docker.sock

steps:
- name: publish-image
  image: plugins/docker
  pull: always
  settings:
    dockerfile: Dockerfile
    auto_tag: true
    daemon_off: true
    registry: registry.helixml.tech
    repo: registry.helixml.tech/helix/controlplane
    username: admin
    password:
      from_secret: helix_registry_password
    build_args:
      - APP_VERSION=${DRONE_TAG:-${DRONE_COMMIT_SHA:-latest}}
  volumes:
  - name: dockersocket
    path: /var/run/docker.sock
  when:
    event:
    - tag

---
kind: pipeline
type: docker
name: build-keycloak

trigger:
  event:
    - tag

volumes:
  - name: dockersocket
    host:
      path: /var/run/docker.sock

steps:
- name: publish-image
  image: plugins/docker
  pull: always
  settings:
    dockerfile: Dockerfile.keycloak
    auto_tag: true
    daemon_off: true
    registry: registry.helixml.tech
    repo: registry.helixml.tech/helix/keycloak
    username: admin
    password:
      from_secret: helix_registry_password
    build_args:
      - APP_VERSION=${DRONE_TAG:-${DRONE_COMMIT_SHA:-latest}}
  volumes:
  - name: dockersocket
    path: /var/run/docker.sock
  when:
    event:
    - tag

---
kind: pipeline
type: docker
name: build-keycloak-bitnami

trigger:
  event:
    - tag

volumes:
  - name: dockersocket
    host:
      path: /var/run/docker.sock

steps:
- name: publish-image
  image: plugins/docker
  pull: always
  settings:
    dockerfile: Dockerfile.keycloak-bitnami
    auto_tag: true
    daemon_off: true
    registry: registry.helixml.tech
    repo: registry.helixml.tech/helix/keycloak-bitnami
    username: admin
    password:
      from_secret: helix_registry_password
    build_args:
      - APP_VERSION=${DRONE_TAG:-${DRONE_COMMIT_SHA:-latest}}
  volumes:
  - name: dockersocket
    path: /var/run/docker.sock
  when:
    event:
    - tag

---
kind: pipeline
type: docker
name: build-haystack

trigger:
  event:
    - tag

volumes:
  - name: dockersocket
    host:
      path: /var/run/docker.sock

steps:
- name: publish-image
  image: plugins/docker
  pull: always
  settings:
    context: haystack_service
    dockerfile: haystack_service/Dockerfile
    auto_tag: true
    daemon_off: true
    registry: registry.helixml.tech
    repo: registry.helixml.tech/helix/haystack
    username: admin
    password:
      from_secret: helix_registry_password
    build_args:
      - APP_VERSION=${DRONE_TAG:-${DRONE_COMMIT_SHA:-latest}}
  volumes:
  - name: dockersocket
    path: /var/run/docker.sock
  when:
    event:
    - tag

---
kind: pipeline
type: docker
name: build-runner

trigger:
  event:
    - tag

volumes:
  - name: dockersocket
    host:
      path: /var/run/docker.sock

steps:
- name: publish-runner
  image: plugins/docker
  pull: always
  settings:
    dockerfile: Dockerfile.runner
    auto_tag: true
    daemon_off: true
    registry: registry.helixml.tech
    repo: registry.helixml.tech/helix/runner
    build_args:
      # Runner with no baked models = empty
      # See https://github.com/helixml/base-images
      # and https://github.com/helixml/base-images/releases
      - TAG=2025-06-23a-empty
      - APP_VERSION=${DRONE_TAG:-${DRONE_COMMIT_SHA:-latest}}
    username: admin
    password:
      from_secret: helix_registry_password
  volumes:
  - name: dockersocket
    path: /var/run/docker.sock
  when:
    event:
    - tag

---
kind: pipeline
type: docker
name: build-runner-small

trigger:
  event:
    - tag

volumes:
  - name: dockersocket
    host:
      path: /var/run/docker.sock

steps:
- name: publish-runner
  image: plugins/docker
  pull: always
  settings:
    dockerfile: Dockerfile.runner
    tags:
    - "${DRONE_TAG:-main}-small" # Default to branch
    - "latest-small"
    daemon_off: true
    registry: registry.helixml.tech
    repo: registry.helixml.tech/helix/runner
    build_args:
      # Runner with small models = small
      # See https://github.com/helixml/base-images
      # and https://github.com/helixml/base-images/releases
      - TAG=2025-06-23a-small
      - APP_VERSION=${DRONE_TAG:-${DRONE_COMMIT_SHA:-latest}}
    username: admin
    password:
      from_secret: helix_registry_password
  volumes:
  - name: dockersocket
    path: /var/run/docker.sock
  when:
    event:
    - tag

- name: publish-runner-branch
  image: plugins/docker
  pull: always
  settings:
    dockerfile: Dockerfile.runner
    tags:
    - "${DRONE_COMMIT_SHA:-main}-small" # Default to branch
    daemon_off: true
    registry: registry.helixml.tech
    repo: registry.helixml.tech/helix/runner
    build_args:
      # Runner with small models = small
      # See https://github.com/helixml/base-images
      # and https://github.com/helixml/base-images/releases
      - TAG=2025-06-23a-small
      - APP_VERSION=${DRONE_TAG:-${DRONE_COMMIT_SHA:-latest}}
    username: admin
    password:
      from_secret: helix_registry_password
  volumes:
  - name: dockersocket
    path: /var/run/docker.sock
  when:
    branch:
      exclude:
      - main
    event:

---
kind: pipeline
type: docker
name: build-runner-large

trigger:
  event:
    - tag

volumes:
  - name: dockersocket
    host:
      path: /var/run/docker.sock

steps:
- name: publish-runner
  image: plugins/docker
  pull: always
  settings:
    dockerfile: Dockerfile.runner
    tags:
    - "${DRONE_TAG:-main}-large"
    - "latest-large"
    daemon_off: true
    registry: registry.helixml.tech
    repo: registry.helixml.tech/helix/runner
    build_args:
      # Runner with large models = large
      # See https://github.com/helixml/base-images
      # and https://github.com/helixml/base-images/releases
      - TAG=2025-06-23a-large
      - APP_VERSION=${DRONE_TAG:-${DRONE_COMMIT_SHA:-latest}}
    username: admin
    password:
      from_secret: helix_registry_password
  volumes:
  - name: dockersocket
    path: /var/run/docker.sock
  when:
    event:
    - tag

- name: publish-runner-branch
  image: plugins/docker
  pull: always
  settings:
    dockerfile: Dockerfile.runner
    tags:
    - "${DRONE_COMMIT_SHA:-main}-large"
    daemon_off: true
    registry: registry.helixml.tech
    repo: registry.helixml.tech/helix/runner
    build_args:
      # Runner with large models = large
      # See https://github.com/helixml/base-images
      # and https://github.com/helixml/base-images/releases
      - TAG=2025-06-23a-large
      - APP_VERSION=${DRONE_TAG:-${DRONE_COMMIT_SHA:-latest}}
    username: admin
    password:
      from_secret: helix_registry_password
  volumes:
  - name: dockersocket
    path: /var/run/docker.sock
  when:
    branch:
      exclude:
      - main
    event:

---
kind: pipeline
type: docker
name: build-gptscript-runner

trigger:
  event:
    - tag

volumes:
  - name: dockersocket
    host:
      path: /var/run/docker.sock

steps:
- name: publish-image
  image: plugins/docker
  pull: always
  settings:
    dockerfile: Dockerfile.gptscript
    auto_tag: true
    daemon_off: true
    registry: registry.helixml.tech
    repo: registry.helixml.tech/helix/gptscript-runner
    username: admin
    password:
      from_secret: helix_registry_password
  volumes:
  - name: dockersocket
    path: /var/run/docker.sock
  when:
    event:
    - tag

---
kind: pipeline
type: docker
name: build-gptscript_devserver

trigger:
  event:
    - tag

volumes:
  - name: dockersocket
    host:
      path: /var/run/docker.sock

steps:
- name: publish-gptscript_devserver
  image: plugins/docker
  pull: always
  settings:
    dockerfile: Dockerfile.gptscript_devserver
    auto_tag: true
    daemon_off: true
    registry: registry.helixml.tech
    repo: registry.helixml.tech/helix/gptscript_devserver
    username: admin
    password:
      from_secret: helix_registry_password
  volumes:
  - name: dockersocket
    path: /var/run/docker.sock
  when:
    event:
    - tag

---
kind: pipeline
type: docker
name: build-typesense_baked_models

trigger:
  event:
    - tag

volumes:
  - name: dockersocket
    host:
      path: /var/run/docker.sock

steps:
- name: publish-typesense_baked_models
  image: plugins/docker
  pull: always
  settings:
    dockerfile: Dockerfile.typesense
    auto_tag: true
    daemon_off: true
    registry: registry.helixml.tech
    repo: registry.helixml.tech/helix/typesense
    username: admin
    password:
      from_secret: helix_registry_password
  volumes:
  - name: dockersocket
    path: /var/run/docker.sock
  when:
    event:
    - tag

---
kind: pipeline
type: docker
name: build-demos

trigger:
  event:
    - tag

volumes:
  - name: dockersocket
    host:
      path: /var/run/docker.sock

steps:
- name: publish-demos
  image: plugins/docker
  pull: always
  settings:
    dockerfile: Dockerfile.demos
    auto_tag: true
    daemon_off: true
    registry: registry.helixml.tech
    repo: registry.helixml.tech/helix/demos
    username: admin
    password:
      from_secret: helix_registry_password
  volumes:
  - name: dockersocket
    path: /var/run/docker.sock
  when:
    event:
    - tag

---
# See integration-test/smoke/README.md
kind: pipeline
type: docker
name: smoke-test

workspace:
  base: /go
  path: src/github.com/helix-ml/helix

trigger:
  event:
    - cron
  cron:
    - smoke-test-hourly
    - developer

steps:
- name: smoke-test-saas
  image: golang:1.24-alpine3.21
  environment:
    BROWSER_URL: http://chrome:7317
    SERVER_URL: https://app.helix.ml
    HELIX_USER: phil+smoketest@helix.ml
    HELIX_PASSWORD:
      from_secret: smoke_test_helix_password
    # Test setup
  volumes:
  - name: integration-test
    path: /integration-test
  commands:
  - apk add --no-cache curl bash openssl
  - cp -r integration-test/* /integration-test
  - go test -timeout 600s -tags=integration -v ./integration-test/smoke
  depends_on: []
- name: slack-notification
  image: plugins/slack
  settings:
    webhook:
      from_secret: JANITOR_SLACK_WEBHOOK_URL
    channel: helix-janitor
    # See the slack formatting docs: https://api.slack.com/reference/surfaces/formatting
    message: "❌ Smoke test failed (<@U010X78FM18>). (<https://drone.lukemarsden.net/helixml/helix/${DRONE_BUILD_NUMBER}|Build>)"
  when:
    status:
    - failure

volumes:
- name: integration-test
  temp: {}

services:
- name: chrome
  image: ghcr.io/go-rod/rod:v0.115.0
  volumes:
  - name: integration-test
    path: /integration-test

---
# See integration-test/smoke/README.md
kind: pipeline
type: docker
name: deply-helix-ml-test

workspace:
  base: /go
  path: src/github.com/helix-ml/helix

trigger:
  event:
    - cron
  cron:
    - deply-helix-ml
    - developer

steps:
- name: smoke-test-launchpad
  image: golang:1.24-alpine3.21
  environment:
    BROWSER_URL: http://chrome:7317
    LAUNCHPAD_API_KEY:
      from_secret: LAUNCHPAD_API_KEY
  volumes:
  - name: integration-test
    path: /integration-test
  commands:
  - apk add --no-cache curl bash openssl
  - cp -r integration-test/* /integration-test
  - go test -timeout 600s -tags=launchpad -v ./integration-test/smoke
  depends_on: []
- name: slack-notification
  image: plugins/slack
  settings:
    webhook:
      from_secret: JANITOR_SLACK_WEBHOOK_URL
    channel: helix-janitor
    # See the slack formatting docs: https://api.slack.com/reference/surfaces/formatting
    message: "❌ Launchpad failed (<@U010X78FM18>). (<https://drone.lukemarsden.net/helixml/helix/${DRONE_BUILD_NUMBER}|Build>)"
  when:
    status:
    - failure

volumes:
- name: integration-test
  temp: {}

services:
- name: chrome
  image: ghcr.io/go-rod/rod:v0.115.0
  volumes:
  - name: integration-test
    path: /integration-test
