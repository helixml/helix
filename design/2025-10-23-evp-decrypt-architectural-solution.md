# Architectural Solution for EVP_DecryptFinal_ex Errors

## Deep Dive: Root Cause Analysis

### How AES Keys Actually Work in Moonlight/Wolf

**CRITICAL FINDING**: AES keys are **randomly generated by the client** on EVERY launch/resume:

```rust
// moonlight-common/src/high.rs:623-641
let mut aes_key = [0u8; 16];
rand_bytes(&mut aes_key)?;  // FRESH RANDOM KEY

let mut aes_iv = [0u8; 4];
rand_bytes(&mut aes_iv)?;   // FRESH RANDOM IV

let request = ClientStreamRequest {
    ri_key: aes_key,        // Sent to Wolf in /launch or /resume
    ri_key_id: aes_iv,
};
```

**Key Flow**:
1. moonlight client generates random `rikey` (16 bytes) and `rikeyid` (4 bytes)
2. Sends these in HTTPS `/launch` or `/resume` query parameters to Wolf
3. Wolf extracts them: `get_header(headers, "rikey").value()` (endpoints.hpp:458)
4. Wolf creates StreamSession with these keys: `session.aes_key = rikey`
5. Wolf stores session **IN MEMORY ONLY** in `running_sessions` atom
6. Streamer child process encrypts control packets with same `rikey`
7. Wolf's ENET control server decrypts using `session.aes_key`

### What Happens on Wolf Restart

**Session Storage** (from state/sessions.hpp:39-90):
- StreamSession objects stored in `immer::atom<immer::vector<StreamSession>>`
- **NO PERSISTENCE** - all sessions lost on Wolf restart
- AES keys are stored as strings in StreamSession struct (events.hpp:237-238)

**When Wolf restarts**:
1. All `running_sessions` cleared (in-memory only)
2. Paired client certificates REMAIN (persisted in Wolf config)
3. moonlight-web certificates REMAIN (persisted in data.json)
4. But ALL session AES keys are LOST

**Failure Scenarios**:

**Scenario A: Active stream during restart**
1. Stream is active, Wolf session exists with `aes_key = ABC123`
2. Wolf container restarts (deployment, crash, etc.)
3. Streamer child process in moonlight-web container keeps running
4. Streamer tries to send ENET packets encrypted with old `ABC123` key
5. Wolf receives packet but has NO session → decrypt failure

**Scenario B: Resume after restart**
1. Stream ends normally, session cleared
2. Wolf restarts, all sessions lost
3. Client tries to reconnect
4. moonlight-web sends `/resume` with NEW random `rikey = XYZ789`
5. Wolf checks for old_session: `get_session_by_client()` returns None (line 501)
6. Wolf logs warning and **returns error** (lines 522-525)
7. Resume fails, client can't reconnect

### Wolf RESUME Endpoint Bug

**CRITICAL BUG FOUND** (endpoints.hpp:494-526):
```cpp
void resume(...) {
  auto old_session = get_session_by_client(state->running_sessions->load(), current_client);
  if (old_session) {
    // ... create new session, handle resume ...
    auto xml = moonlight::launch_resume(...);
    send_xml<SimpleWeb::HTTPS>(response, SimpleWeb::StatusCode::success_ok, xml);
  } else {
    logs::log(logs::warning, "[HTTPS] Received resume event from an unregistered session");
  }

  server_error<SimpleWeb::HTTPS>(response);  // BUG: ALWAYS RUNS!
}
```

**Line 525 is OUTSIDE the if/else block** - it runs unconditionally!
This means **RESUME ALWAYS RETURNS ERROR**, even when it succeeds.

This bug would prevent any successful resume operation.

## The Elegant Architectural Solution

### Problem Statement

**State Persistence Mismatch**:
- moonlight-web persists client certificates (survives restarts)
- Wolf does NOT persist sessions/AES keys (lost on restart)
- No mechanism to detect Wolf restart and re-sync state

**Requirements**:
1. Prevent decrypt errors after Wolf restarts
2. Enable graceful reconnection when Wolf loses session state
3. Maintain per-session client certificate persistence (for RESUME protocol)
4. No decrypt errors in production, ever

### Solution Architecture

**Three-Part Solution**:

#### 1. Fix Wolf RESUME Bug (Immediate Critical Fix)

**File**: `wolf/src/moonlight-server/rest/endpoints.hpp`
**Lines**: 521-526

```cpp
// BEFORE (BROKEN):
} else {
    logs::log(logs::warning, "[HTTPS] Received resume event from an unregistered session, ip: {}", client_ip);
}

server_error<SimpleWeb::HTTPS>(response);  // BUG: Always runs!
```

```cpp
// AFTER (FIXED):
} else {
    logs::log(logs::warning, "[HTTPS] Received resume event from an unregistered session, ip: {}", client_ip);
    server_error<SimpleWeb::HTTPS>(response);  // Moved INSIDE else block
}
```

**Impact**: RESUME will now work correctly when Wolf has the session.

#### 2. Add Wolf Status/Uptime Endpoint

**File**: `wolf/src/moonlight-server/api/api.cpp` or new handler

Add `/api/v1/status` endpoint that returns:
```json
{
  "uptime_seconds": 12345,
  "boot_time_unix": 1729701234,
  "version": "1.0.0"
}
```

**Implementation**:
- Store Wolf boot timestamp on startup (process start time)
- Expose via Unix socket API (accessible from Helix API container)
- Simple, stateless endpoint (just returns current uptime)

#### 3. moonlight-web: Detect Wolf Restart and Force LAUNCH

**File**: `moonlight-web-stream/moonlight-web/web-server/src/api/stream.rs`

**Strategy**:
- Query Wolf status before stream initialization
- Track last known Wolf boot_time
- If boot_time changed → Wolf restarted → force LAUNCH (not RESUME)

**Implementation**:
```rust
// Add to AppData state
struct WolfState {
    boot_time: Arc<RwLock<Option<i64>>>,
}

// Before pairing/launch (in handle_start_stream):
async fn check_wolf_restart(host: &str, port: u16, state: &WolfState) -> bool {
    // Query Wolf status endpoint
    match query_wolf_status(host, port).await {
        Ok(status) => {
            let mut last_boot = state.boot_time.write().await;
            let wolf_restarted = last_boot.is_some() &&
                                 last_boot.unwrap() != status.boot_time_unix;
            *last_boot = Some(status.boot_time_unix);
            wolf_restarted
        }
        Err(_) => {
            // Can't determine, assume no restart
            false
        }
    }
}

// In stream init:
let wolf_restarted = check_wolf_restart(&host_address, host_http_port, &data.wolf_state).await;

if wolf_restarted {
    // Clear cached session assumptions
    info!("[Stream]: Wolf restarted detected, clearing stale state");
    // Force LAUNCH even if we have cached cert
}
```

**Alternative Simpler Approach** (if Wolf status endpoint not added):
- Just handle RESUME failures gracefully
- If Wolf returns error on RESUME → automatically retry with LAUNCH
- This works because RESUME bug will be fixed (solution #1)

### Why This Solution is Elegant

**1. Separation of Concerns**:
- Pairing = client certificate management (persisted, long-lived)
- Sessions = streaming state with AES keys (ephemeral, per-connection)
- Solution keeps these concepts properly separated

**2. Minimal Wolf Changes**:
- One-line bug fix (critical)
- Optional: Add simple status endpoint (good architecture)
- No changes to session storage (Wolf's in-memory approach is fine)

**3. Smart moonlight-web Logic**:
- Detects Wolf restart proactively
- Adapts behavior based on Wolf state
- Graceful fallback from RESUME to LAUNCH

**4. No Defensive Unpair Needed**:
- My previous unpair approach was treating symptoms, not cause
- This solution addresses root cause: state synchronization
- Pairing remains intact, only session state is re-synced

**5. Production Safe**:
- No decrypt errors after Wolf restart
- Transparent to users (auto-reconnect works)
- No manual intervention needed

### Implementation Priority

**Phase 1: Critical Fix** (15 minutes)
- Fix Wolf RESUME bug (one line change)
- Rebuild Wolf, test RESUME works

**Phase 2: Robust Solution** (2-3 hours)
- Add Wolf `/api/v1/status` endpoint
- moonlight-web Wolf restart detection
- Test full restart + reconnect flow

**Phase 3: Production Validation** (1 hour)
- End-to-end testing with multiple sessions
- Test Wolf restart during active stream
- Test Wolf restart between sessions
- Verify no decrypt errors in all scenarios

### Testing Strategy

**Test Cases**:
1. **Normal operation** (no restart):
   - Start stream → verify encryption works
   - Disconnect → reconnect → verify RESUME works

2. **Wolf restart during active stream**:
   - Start stream → restart Wolf → verify graceful reconnect
   - Should automatically LAUNCH fresh (new AES keys)

3. **Wolf restart between sessions**:
   - Stream → disconnect → restart Wolf → reconnect
   - Should detect restart, use LAUNCH instead of RESUME

4. **Multiple concurrent sessions**:
   - Start 3 streams → restart Wolf → verify all reconnect correctly

**Success Criteria**:
- ✅ No EVP_DecryptFinal_ex errors in Wolf logs
- ✅ RESUME works when Wolf has session
- ✅ Graceful fallback to LAUNCH when Wolf lost session
- ✅ All streams reconnect successfully after Wolf restart

## Comparison to Previous Approach

### Defensive Unpair (REJECTED)

**What I tried**:
- Unpair client before pairing on each stream
- Clear stale Wolf state proactively

**Why it failed**:
- Triggered streamer panic in moonlight-web
- Treating wrong layer (pairing vs sessions)
- Didn't address root cause (session state loss)

### Current Approach (CORRECT)

**What we're doing**:
- Fix RESUME bug (Wolf-side)
- Detect Wolf restart (moonlight-web-side)
- Force LAUNCH when Wolf lost state

**Why it works**:
- Addresses root cause (state synchronization)
- Separates pairing (persistent) from sessions (ephemeral)
- Graceful, transparent to users

## Implementation Status

### Phase 1: Critical Fix ✅ COMPLETE

**Wolf RESUME Bug Fixed** (commit be11da9):
- **File**: `wolf/src/moonlight-server/rest/endpoints.hpp:521-524`
- **Change**: Moved `server_error()` call inside else block
- **Impact**: RESUME now works correctly when Wolf has session state

### Phase 2: Robust Solution ✅ COMPLETE

**Wolf Status Endpoint Added** (commit be11da9):

**Files Changed**:
- `wolf/src/moonlight-server/state/data-structures.hpp`: Added `boot_time` field to AppState
- `wolf/src/moonlight-server/wolf.cpp`: Initialize boot_time on startup
- `wolf/src/moonlight-server/api/api.hpp`: Added StatusResponse struct and endpoint declaration
- `wolf/src/moonlight-server/api/endpoints.cpp`: Implemented endpoint_Status()
- `wolf/src/moonlight-server/api/unix_socket_server.cpp`: Registered `/api/v1/status` route

**Endpoint Details**:
```bash
# Query Wolf status
docker compose -f docker-compose.dev.yaml exec api curl --unix-socket /var/run/wolf/wolf.sock http://localhost/api/v1/status

# Response:
{
  "success": true,
  "uptime_seconds": 123,
  "boot_time_unix": 1729701234,
  "version": "1.0.0"
}
```

**Wolf Deployment**: ✅ Container rebuilt and restarted with fixes

### Phase 3: moonlight-web Integration ⬜ PENDING

**Next Steps**:
1. ⬜ Implement Wolf restart detection in moonlight-web
2. ⬜ Test end-to-end with Wolf restart scenarios
3. ⬜ Monitor for decrypt errors in production

## Testing the Current Fixes

**Test Wolf Status Endpoint**:
```bash
# Query status from API container
docker compose -f docker-compose.dev.yaml exec api curl --unix-socket /var/run/wolf/wolf.sock http://localhost/api/v1/status | jq '.'

# Expected output:
{
  "success": true,
  "uptime_seconds": <number>,
  "boot_time_unix": <unix timestamp>,
  "version": "1.0.0"
}
```

**Test RESUME Fix**:
1. Start external agent session
2. Connect via Moonlight
3. Disconnect Moonlight client
4. Reconnect - should RESUME successfully without error
