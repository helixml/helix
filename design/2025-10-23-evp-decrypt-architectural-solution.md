# EVP_DecryptFinal_ex Errors: Investigation and Reality Check

## CRITICAL: Assumptions vs Reality

**WARNING**: The initial analysis made sweeping assumptions without reproducing the actual bug. This document has been updated to reflect what we ACTUALLY know vs what was assumed.

## What We ACTUALLY Know

### How AES Keys Work in Moonlight/Wolf

**VERIFIED FROM CODE**: AES keys are randomly generated by the client on EVERY launch/resume:

```rust
// moonlight-common/src/high.rs:623-641
let mut aes_key = [0u8; 16];
rand_bytes(&mut aes_key)?;  // FRESH RANDOM KEY

let mut aes_iv = [0u8; 4];
rand_bytes(&mut aes_iv)?;   // FRESH RANDOM IV

let request = ClientStreamRequest {
    ri_key: aes_key,        // Sent to Wolf in /launch or /resume
    ri_key_id: aes_iv,
};
```

**Key Flow**:
1. moonlight client generates random `rikey` (16 bytes) and `rikeyid` (4 bytes)
2. Sends these in HTTPS `/launch` or `/resume` query parameters to Wolf
3. Wolf extracts them: `get_header(headers, "rikey").value()` (endpoints.hpp:458)
4. Wolf creates StreamSession with these keys: `session.aes_key = rikey`
5. Wolf stores session **IN MEMORY ONLY** in `running_sessions` atom
6. Streamer child process encrypts control packets with same `rikey`
7. Wolf's ENET control server decrypts using `session.aes_key`

### What Happens on Wolf Restart (THEORY - NOT TESTED)

**Session Storage** (verified from code):
- StreamSession objects stored in `immer::atom<immer::vector<StreamSession>>`
- **NO PERSISTENCE** - all sessions lost on Wolf restart
- AES keys are stored as strings in StreamSession struct

**ASSUMPTION (NOT VERIFIED)**:
The original analysis assumed these failure scenarios without testing:

**Scenario A: Active stream during restart**
- ASSUMPTION: Streamer keeps running and tries to decrypt with old keys
- REALITY: Unknown - need to test if streamer child survives Wolf restart
- QUESTION: Does the app container actually keep running?

**Scenario B: Resume after restart**
- ASSUMPTION: Client tries RESUME when Wolf has no session
- REALITY: User points out - **LAUNCH vs RESUME is auto-detected based on whether app is running**
- If Wolf restarted → app not running → should auto-LAUNCH, not RESUME
- This scenario may not actually occur!

### Wolf RESUME Endpoint Bug

**CRITICAL BUG FOUND** (endpoints.hpp:494-526):
```cpp
void resume(...) {
  auto old_session = get_session_by_client(state->running_sessions->load(), current_client);
  if (old_session) {
    // ... create new session, handle resume ...
    auto xml = moonlight::launch_resume(...);
    send_xml<SimpleWeb::HTTPS>(response, SimpleWeb::StatusCode::success_ok, xml);
  } else {
    logs::log(logs::warning, "[HTTPS] Received resume event from an unregistered session");
  }

  server_error<SimpleWeb::HTTPS>(response);  // BUG: ALWAYS RUNS!
}
```

**Line 525 is OUTSIDE the if/else block** - it runs unconditionally!
This means **RESUME ALWAYS RETURNS ERROR**, even when it succeeds.

This bug would prevent any successful resume operation.

## What We Actually Fixed

### 1. Real Bug Found: Wolf RESUME Endpoint

**VERIFIED BUG** (endpoints.hpp:521-525):
The RESUME endpoint had `server_error()` call OUTSIDE the if/else block, so it ALWAYS returned error even on success.

**This is a REAL bug** - the fix is correct regardless of the decrypt error root cause.

### 2. Observability Addition: Status Endpoint

**USEFUL FOR DEBUGGING**: Added `/api/v1/status` endpoint
- Returns `boot_time_unix` and `uptime_seconds`
- Good for observability and debugging
- NOT necessarily the solution to decrypt errors (that was an assumption)

## What We NEED to Actually Do

### Reproduce the Decrypt Errors

**We've never actually reproduced these errors under controlled conditions.**

Original evidence:
- EVP_DecryptFinal_ex errors appeared in logs after restarts
- Debug logging showed 280+ successful decrypts (no failures during test)
- Defensive unpair caused moonlight-web streamer panic (different bug)

**Need to test**:
1. Start external agent session
2. Restart Wolf container while streaming is active
3. Observe what actually happens:
   - Does the app container keep running?
   - Does moonlight-web streamer try to reconnect?
   - Does it use LAUNCH or RESUME?
   - Do we see decrypt errors?

### Questions We Can't Answer Yet

**Auto-Detection of LAUNCH vs RESUME**:
- User is right: system should auto-detect based on whether app is running
- If Wolf restarts → app stops → client should auto-LAUNCH
- Why would RESUME even be attempted?

**When Do Decrypt Errors Actually Occur?**:
- During active stream? (Scenario A)
- On reconnection attempt? (Scenario B)
- Some other scenario we haven't identified?

**What Triggers Them?**:
- Wolf restart specifically?
- moonlight-web restart?
- Network disconnection?
- Race condition between components?

## Revised Solution Approach

### Step 1: Keep What We Fixed ✅

**Wolf RESUME Bug Fix** - This is real and correct:
```cpp
} else {
    logs::log(logs::warning, "[HTTPS] Received resume event from an unregistered session, ip: {}", client_ip);
    server_error<SimpleWeb::HTTPS>(response);  // Moved inside else block
}
```

**Wolf Status Endpoint** - Useful for observability:
```bash
GET /api/v1/status
{
  "uptime_seconds": 123,
  "boot_time_unix": 1729701234,
  "version": "1.0.0"
}
```

### Step 2: Reproduce the Actual Bug

**Test Methodology**:

1. **Setup**:
   - Start external agent session
   - Begin streaming (verify working)
   - Capture baseline Wolf logs

2. **Trigger scenarios**:
   ```bash
   # Scenario A: Wolf restart during active stream
   docker compose -f docker-compose.dev.yaml restart wolf
   # Observe: What happens? Do we see decrypt errors?

   # Scenario B: moonlight-web restart during active stream
   docker compose -f docker-compose.dev.yaml restart moonlight-web
   # Observe: Different behavior?

   # Scenario C: Normal disconnect/reconnect
   # Disconnect Moonlight client, wait, reconnect
   # Does it LAUNCH or RESUME? Any errors?
   ```

3. **Capture detailed logs**:
   ```bash
   # BEFORE each test, capture logs to timestamped directory
   mkdir -p logs/$(date +%Y%m%d-%H%M%S)-<scenario-name>
   cd logs/<directory>

   # Tail logs in real-time during test
   docker compose -f docker-compose.dev.yaml logs -f wolf | grep -E "(Decrypt|RESUME|LAUNCH|session)" | tee wolf-live.log
   ```

4. **Questions to answer**:
   - When exactly do decrypt errors occur?
   - What's the sequence of events leading to the error?
   - Does LAUNCH vs RESUME auto-detection work correctly?
   - Does the app container actually survive Wolf restart?
   - Does moonlight-web streamer try to reconnect after Wolf restart?

### Step 3: Analyze Real Data

**Only after reproducing**, we can:
- Identify the actual failure mode
- Determine if auto-detection already solves it
- Design a targeted fix (not a sweeping architectural change)

### Step 4: Fix the Real Problem

**Potential outcomes**:

**Outcome A: Auto-detection already works**
- LAUNCH/RESUME is correctly auto-detected
- Decrypt errors only occur during brief transition
- No fix needed beyond RESUME bug fix

**Outcome B: Specific race condition**
- Identify exact timing issue
- Add targeted synchronization
- No need for Wolf restart detection

**Outcome C: Different root cause entirely**
- Decrypt errors unrelated to Wolf restart
- Issue in moonlight-web streamer lifecycle
- Fix in appropriate component

## What We Learned

**Assumptions Made Without Data**:
1. ❌ Assumed Wolf restart causes decrypt errors
2. ❌ Assumed RESUME would be attempted when app not running
3. ❌ Assumed we needed Wolf restart detection in moonlight-web
4. ❌ Designed solution before reproducing problem

**What We Should Have Done**:
1. ✅ Reproduce the bug first
2. ✅ Observe actual behavior
3. ✅ Identify specific failure mode
4. ✅ Design targeted fix

**Good Things We Did**:
1. ✅ Found and fixed real RESUME bug
2. ✅ Added useful observability endpoint
3. ✅ Comprehensive code analysis
4. ✅ Good documentation (even if premature)

## Current Status

### What's Deployed ✅

**Wolf Changes** (commit be11da9):
- ✅ Fixed RESUME endpoint bug (real bug, correct fix)
- ✅ Added `/api/v1/status` endpoint (useful for observability)
- ✅ Container rebuilt and restarted

**Verified Working**:
```bash
$ docker compose -f docker-compose.dev.yaml exec api curl --unix-socket /var/run/wolf/wolf.sock http://localhost/api/v1/status
{
  "success": true,
  "uptime_seconds": 31,
  "boot_time_unix": 1761213565,
  "version": "1.0.0"
}
```

### What We DON'T Know Yet ⚠️

1. **When do decrypt errors actually occur?**
   - Haven't reproduced under controlled conditions
   - Don't know the exact trigger

2. **Does auto-detection already solve this?**
   - LAUNCH vs RESUME should auto-detect based on app running state
   - May not need additional Wolf restart detection

3. **What's the actual failure sequence?**
   - Need to observe real behavior, not assumptions
   - Need logs from actual decrypt error occurrence

### Next Actions

**BEFORE implementing moonlight-web changes**:
1. ⬜ Reproduce decrypt errors with Wolf restart
2. ⬜ Reproduce decrypt errors with moonlight-web restart
3. ⬜ Observe LAUNCH vs RESUME auto-detection behavior
4. ⬜ Capture detailed logs of actual failure
5. ⬜ Design fix based on REAL data, not assumptions

**Only AFTER we understand the real problem**:
- Design targeted fix
- Implement in appropriate component
- Test that it actually solves the reproduced issue
