# Google OIDC Logout Bug Investigation

**Date:** 2026-02-01
**Status:** Fix implemented - PR pending

## Problem Statement

Users are getting logged out unexpectedly when using Google OIDC authentication, despite recent fixes that should address token expiry and refresh.

## Recent Fixes Attempted

1. **08d6c085** - `feat: Add OIDC_OFFLINE_ACCESS for Google refresh tokens`
   - Added `access_type=offline` to auth URL for Google to return refresh tokens
   - Defaults to `true`

2. **a5a62e07d** - `feat: Auto-refresh tokens on 401 and improve MCP skill configuration`
   - Added axios interceptor to automatically refresh tokens on 401 errors
   - Added `OIDC_COOKIE_MAX_AGE` config for persistent cookies

## Root Cause Analysis

### Observation from Logs

The API logs show 401 errors with this pattern:
```
error validating user token: invalid access token (could not get user info): 401 Unauthorized: Invalid Credentials
token=eyJhbGciOiJIUzI1NiJ9...
```

Decoding the JWT payload reveals:
```json
{
  "admin": true,
  "email": "luke@helix.ml",
  "exp": 1770148975,
  "iat": 1769544175,
  "iss": "helix",        // <-- Helix-generated JWT, NOT Google
  "sub": "usr_01kcgftbnbmr6amd6w707kbpx0"  // <-- Helix user ID format
}
```

### The Core Issue

**The access_token cookie contains a Helix-generated JWT, but the backend is configured for OIDC (Google).**

When `AUTH_PROVIDER=oidc`:
1. Backend uses `oidcClient.ValidateUserToken()` which calls Google's userinfo endpoint
2. Google rejects the Helix JWT because it's not a valid Google access token
3. User gets 401 â†’ logged out

## Hypotheses

### Hypothesis 1: Stale cookies from previous auth provider

The user may have:
1. Originally logged in when `AUTH_PROVIDER=regular`
2. Got a Helix JWT stored in cookies
3. Later, `AUTH_PROVIDER` was changed to `oidc`
4. Old Helix JWT is still in cookies
5. Backend rejects it because it tries to validate via Google

**Evidence:** The token has `iss: helix` and `sub: usr_...` format which is only generated by Helix's regular auth, not OIDC.

### Hypothesis 2: Multiple API call paths with different token handling

The frontend has multiple ways to make API calls:
1. `apiClientSingleton` (OpenAPI client) - has 401 interceptor for token refresh
2. Direct `axios` calls via `useApi()` get/post/put/del - uses axios defaults
3. Direct `fetch()` calls (e.g., filestoreService.ts line 408) - uses `localStorage.getItem('token')`

**Potential issue:** `localStorage.getItem('token')` is read but **never written** in the codebase. This could be:
- Always empty (causing auth failures for file uploads)
- Stale from an old implementation

### Hypothesis 3: Cookie/token mismatch during refresh

When a 401 occurs:
1. Frontend calls `/api/v1/auth/refresh`
2. Backend expects a Google refresh token in the `refresh_token` cookie
3. If the cookie contains a Helix JWT, Google's token refresh fails
4. User remains logged out

### Hypothesis 4: OIDC_OFFLINE_ACCESS not working

Even with `OIDC_OFFLINE_ACCESS=true`:
- Google may not return refresh tokens if user already authorized the app
- Google requires `prompt=consent` to get refresh tokens on re-auth

## Token Flow Analysis

### Expected Flow (OIDC)
```
1. User clicks Login
2. Redirect to Google with access_type=offline
3. Google returns auth code
4. Backend exchanges code for tokens (access_token + refresh_token)
5. Backend sets cookies:
   - access_token = Google's access token (opaque, ~1 hour expiry)
   - refresh_token = Google's refresh token
6. Frontend calls API with access_token cookie
7. Backend validates by calling Google's userinfo endpoint
8. On 401, frontend calls /api/v1/auth/refresh
9. Backend uses refresh_token to get new access_token from Google
10. Backend updates cookies
```

### Actual Flow (Broken)
```
1-5. Same as above, OR user has old Helix JWT from previous auth mode
6. Frontend calls API with access_token cookie (contains Helix JWT)
7. Backend tries to validate Helix JWT via Google's userinfo endpoint
8. Google returns 401 (invalid token)
9. Frontend tries to refresh
10. Backend tries to use Helix JWT as refresh_token with Google
11. Google returns error
12. User is logged out
```

## Affected Endpoints (from logs)

- `/api/v1/ws/user` - WebSocket connection
- `/api/v1/users/token-usage` - Token usage stats
- `/api/v1/sessions/{id}` - Session data

## Proposed Fixes

### Fix 1: Clear stale cookies on auth provider mismatch

In the auth middleware, detect if the token format doesn't match the configured provider and clear cookies:

```go
func (auth *authMiddleware) getUserFromToken(ctx context.Context, token string) (*types.User, error) {
    // If OIDC is configured but token looks like a Helix JWT, reject it
    if auth.oidcClient != nil && looksLikeHelixJWT(token) {
        return nil, fmt.Errorf("invalid token format for OIDC auth")
    }
    // ...
}
```

### Fix 2: Ensure localStorage token is set

Find where `api.setToken()` is called and also update localStorage:

```typescript
const setToken = useCallback(function(token: string) {
    axios.defaults.headers.common = token ? getTokenHeaders(token) : {}
    apiClientSingleton.setSecurityData({ token })
    // Also set in localStorage for fetch() calls
    if (token) {
        localStorage.setItem('token', token)
    } else {
        localStorage.removeItem('token')
    }
}, [])
```

### Fix 3: Add prompt=consent for returning users (if refresh tokens not present)

When generating the auth URL, if user is returning and we don't have a refresh token, force consent:

```go
if c.cfg.OfflineAccess {
    opts = append(opts, oauth2.AccessTypeOffline)
    // Force consent to get refresh token on re-auth
    opts = append(opts, oauth2.SetAuthURLParam("prompt", "consent"))
}
```

**Note:** This changes UX - users see consent screen every time. May want to make this configurable.

## Testing Plan

1. Clear all cookies and localStorage
2. Log in fresh via Google OIDC
3. Check that cookies contain Google tokens (opaque format, not JWT)
4. Wait for token expiry (~1 hour) or manually invalidate
5. Verify token refresh works
6. Check console for `[API] Token refresh successful` messages

## Implemented Fix

### Backend: Detect and reject stale Helix JWTs when OIDC is configured

Added `looksLikeHelixJWT()` helper in `auth_middleware.go` that parses a token without verification
and checks if the issuer claim is "helix".

Updated these endpoints to detect Helix JWTs when OIDC is configured:
1. `getUserFromToken()` in auth middleware - returns `ErrHelixTokenWithOIDC` error
2. `/api/v1/auth/authenticated` - clears cookies and returns `authenticated: false`
3. `/api/v1/auth/user` - clears cookies and returns 401
4. `/api/v1/auth/refresh` - clears cookies and returns 401

When a Helix JWT is detected with OIDC configured, cookies are cleared server-side,
forcing the user to re-login via the OIDC provider (Google).

### Frontend: Fix localStorage token for fetch() calls

Updated `setToken()` in `useApi.ts` to also set `localStorage.setItem('token', token)`
so that direct `fetch()` calls (e.g., file uploads in filestoreService.ts) have access
to the current token.

## Root Cause CONFIRMED (2026-02-01 Session 2)

**The actual root cause was Hypothesis 4: Google not returning refresh tokens.**

### Evidence from Logs

```
WRN pkg/server/auth.go:671 > No refresh token received from OIDC provider. Set OIDC_OFFLINE_ACCESS=true for Google to enable token refresh.
DBG pkg/server/auth.go:868 > Failed to get refresh_token, skipping refresh error="not found: refresh_token"
```

The logs show:
1. Google is NOT returning refresh tokens even with `access_type=offline`
2. Every 2 minutes, the refresh interval fails because there's no `refresh_token` cookie
3. After 1 hour, the access token expires, and the user gets logged out

### Why Google Doesn't Return Refresh Tokens

Google ONLY returns refresh tokens in two cases:
1. **First authorization** - user has never authorized the app before
2. **`prompt=consent`** - explicitly forces the consent screen

The code was using `prompt=select_account` which only shows the account picker. For returning users who have already authorized the app, Google says "you already gave consent" and doesn't issue a new refresh token.

### The Fix

Changed `oidc.go` to use `prompt=consent select_account` when `OfflineAccess` is enabled:

```go
if c.cfg.OfflineAccess {
    opts = append(opts, oauth2.AccessTypeOffline)
    // IMPORTANT: For Google OIDC, we must use prompt=consent to get refresh tokens
    // for returning users. prompt=select_account only shows the account picker but
    // Google won't issue refresh tokens unless consent is explicitly requested.
    // Using "consent select_account" shows both consent AND account picker.
    opts = append(opts, oauth2.SetAuthURLParam("prompt", "consent select_account"))
}
```

**UX Change:** Users will now see the Google consent screen ("Allow Helix to...") every time they log in, not just the account picker. This is necessary to ensure refresh tokens are always returned.

## Timeline of Issues

1. **Stale Helix JWTs** (Fixed in PR #1569)
   - Deployment had `AUTH_PROVIDER=regular` before, then switched to `oidc`
   - Old Helix JWTs in cookies were being rejected by Google's userinfo endpoint
   - Fix: Detect Helix JWTs and clear cookies, force re-login

2. **Missing refresh tokens** (Fixed in this session)
   - Google wasn't returning refresh tokens for returning users
   - Access tokens expire after 1 hour, no way to refresh
   - Fix: Add `prompt=consent` to force Google to return refresh tokens

## Completed Fixes

1. [x] Fix 1: Detect Helix JWTs and clear cookies when OIDC is configured
2. [x] Fix 2: Add `localStorage.setItem('token', ...)` in setToken
3. [x] Fix 3: Add `prompt=consent select_account` when offline access is requested

## Testing Plan

1. Clear all cookies and localStorage
2. Log in via Google OIDC
3. Verify consent screen appears (not just account picker)
4. Check API logs for: `Refresh token received and stored`
5. Wait ~2 hours or check logs for: `Token refresh successful`
6. Verify user remains logged in
