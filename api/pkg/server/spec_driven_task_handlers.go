package server

import (
	"encoding/json"
	"fmt"
	"net/http"
	"time"

	"github.com/gorilla/mux"
	"github.com/helixml/helix/api/pkg/services"
	"github.com/helixml/helix/api/pkg/types"
	"github.com/rs/zerolog/log"
)

// createTaskFromPrompt godoc
// @Summary Create spec-driven task from simple prompt
// @Description Create a new task from a simple description and start spec generation
// @Tags    spec-driven-tasks
// @Accept  json
// @Produce json
// @Param   request body services.CreateTaskRequest true "Task creation request"
// @Success 201 {object} types.SpecTask
// @Failure 400 {object} types.APIError
// @Failure 500 {object} types.APIError
// @Router  /api/v1/spec-tasks/from-prompt [post]
func (s *HelixAPIServer) createTaskFromPrompt(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	user := getUserFromContext(ctx)
	if user == nil {
		http.Error(w, "unauthorized", http.StatusUnauthorized)
		return
	}

	var req services.CreateTaskRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		log.Error().Err(err).Msg("Failed to decode create task request")
		http.Error(w, "invalid request body", http.StatusBadRequest)
		return
	}

	// Set user ID from context
	req.UserID = user.ID

	// Validate request
	if req.Prompt == "" {
		http.Error(w, "prompt is required", http.StatusBadRequest)
		return
	}
	if req.ProjectID == "" {
		http.Error(w, "project_id is required", http.StatusBadRequest)
		return
	}

	// Create task via spec-driven service
	task, err := s.specDrivenTaskService.CreateTaskFromPrompt(ctx, &req)
	if err != nil {
		log.Error().Err(err).Msg("Failed to create task from prompt")
		http.Error(w, fmt.Sprintf("failed to create task: %v", err), http.StatusInternalServerError)
		return
	}

	log.Info().
		Str("task_id", task.ID).
		Str("user_id", user.ID).
		Str("project_id", req.ProjectID).
		Msg("Task created from prompt")

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusCreated)
	json.NewEncoder(w).Encode(task)
}

// getTask godoc
// @Summary Get spec-driven task details
// @Description Get detailed information about a specific spec-driven task
// @Tags    spec-driven-tasks
// @Produce json
// @Param   taskId path string true "Task ID"
// @Success 200 {object} types.SpecTask
// @Failure 404 {object} types.APIError
// @Failure 500 {object} types.APIError
// @Router  /api/v1/spec-tasks/{taskId} [get]
func (s *HelixAPIServer) getTask(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	vars := mux.Vars(r)
	taskID := vars["taskId"]

	if taskID == "" {
		http.Error(w, "task ID is required", http.StatusBadRequest)
		return
	}

	task, err := s.Store.GetSpecTask(ctx, taskID)
	if err != nil {
		log.Error().Err(err).Str("task_id", taskID).Msg("Failed to get task")
		http.Error(w, "task not found", http.StatusNotFound)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(task)
}

// listTasks godoc
// @Summary List spec-driven tasks
// @Description List spec-driven tasks with optional filtering by project, status, or user
// @Tags    spec-driven-tasks
// @Produce json
// @Param   project_id query string false "Filter by project ID"
// @Param   status query string false "Filter by status"
// @Param   user_id query string false "Filter by user ID"
// @Param   limit query int false "Limit number of results" default(50)
// @Param   offset query int false "Offset for pagination" default(0)
// @Success 200 {array} types.SpecTask
// @Failure 500 {object} types.APIError
// @Router  /api/v1/spec-tasks [get]
func (s *HelixAPIServer) listTasks(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	query := r.URL.Query()

	filters := &types.SpecTaskFilters{
		ProjectID: query.Get("project_id"),
		Status:    query.Get("status"),
		UserID:    query.Get("user_id"),
		Limit:     parseIntQuery(query.Get("limit"), 50),
		Offset:    parseIntQuery(query.Get("offset"), 0),
	}

	tasks, err := s.Store.ListSpecTasks(ctx, filters)
	if err != nil {
		log.Error().Err(err).Msg("Failed to list tasks")
		http.Error(w, fmt.Sprintf("failed to list tasks: %v", err), http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(tasks)
}

// approveSpecs godoc
// @Summary Approve or reject generated specifications
// @Description Human approval/rejection of specs generated by AI agent
// @Tags    spec-driven-tasks
// @Accept  json
// @Produce json
// @Param   taskId path string true "Task ID"
// @Param   request body types.SpecApprovalResponse true "Approval response"
// @Success 200 {object} types.SpecTask
// @Failure 400 {object} types.APIError
// @Failure 404 {object} types.APIError
// @Failure 500 {object} types.APIError
// @Router  /api/v1/spec-tasks/{taskId}/approve-specs [post]
func (s *HelixAPIServer) approveSpecs(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	user := getUserFromContext(ctx)
	if user == nil {
		http.Error(w, "unauthorized", http.StatusUnauthorized)
		return
	}

	vars := mux.Vars(r)
	taskID := vars["taskId"]

	if taskID == "" {
		http.Error(w, "task ID is required", http.StatusBadRequest)
		return
	}

	var req types.SpecApprovalResponse
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		log.Error().Err(err).Msg("Failed to decode approval request")
		http.Error(w, "invalid request body", http.StatusBadRequest)
		return
	}

	// Set fields from context and path
	req.TaskID = taskID
	req.ApprovedBy = user.ID
	req.ApprovedAt = time.Now()

	// Process approval
	err := s.specDrivenTaskService.ApproveSpecs(ctx, &req)
	if err != nil {
		log.Error().Err(err).Str("task_id", taskID).Msg("Failed to process spec approval")
		http.Error(w, fmt.Sprintf("failed to process approval: %v", err), http.StatusInternalServerError)
		return
	}

	// Return updated task
	task, err := s.Store.GetSpecTask(ctx, taskID)
	if err != nil {
		log.Error().Err(err).Str("task_id", taskID).Msg("Failed to get updated task")
		http.Error(w, "failed to get updated task", http.StatusInternalServerError)
		return
	}

	log.Info().
		Str("task_id", taskID).
		Str("user_id", user.ID).
		Bool("approved", req.Approved).
		Msg("Spec approval processed")

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(task)
}

// getTaskSpecs godoc
// @Summary Get task specifications for review
// @Description Get the generated specifications for human review
// @Tags    spec-driven-tasks
// @Produce json
// @Param   taskId path string true "Task ID"
// @Success 200 {object} TaskSpecsResponse
// @Failure 404 {object} types.APIError
// @Failure 500 {object} types.APIError
// @Router  /api/v1/spec-tasks/{taskId}/specs [get]
func (s *HelixAPIServer) getTaskSpecs(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	vars := mux.Vars(r)
	taskID := vars["taskId"]

	if taskID == "" {
		http.Error(w, "task ID is required", http.StatusBadRequest)
		return
	}

	task, err := s.Store.GetSpecTask(ctx, taskID)
	if err != nil {
		log.Error().Err(err).Str("task_id", taskID).Msg("Failed to get task")
		http.Error(w, "task not found", http.StatusNotFound)
		return
	}

	// Only return specs if they've been generated
	if task.Status == types.TaskStatusBacklog || task.Status == types.TaskStatusSpecGeneration {
		http.Error(w, "specifications not yet generated", http.StatusNotFound)
		return
	}

	response := TaskSpecsResponse{
		TaskID:             task.ID,
		Status:             task.Status,
		OriginalPrompt:     task.OriginalPrompt,
		RequirementsSpec:   task.RequirementsSpec,
		TechnicalDesign:    task.TechnicalDesign,
		ImplementationPlan: task.ImplementationPlan,
		SpecApprovedBy:     task.SpecApprovedBy,
		SpecApprovedAt:     task.SpecApprovedAt,
		SpecRevisionCount:  task.SpecRevisionCount,
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}

// getTaskProgress godoc
// @Summary Get spec-driven task progress
// @Description Get detailed progress information for a spec-driven task including specification and implementation phases
// @Tags    spec-driven-tasks
// @Produce json
// @Param   taskId path string true "Task ID"
// @Success 200 {object} TaskProgressResponse
// @Failure 404 {object} types.APIError
// @Failure 500 {object} types.APIError
// @Router  /api/v1/spec-tasks/{taskId}/progress [get]
func (s *HelixAPIServer) getTaskProgress(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	vars := mux.Vars(r)
	taskID := vars["taskId"]

	if taskID == "" {
		http.Error(w, "task ID is required", http.StatusBadRequest)
		return
	}

	task, err := s.Store.GetSpecTask(ctx, taskID)
	if err != nil {
		log.Error().Err(err).Str("task_id", taskID).Msg("Failed to get task")
		http.Error(w, "task not found", http.StatusNotFound)
		return
	}

	// Build progress response
	progress := TaskProgressResponse{
		TaskID:    task.ID,
		Status:    task.Status,
		CreatedAt: task.CreatedAt,
		UpdatedAt: task.UpdatedAt,
		Specification: PhaseProgress{
			Status:        getSpecificationStatus(task.Status),
			Agent:         task.SpecAgent,
			SessionID:     task.SpecSessionID,
			StartedAt:     task.CreatedAt, // Spec generation starts when task is created
			CompletedAt:   task.SpecApprovedAt,
			RevisionCount: task.SpecRevisionCount,
		},
		Implementation: PhaseProgress{
			Status:    getImplementationStatus(task.Status),
			Agent:     task.ImplementationAgent,
			SessionID: task.ImplementationSessionID,
			StartedAt: task.SpecApprovedAt,
			// CompletedAt will be set when implementation is done
		},
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(progress)
}

// Helper functions
func parseIntQuery(value string, defaultValue int) int {
	if value == "" {
		return defaultValue
	}
	// Simple parsing - you might want to use strconv.Atoi with error handling
	var result int
	if _, err := fmt.Sscanf(value, "%d", &result); err != nil {
		return defaultValue
	}
	return result
}

func getSpecificationStatus(taskStatus string) string {
	switch taskStatus {
	case types.TaskStatusBacklog:
		return "pending"
	case types.TaskStatusSpecGeneration:
		return "in_progress"
	case types.TaskStatusSpecReview:
		return "awaiting_review"
	case types.TaskStatusSpecRevision:
		return "revision_requested"
	case types.TaskStatusSpecApproved:
		return "completed"
	case types.TaskStatusSpecFailed:
		return "failed"
	default:
		if isImplementationStatus(taskStatus) {
			return "completed"
		}
		return "unknown"
	}
}

func getImplementationStatus(taskStatus string) string {
	switch taskStatus {
	case types.TaskStatusImplementationQueued:
		return "queued"
	case types.TaskStatusImplementation:
		return "in_progress"
	case types.TaskStatusImplementationReview:
		return "code_review"
	case types.TaskStatusDone:
		return "completed"
	case types.TaskStatusImplementationFailed:
		return "failed"
	default:
		if isSpecificationStatus(taskStatus) {
			return "pending"
		}
		return "unknown"
	}
}

func isSpecificationStatus(status string) bool {
	specificationStatuses := []string{
		types.TaskStatusBacklog,
		types.TaskStatusSpecGeneration,
		types.TaskStatusSpecReview,
		types.TaskStatusSpecRevision,
		types.TaskStatusSpecApproved,
		types.TaskStatusSpecFailed,
	}
	for _, s := range specificationStatuses {
		if s == status {
			return true
		}
	}
	return false
}

func isImplementationStatus(status string) bool {
	implementationStatuses := []string{
		types.TaskStatusImplementationQueued,
		types.TaskStatusImplementation,
		types.TaskStatusImplementationReview,
		types.TaskStatusDone,
		types.TaskStatusImplementationFailed,
	}
	for _, s := range implementationStatuses {
		if s == status {
			return true
		}
	}
	return false
}

// Response types
type TaskSpecsResponse struct {
	TaskID             string     `json:"task_id"`
	Status             string     `json:"status"`
	OriginalPrompt     string     `json:"original_prompt"`
	RequirementsSpec   string     `json:"requirements_spec"`
	TechnicalDesign    string     `json:"technical_design"`
	ImplementationPlan string     `json:"implementation_plan"`
	SpecApprovedBy     string     `json:"spec_approved_by,omitempty"`
	SpecApprovedAt     *time.Time `json:"spec_approved_at,omitempty"`
	SpecRevisionCount  int        `json:"spec_revision_count"`
}

type TaskProgressResponse struct {
	TaskID         string        `json:"task_id"`
	Status         string        `json:"status"`
	CreatedAt      time.Time     `json:"created_at"`
	UpdatedAt      time.Time     `json:"updated_at"`
	Specification  PhaseProgress `json:"specification"`
	Implementation PhaseProgress `json:"implementation"`
}

type PhaseProgress struct {
	Status        string     `json:"status"`
	Agent         string     `json:"agent,omitempty"`
	SessionID     string     `json:"session_id,omitempty"`
	StartedAt     *time.Time `json:"started_at,omitempty"`
	CompletedAt   *time.Time `json:"completed_at,omitempty"`
	RevisionCount int        `json:"revision_count,omitempty"`
}
