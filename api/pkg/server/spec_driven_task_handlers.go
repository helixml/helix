package server

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"time"

	"github.com/gorilla/mux"
	"github.com/helixml/helix/api/pkg/services"
	"github.com/helixml/helix/api/pkg/types"
	"github.com/rs/zerolog/log"
)

// createTaskFromPrompt godoc
// @Summary Create spec-driven task from simple prompt
// @Description Create a new task from a simple description and start spec generation
// @Tags    spec-driven-tasks
// @Accept  json
// @Produce json
// @Param   request body services.CreateTaskRequest true "Task creation request"
// @Success 201 {object} types.SpecTask
// @Failure 400 {object} types.APIError
// @Failure 500 {object} types.APIError
// @Router  /api/v1/spec-tasks/from-prompt [post]
func (s *HelixAPIServer) createTaskFromPrompt(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	user := getRequestUser(r)
	if user == nil {
		http.Error(w, "unauthorized", http.StatusUnauthorized)
		return
	}

	var req services.CreateTaskRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		log.Error().Err(err).Msg("Failed to decode create task request")
		http.Error(w, "invalid request body", http.StatusBadRequest)
		return
	}

	// Set user ID from context
	req.UserID = user.ID

	// Validate request
	if req.Prompt == "" {
		http.Error(w, "prompt is required", http.StatusBadRequest)
		return
	}
	if req.ProjectID == "" {
		http.Error(w, "project_id is required", http.StatusBadRequest)
		return
	}

	// Create task via spec-driven service
	task, err := s.specDrivenTaskService.CreateTaskFromPrompt(ctx, &req)
	if err != nil {
		log.Error().Err(err).Msg("Failed to create task from prompt")
		http.Error(w, fmt.Sprintf("failed to create task: %v", err), http.StatusInternalServerError)
		return
	}

	log.Info().
		Str("task_id", task.ID).
		Str("user_id", user.ID).
		Str("project_id", req.ProjectID).
		Msg("Task created from prompt")

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusCreated)
	json.NewEncoder(w).Encode(task)
}

// getTask godoc
// @Summary Get spec-driven task details
// @Description Get detailed information about a specific spec-driven task
// @Tags    spec-driven-tasks
// @Produce json
// @Param   taskId path string true "Task ID"
// @Success 200 {object} types.SpecTask
// @Failure 404 {object} types.APIError
// @Failure 500 {object} types.APIError
// @Router  /api/v1/spec-tasks/{taskId} [get]
func (s *HelixAPIServer) getTask(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	vars := mux.Vars(r)
	taskID := vars["taskId"]

	if taskID == "" {
		http.Error(w, "task ID is required", http.StatusBadRequest)
		return
	}

	task, err := s.Store.GetSpecTask(ctx, taskID)
	if err != nil {
		log.Error().Err(err).Str("task_id", taskID).Msg("Failed to get task")
		http.Error(w, "task not found", http.StatusNotFound)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(task)
}

// listTasks godoc
// @Summary List spec-driven tasks
// @Description List spec-driven tasks with optional filtering by project, status, or user
// @Tags    spec-driven-tasks
// @Produce json
// @Param   project_id query string false "Filter by project ID"
// @Param   status query string false "Filter by status"
// @Param   user_id query string false "Filter by user ID"
// @Param   include_archived query bool false "Include archived tasks" default(false)
// @Param   limit query int false "Limit number of results" default(50)
// @Param   offset query int false "Offset for pagination" default(0)
// @Success 200 {array} types.SpecTask
// @Failure 500 {object} types.APIError
// @Router  /api/v1/spec-tasks [get]
func (s *HelixAPIServer) listTasks(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	query := r.URL.Query()

	filters := &types.SpecTaskFilters{
		ProjectID:       query.Get("project_id"),
		Status:          query.Get("status"),
		UserID:          query.Get("user_id"),
		Limit:           parseIntQuery(query.Get("limit"), 50),
		Offset:          parseIntQuery(query.Get("offset"), 0),
		IncludeArchived: query.Get("include_archived") == "true",
		ArchivedOnly:    query.Get("archived_only") == "true",
	}

	tasks, err := s.Store.ListSpecTasks(ctx, filters)
	if err != nil {
		log.Error().Err(err).Msg("Failed to list tasks")
		http.Error(w, fmt.Sprintf("failed to list tasks: %v", err), http.StatusInternalServerError)
		return
	}

	// Ensure we return an empty array instead of null for empty results
	if tasks == nil {
		tasks = []*types.SpecTask{}
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(tasks)
}

// approveSpecs godoc
// @Summary Approve or reject generated specifications
// @Description Human approval/rejection of specs generated by AI agent
// @Tags    spec-driven-tasks
// @Accept  json
// @Produce json
// @Param   taskId path string true "Task ID"
// @Param   request body types.SpecApprovalResponse true "Approval response"
// @Success 200 {object} types.SpecTask
// @Failure 400 {object} types.APIError
// @Failure 404 {object} types.APIError
// @Failure 500 {object} types.APIError
// @Router  /api/v1/spec-tasks/{taskId}/approve-specs [post]
func (s *HelixAPIServer) approveSpecs(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	user := getRequestUser(r)
	if user == nil {
		http.Error(w, "unauthorized", http.StatusUnauthorized)
		return
	}

	vars := mux.Vars(r)
	taskID := vars["taskId"]

	if taskID == "" {
		http.Error(w, "task ID is required", http.StatusBadRequest)
		return
	}

	var req types.SpecApprovalResponse
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		log.Error().Err(err).Msg("Failed to decode approval request")
		http.Error(w, "invalid request body", http.StatusBadRequest)
		return
	}

	// Set fields from context and path
	req.TaskID = taskID
	req.ApprovedBy = user.ID
	req.ApprovedAt = time.Now()

	// Process approval
	err := s.specDrivenTaskService.ApproveSpecs(ctx, &req)
	if err != nil {
		log.Error().Err(err).Str("task_id", taskID).Msg("Failed to process spec approval")
		http.Error(w, fmt.Sprintf("failed to process approval: %v", err), http.StatusInternalServerError)
		return
	}

	// Return updated task
	task, err := s.Store.GetSpecTask(ctx, taskID)
	if err != nil {
		log.Error().Err(err).Str("task_id", taskID).Msg("Failed to get updated task")
		http.Error(w, "failed to get updated task", http.StatusInternalServerError)
		return
	}

	log.Info().
		Str("task_id", taskID).
		Str("user_id", user.ID).
		Bool("approved", req.Approved).
		Msg("Spec approval processed")

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(task)
}

// getTaskSpecs godoc
// @Summary Get task specifications for review
// @Description Get the generated specifications for human review
// @Tags    spec-driven-tasks
// @Produce json
// @Param   taskId path string true "Task ID"
// @Success 200 {object} TaskSpecsResponse
// @Failure 404 {object} types.APIError
// @Failure 500 {object} types.APIError
// @Router  /api/v1/spec-tasks/{taskId}/specs [get]
func (s *HelixAPIServer) getTaskSpecs(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	vars := mux.Vars(r)
	taskID := vars["taskId"]

	if taskID == "" {
		http.Error(w, "task ID is required", http.StatusBadRequest)
		return
	}

	task, err := s.Store.GetSpecTask(ctx, taskID)
	if err != nil {
		log.Error().Err(err).Str("task_id", taskID).Msg("Failed to get task")
		http.Error(w, "task not found", http.StatusNotFound)
		return
	}

	// Only return specs if they've been generated
	if task.Status == types.TaskStatusBacklog || task.Status == types.TaskStatusSpecGeneration {
		http.Error(w, "specifications not yet generated", http.StatusNotFound)
		return
	}

	response := TaskSpecsResponse{
		TaskID:             task.ID,
		Status:             task.Status,
		OriginalPrompt:     task.OriginalPrompt,
		RequirementsSpec:   task.RequirementsSpec,
		TechnicalDesign:    task.TechnicalDesign,
		ImplementationPlan: task.ImplementationPlan,
		SpecApprovedBy:     task.SpecApprovedBy,
		SpecApprovedAt:     task.SpecApprovedAt,
		SpecRevisionCount:  task.SpecRevisionCount,
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}

// getTaskProgress godoc
// @Summary Get spec-driven task progress
// @Description Get detailed progress information for a spec-driven task including specification and implementation phases
// @Tags    spec-driven-tasks
// @Produce json
// @Param   taskId path string true "Task ID"
// @Success 200 {object} TaskProgressResponse
// @Failure 404 {object} types.APIError
// @Failure 500 {object} types.APIError
// @Router  /api/v1/spec-tasks/{taskId}/progress [get]
func (s *HelixAPIServer) getTaskProgress(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	vars := mux.Vars(r)
	taskID := vars["taskId"]

	if taskID == "" {
		http.Error(w, "task ID is required", http.StatusBadRequest)
		return
	}

	task, err := s.Store.GetSpecTask(ctx, taskID)
	if err != nil {
		log.Error().Err(err).Str("task_id", taskID).Msg("Failed to get task")
		http.Error(w, "task not found", http.StatusNotFound)
		return
	}

	// Build progress response
	progress := TaskProgressResponse{
		TaskID:    task.ID,
		Status:    task.Status,
		CreatedAt: task.CreatedAt,
		UpdatedAt: task.UpdatedAt,
		Specification: PhaseProgress{
			Status:        getSpecificationStatus(task.Status),
			Agent:         task.SpecAgent,
			SessionID:     task.SpecSessionID,
			StartedAt:     &task.CreatedAt, // Spec generation starts when task is created
			CompletedAt:   task.SpecApprovedAt,
			RevisionCount: task.SpecRevisionCount,
		},
		Implementation: PhaseProgress{
			Status:    getImplementationStatus(task.Status),
			Agent:     task.ImplementationAgent,
			SessionID: task.ImplementationSessionID,
			StartedAt: task.SpecApprovedAt,
			// CompletedAt will be set when implementation is done
		},
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(progress)
}

// Helper functions
func parseIntQuery(value string, defaultValue int) int {
	if value == "" {
		return defaultValue
	}
	// Simple parsing - you might want to use strconv.Atoi with error handling
	var result int
	if _, err := fmt.Sscanf(value, "%d", &result); err != nil {
		return defaultValue
	}
	return result
}

// startPlanning godoc
// @Summary Start planning for a SpecTask
// @Description Explicitly start spec generation (planning phase) for a backlog task. This transitions the task to planning status and starts a spec generation session.
// @Tags spec-driven-tasks
// @Accept json
// @Produce json
// @Param taskId path string true "SpecTask ID"
// @Success 200 {object} types.SpecTask
// @Failure 400 {object} types.APIError
// @Failure 404 {object} types.APIError
// @Failure 500 {object} types.APIError
// @Router /api/v1/spec-tasks/{taskId}/start-planning [post]
// @Security BearerAuth
func (s *HelixAPIServer) startPlanning(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	user := getRequestUser(r)
	if user == nil {
		http.Error(w, "unauthorized", http.StatusUnauthorized)
		return
	}

	vars := mux.Vars(r)
	taskID := vars["taskId"]
	if taskID == "" {
		http.Error(w, "task ID is required", http.StatusBadRequest)
		return
	}

	// Get the task
	task, err := s.Store.GetSpecTask(ctx, taskID)
	if err != nil {
		log.Error().Err(err).Str("task_id", taskID).Msg("Failed to get SpecTask")
		http.Error(w, "SpecTask not found", http.StatusNotFound)
		return
	}

	// Verify task is in backlog status
	if task.Status != types.TaskStatusBacklog {
		http.Error(w, fmt.Sprintf("task is not in backlog status (current: %s)", task.Status), http.StatusBadRequest)
		return
	}

	// Start spec generation
	go s.specDrivenTaskService.StartSpecGeneration(context.Background(), task)

	// Return updated task (status will be updated asynchronously)
	task.Status = types.TaskStatusSpecGeneration
	task.UpdatedAt = time.Now()

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(task)
}

// updateSpecTask handles PUT /api/v1/spec-tasks/{taskId}
// @Summary Update SpecTask
// @Description Update SpecTask status, priority, or other fields
// @Tags spec-driven-tasks
// @Accept json
// @Produce json
// @Param taskId path string true "SpecTask ID"
// @Param request body types.SpecTaskUpdateRequest true "Update request"
// @Success 200 {object} types.SpecTask
// @Failure 400 {object} types.APIError
// @Failure 404 {object} types.APIError
// @Failure 500 {object} types.APIError
// @Router /api/v1/spec-tasks/{taskId} [put]
// @Security BearerAuth
func (s *HelixAPIServer) updateSpecTask(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	taskID := vars["taskId"]
	if taskID == "" {
		http.Error(w, "task ID is required", http.StatusBadRequest)
		return
	}

	var updateReq types.SpecTaskUpdateRequest
	if err := json.NewDecoder(r.Body).Decode(&updateReq); err != nil {
		log.Error().Err(err).Msg("Failed to decode SpecTask update request")
		http.Error(w, "invalid request body", http.StatusBadRequest)
		return
	}

	// Get existing task
	task, err := s.Store.GetSpecTask(r.Context(), taskID)
	if err != nil {
		log.Error().Err(err).Str("task_id", taskID).Msg("Failed to get SpecTask for update")
		http.Error(w, "SpecTask not found", http.StatusNotFound)
		return
	}

	// Update fields if provided
	if updateReq.Status != "" {
		task.Status = updateReq.Status
	}
	if updateReq.Priority != "" {
		task.Priority = updateReq.Priority
	}
	if updateReq.Name != "" {
		task.Name = updateReq.Name
	}
	if updateReq.Description != "" {
		task.Description = updateReq.Description
	}

	// Update in store
	err = s.Store.UpdateSpecTask(r.Context(), task)
	if err != nil {
		log.Error().Err(err).Str("task_id", taskID).Msg("Failed to update SpecTask")
		http.Error(w, fmt.Sprintf("failed to update SpecTask: %v", err), http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(task)
}

// archiveSpecTask godoc
// @Summary Archive or unarchive a spec task
// @Description Archive a spec task to hide it from the main view, or unarchive to restore it
// @Tags spec-driven-tasks
// @Accept json
// @Produce json
// @Param taskId path string true "Task ID"
// @Param archived body bool true "Archive status (true to archive, false to unarchive)"
// @Success 200 {object} types.SpecTask
// @Failure 400 {object} types.APIError
// @Failure 404 {object} types.APIError
// @Failure 500 {object} types.APIError
// @Router /api/v1/spec-tasks/{taskId}/archive [patch]
// @Security BearerAuth
func (s *HelixAPIServer) archiveSpecTask(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	taskID := vars["taskId"]
	if taskID == "" {
		http.Error(w, "task ID is required", http.StatusBadRequest)
		return
	}

	var req struct {
		Archived bool `json:"archived"`
	}
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		log.Error().Err(err).Msg("Failed to decode archive request")
		http.Error(w, "invalid request body", http.StatusBadRequest)
		return
	}

	// Get existing task
	task, err := s.Store.GetSpecTask(r.Context(), taskID)
	if err != nil {
		log.Error().Err(err).Str("task_id", taskID).Msg("Failed to get SpecTask for archiving")
		http.Error(w, "SpecTask not found", http.StatusNotFound)
		return
	}

	// Update archived status
	task.Archived = req.Archived

	// Update in store
	err = s.Store.UpdateSpecTask(r.Context(), task)
	if err != nil {
		log.Error().Err(err).Str("task_id", taskID).Msg("Failed to archive SpecTask")
		http.Error(w, fmt.Sprintf("failed to archive SpecTask: %v", err), http.StatusInternalServerError)
		return
	}

	action := "archived"
	if !req.Archived {
		action = "unarchived"
	}
	log.Info().Str("task_id", taskID).Bool("archived", req.Archived).Msgf("SpecTask %s", action)

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(task)
}

func getSpecificationStatus(taskStatus string) string {
	switch taskStatus {
	case types.TaskStatusBacklog:
		return "pending"
	case types.TaskStatusSpecGeneration:
		return "in_progress"
	case types.TaskStatusSpecReview:
		return "awaiting_review"
	case types.TaskStatusSpecRevision:
		return "revision_requested"
	case types.TaskStatusSpecApproved:
		return "completed"
	case types.TaskStatusSpecFailed:
		return "failed"
	default:
		if isImplementationStatus(taskStatus) {
			return "completed"
		}
		return "unknown"
	}
}

func getImplementationStatus(taskStatus string) string {
	switch taskStatus {
	case types.TaskStatusImplementationQueued:
		return "queued"
	case types.TaskStatusImplementation:
		return "in_progress"
	case types.TaskStatusImplementationReview:
		return "code_review"
	case types.TaskStatusDone:
		return "completed"
	case types.TaskStatusImplementationFailed:
		return "failed"
	default:
		if isSpecificationStatus(taskStatus) {
			return "pending"
		}
		return "unknown"
	}
}

func isSpecificationStatus(status string) bool {
	specificationStatuses := []string{
		types.TaskStatusBacklog,
		types.TaskStatusSpecGeneration,
		types.TaskStatusSpecReview,
		types.TaskStatusSpecRevision,
		types.TaskStatusSpecApproved,
		types.TaskStatusSpecFailed,
	}
	for _, s := range specificationStatuses {
		if s == status {
			return true
		}
	}
	return false
}

func isImplementationStatus(status string) bool {
	implementationStatuses := []string{
		types.TaskStatusImplementationQueued,
		types.TaskStatusImplementation,
		types.TaskStatusImplementationReview,
		types.TaskStatusDone,
		types.TaskStatusImplementationFailed,
	}
	for _, s := range implementationStatuses {
		if s == status {
			return true
		}
	}
	return false
}

// Response types
type TaskSpecsResponse struct {
	TaskID             string     `json:"task_id"`
	Status             string     `json:"status"`
	OriginalPrompt     string     `json:"original_prompt"`
	RequirementsSpec   string     `json:"requirements_spec"`
	TechnicalDesign    string     `json:"technical_design"`
	ImplementationPlan string     `json:"implementation_plan"`
	SpecApprovedBy     string     `json:"spec_approved_by,omitempty"`
	SpecApprovedAt     *time.Time `json:"spec_approved_at,omitempty"`
	SpecRevisionCount  int        `json:"spec_revision_count"`
}

type TaskProgressResponse struct {
	TaskID         string        `json:"task_id"`
	Status         string        `json:"status"`
	CreatedAt      time.Time     `json:"created_at"`
	UpdatedAt      time.Time     `json:"updated_at"`
	Specification  PhaseProgress `json:"specification"`
	Implementation PhaseProgress `json:"implementation"`
}

type PhaseProgress struct {
	Status        string     `json:"status"`
	Agent         string     `json:"agent,omitempty"`
	SessionID     string     `json:"session_id,omitempty"`
	StartedAt     *time.Time `json:"started_at,omitempty"`
	CompletedAt   *time.Time `json:"completed_at,omitempty"`
	RevisionCount int        `json:"revision_count,omitempty"`
}

// BoardSettings represents the Kanban board settings for a project
type BoardSettings struct {
	WIPLimits map[string]int `json:"wip_limits"`
}

// getBoardSettings godoc
// @Summary Get board settings for spec tasks
// @Description Get the Kanban board settings (WIP limits) for the default project
// @Tags spec-driven-tasks
// @Produce json
// @Success 200 {object} BoardSettings
// @Failure 500 {object} types.APIError
// @Router /api/v1/spec-tasks/board-settings [get]
// @Security BearerAuth
func (s *HelixAPIServer) getBoardSettings(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	// Get default project
	project, err := s.Store.GetProject(ctx, "default")
	if err != nil {
		log.Error().Err(err).Msg("Failed to get default project")
		http.Error(w, "failed to get board settings", http.StatusInternalServerError)
		return
	}

	// Parse metadata to extract board settings
	var metadata map[string]interface{}
	if err := json.Unmarshal(project.Metadata, &metadata); err != nil {
		log.Error().Err(err).Msg("Failed to parse project metadata")
		http.Error(w, "failed to parse board settings", http.StatusInternalServerError)
		return
	}

	boardSettingsData, ok := metadata["board_settings"].(map[string]interface{})
	if !ok {
		// Return default settings if not found
		boardSettings := BoardSettings{
			WIPLimits: map[string]int{
				"planning":       3,
				"review":         2,
				"implementation": 5,
			},
		}
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(boardSettings)
		return
	}

	wipLimitsData, ok := boardSettingsData["wip_limits"].(map[string]interface{})
	if !ok {
		log.Error().Msg("Invalid wip_limits format in metadata")
		http.Error(w, "invalid board settings format", http.StatusInternalServerError)
		return
	}

	// Convert to map[string]int
	wipLimits := make(map[string]int)
	for k, v := range wipLimitsData {
		if limit, ok := v.(float64); ok {
			wipLimits[k] = int(limit)
		}
	}

	boardSettings := BoardSettings{
		WIPLimits: wipLimits,
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(boardSettings)
}

// updateBoardSettings godoc
// @Summary Update board settings for spec tasks
// @Description Update the Kanban board settings (WIP limits) for the default project
// @Tags spec-driven-tasks
// @Accept json
// @Produce json
// @Param request body BoardSettings true "Board settings"
// @Success 200 {object} BoardSettings
// @Failure 400 {object} types.APIError
// @Failure 500 {object} types.APIError
// @Router /api/v1/spec-tasks/board-settings [put]
// @Security BearerAuth
func (s *HelixAPIServer) updateBoardSettings(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	user := getRequestUser(r)
	if user == nil {
		http.Error(w, "unauthorized", http.StatusUnauthorized)
		return
	}

	var settings BoardSettings
	if err := json.NewDecoder(r.Body).Decode(&settings); err != nil {
		log.Error().Err(err).Msg("Failed to decode board settings")
		http.Error(w, "invalid request body", http.StatusBadRequest)
		return
	}

	// Get default project
	project, err := s.Store.GetProject(ctx, "default")
	if err != nil {
		log.Error().Err(err).Msg("Failed to get default project")
		http.Error(w, "failed to update board settings", http.StatusInternalServerError)
		return
	}

	// Parse existing metadata
	var metadata map[string]interface{}
	if len(project.Metadata) > 0 {
		if err := json.Unmarshal(project.Metadata, &metadata); err != nil {
			log.Error().Err(err).Msg("Failed to parse project metadata")
			http.Error(w, "failed to parse existing settings", http.StatusInternalServerError)
			return
		}
	} else {
		metadata = make(map[string]interface{})
	}

	// Update board settings in metadata
	metadata["board_settings"] = map[string]interface{}{
		"wip_limits": settings.WIPLimits,
	}

	// Marshal back to JSON
	newMetadata, err := json.Marshal(metadata)
	if err != nil {
		log.Error().Err(err).Msg("Failed to marshal metadata")
		http.Error(w, "failed to save settings", http.StatusInternalServerError)
		return
	}

	// Update project
	project.Metadata = newMetadata
	project.UpdatedAt = time.Now()

	err = s.Store.UpdateProject(ctx, project)
	if err != nil {
		log.Error().Err(err).Msg("Failed to save project")
		http.Error(w, "failed to save board settings", http.StatusInternalServerError)
		return
	}

	log.Info().
		Str("user_id", user.ID).
		Interface("wip_limits", settings.WIPLimits).
		Msg("Updated board settings")

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(settings)
}
