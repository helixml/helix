package types

import (
	"context"
	"time"
)

type BalanceTransferData struct {
	JobID           string `json:"job_id"`
	StripePaymentID string `json:"stripe_payment_id"`
}

type BalanceTransfer struct {
	ID          string              `json:"id"`
	Created     time.Time           `json:"created"`
	Owner       string              `json:"owner"`
	OwnerType   OwnerType           `json:"owner_type"`
	PaymentType PaymentType         `json:"payment_type"`
	Amount      int                 `json:"amount"`
	Data        BalanceTransferData `json:"data"`
}

type Module struct {
	ID       string `json:"id"`
	Title    string `json:"title"`
	Cost     int    `json:"cost"`
	Template string `json:"template"`
}

type Interaction struct {
	ID       string      `json:"id"`
	Created  time.Time   `json:"created"`
	Creator  CreatorType `json:"creator"`  // e.g. User
	Message  string      `json:"message"`  // e.g. Prove pythagoras
	Files    []string    `json:"uploads"`  // list of filepath paths
	Finished bool        `json:"finished"` // if true, the message has finished being written to, and is ready for a response (e.g. from the other participant)
}

type Session struct {
	ID string `json:"id"`
	// name that goes in the UI - ideally autogenerated by AI but for now can be
	// named manually
	Name    string    `json:"name"`
	Created time.Time `json:"created"`
	Updated time.Time `json:"updated"`
	// e.g. inference, finetune
	Mode SessionMode `json:"mode"`
	// e.g. text, image
	Type SessionType `json:"type"`
	// huggingface model name e.g. mistralai/Mistral-7B-Instruct-v0.1 or
	// stabilityai/stable-diffusion-xl-base-1.0
	ModelName ModelName `json:"model_name"`
	// if type == finetune, we record a filestore path to e.g. lora file here
	// currently the only place you can do inference on a finetune is within the
	// session where the finetune was generated
	FinetuneFile string `json:"finetune_file"`
	// for now we just whack the entire history of the interaction in here, json
	// style
	Interactions []Interaction `json:"interactions"`
	// uuid of owner entity
	Owner string `json:"owner"`
	// e.g. user, system, org
	OwnerType OwnerType `json:"owner_type"`
}

type SessionFilterDeprioritize struct {
	Mode      SessionMode `json:"mode"`
	ModelName ModelName   `json:"model_name"`
}

type SessionFilter struct {
	// e.g. inference, finetune
	Mode SessionMode `json:"mode"`
	// e.g. text, image
	Type SessionType `json:"type"`
	// huggingface model name e.g. mistralai/Mistral-7B-Instruct-v0.1 or
	// stabilityai/stable-diffusion-xl-base-1.0
	ModelName ModelName `json:"model_name"`
	// the filestore path to the file being used for finetuning
	FinetuneFile string `json:"finetune_file"`
	// this means "only give me sessions that will fit in this much ram"
	Memory uint64 `json:"memory"`

	// the list of model name / mode combos that we should skip over
	// on the first pass - we are allowed to return one of these types
	// as long as we've chcked for other types first
	Deprioritize []SessionFilterDeprioritize `json:"deprioritize"`
}

// passed between the api server and the controller
type RequestContext struct {
	Ctx       context.Context
	Owner     string
	OwnerType OwnerType
}

type UserStatus struct {
	User    string `json:"user"`
	Credits int    `json:"credits"`
}

type WebsocketEvent struct {
	Type    WebsocketEventType `json:"type"`
	Session *Session           `json:"session"`
}

// the context of a long running python process
// on a runner - this will be used to inject the env
// into the cmd returned by the model instance.GetCommand() function
type RunnerProcessConfig struct {
	// the id of the model instance
	InstanceID string `json:"instance_id"`
	// the URL to ask for more tasks
	TaskURL string `json:"task_url"`
	// the URL to send responses to
	ResponseURL string `json:"response_url"`
}

// the api and runner parent controller will speak to each other
// in terms of "sessions" - i.e. entities with full historical context
// the running controller - when preparing a task for the python child
// will convert the session into what we are calling a "prompt"
// each model knows how to convert a full session in a text string that we feed into the
// mode as a prompt (for example Mistral will wrap the last message with [INST][/INST])
// the WorkerPrompt object has the result of this conversion and is the thing
// the python code will pull in from the runner controller
// the WorkerPrompt also contains the full session so that if the Python wants to do
// something funky - it can by ignoring the top level prompt and interpreting the session
// how it wants - most models python code will only use the top level fields however
type WorkerTask struct {
	SessionID string  `json:"session_id"`
	Session   Session `json:"session"`
	// the string that we are calling the prompt that we will feed into the model
	Prompt string `json:"prompt"`
	// the path to the local files we will use for fine tuning
	FinetuneFile string `json:"finetune_file"`
}

type WorkerTaskResponse struct {
	// the python code MUST include these 2 fields at least
	Type      WorkerTaskResponseType `json:"type"`
	SessionID string                 `json:"session_id"`
	// this is filled in by the runner parent before posting back to the api
	// the python does not need to know which interaction id it's handling
	InteractionID string `json:"interaction_id"`
	// the fields of an interaction that the backend python process can update
	Message string   `json:"message"` // e.g. Prove pythagoras
	Files   []string `json:"uploads"` // list of filepath paths
}
