package types

import (
	"context"
	"encoding/json"
	"errors"
	"time"
)

type BalanceTransferData struct {
	JobID           string `json:"job_id"`
	StripePaymentID string `json:"stripe_payment_id"`
}

type BalanceTransfer struct {
	ID          string              `json:"id"`
	Created     time.Time           `json:"created"`
	Owner       string              `json:"owner"`
	OwnerType   OwnerType           `json:"owner_type"`
	PaymentType PaymentType         `json:"payment_type"`
	Amount      int                 `json:"amount"`
	Data        BalanceTransferData `json:"data"`
}

type Module struct {
	ID       string `json:"id"`
	Title    string `json:"title"`
	Cost     int    `json:"cost"`
	Template string `json:"template"`
}

type Interaction struct {
	ID      string      `json:"id"`
	Created time.Time   `json:"created"`
	Creator CreatorType `json:"creator"` // e.g. User
	// the ID of the runner that processed this interaction
	Runner   string            `json:"runner"`   // e.g. 0
	Message  string            `json:"message"`  // e.g. Prove pythagoras
	Progress int               `json:"progress"` // e.g. 0-100
	Files    []string          `json:"files"`    // list of filepath paths
	Finished bool              `json:"finished"` // if true, the message has finished being written to, and is ready for a response (e.g. from the other participant)
	Metadata map[string]string `json:"metadata"` // different modes and models can put values here - for example, the image fine tuning will keep labels here to display in the frontend
	State    InteractionState  `json:"state"`
	Status   string            `json:"status"`
	Error    string            `json:"error"`
	// we hoist this from files so a single interaction knows that it "Created a finetune file"
	LoraDir string `json:"lora_dir"`
}

type Session struct {
	ID string `json:"id"`
	// name that goes in the UI - ideally autogenerated by AI but for now can be
	// named manually
	Name          string    `json:"name"`
	Created       time.Time `json:"created"`
	Updated       time.Time `json:"updated"`
	ParentSession string    `json:"parent_session"`
	// e.g. inference, finetune
	Mode SessionMode `json:"mode"`
	// e.g. text, image
	Type SessionType `json:"type"`
	// huggingface model name e.g. mistralai/Mistral-7B-Instruct-v0.1 or
	// stabilityai/stable-diffusion-xl-base-1.0
	ModelName ModelName `json:"model_name"`
	// if type == finetune, we record a filestore path to e.g. lora file here
	// currently the only place you can do inference on a finetune is within the
	// session where the finetune was generated
	LoraDir string `json:"lora_dir"`
	// for now we just whack the entire history of the interaction in here, json
	// style
	Interactions []Interaction `json:"interactions"`
	// uuid of owner entity
	Owner string `json:"owner"`
	// e.g. user, system, org
	OwnerType OwnerType `json:"owner_type"`
}

type SessionFilterModel struct {
	Mode         SessionMode `json:"mode"`
	ModelName    ModelName   `json:"model_name"`
	FinetuneFile string      `json:"finetune_file"`
}

type Duration time.Duration

func (d Duration) MarshalJSON() ([]byte, error) {
	return json.Marshal(time.Duration(d).String())
}

func (d *Duration) UnmarshalJSON(b []byte) error {
	var v interface{}
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	switch value := v.(type) {
	case string:
		tmp, err := time.ParseDuration(value)
		if err != nil {
			return err
		}
		*d = Duration(tmp)
		return nil
	default:
		return errors.New("invalid duration")
	}
}

type SessionFilter struct {
	// e.g. inference, finetune
	Mode SessionMode `json:"mode"`
	// e.g. text, image
	Type SessionType `json:"type"`
	// huggingface model name e.g. mistralai/Mistral-7B-Instruct-v0.1 or
	// stabilityai/stable-diffusion-xl-base-1.0
	ModelName ModelName `json:"model_name"`
	// the filestore path to the file being used for finetuning
	LoraDir string `json:"lora_dir"`
	// this means "only give me sessions that will fit in this much ram"
	Memory uint64 `json:"memory"`

	// the list of model name / mode combos that we should skip over
	// normally used by runners that are running multiple types in parallel
	// who don't want another version of what they are already running
	Reject []SessionFilterModel `json:"reject"`

	// only accept sessions that were created more than this duration ago
	Older Duration `json:"older"`
}

type ApiKey struct {
	Owner     string    `json:"owner"`
	OwnerType OwnerType `json:"owner_type"`
	Key       string    `json:"key"`
	Name      string    `json:"name"`
}

// passed between the api server and the controller
type RequestContext struct {
	Ctx       context.Context
	Admin     bool
	Owner     string
	OwnerType OwnerType
}

type UserStatus struct {
	Admin   bool   `json:"admin"`
	User    string `json:"user"`
	Credits int    `json:"credits"`
}

// a single envelope that is broadcast to users
type WebsocketEvent struct {
	Type               WebsocketEventType  `json:"type"`
	SessionID          string              `json:"session_id"`
	Owner              string              `json:"owner"`
	Session            *Session            `json:"session"`
	WorkerTaskResponse *RunnerTaskResponse `json:"worker_task_response"`
}

// the context of a long running python process
// on a runner - this will be used to inject the env
// into the cmd returned by the model instance.GetCommand() function
type RunnerProcessConfig struct {
	// the id of the model instance
	InstanceID string `json:"instance_id"`
	// the URL to ask for more tasks
	// this will pop the task from the queue
	NextTaskURL string `json:"next_task_url"`
	// the URL to ask for what the session is (e.g. to know what finetune_file to load)
	// this is readonly and will not pop the session(task) from the queue
	InitialSessionURL string `json:"initial_session_url"`
}

// a session will run "tasks" on runners
// task's job is to take the most recent user interaction
// and add a response to it in the form of a system interaction
// the api controller will have already appended the system interaction
// to the very end of the Session.Interactions list
// our job is to fill in the Message and/or Files field of that interaction
type RunnerTask struct {
	SessionID string `json:"session_id"`
	// the string that we are calling the prompt that we will feed into the model
	Prompt string `json:"prompt"`

	// the directory that contains the lora training files
	LoraDir string `json:"lora_dir"`

	// this is the directory that contains the files used for fine tuning
	// i.e. it's the user files that will be the input to a finetune session
	DatasetDir string `json:"dataset_dir"`
}

type RunnerTaskResponse struct {
	// the python code must submit these fields back to the runner api
	Type      WorkerTaskResponseType `json:"type"`
	SessionID string                 `json:"session_id"`
	Owner     string                 `json:"owner"`
	// which fields the python code decides to fill in here depends
	// on what the type of model it is
	Message  string   `json:"message,omitempty"`  // e.g. Prove pythagoras
	Progress int      `json:"progress,omitempty"` // e.g. 0-100
	Status   string   `json:"status,omitempty"`   // e.g. updating X
	Files    []string `json:"files,omitempty"`    // list of filepath paths
	LoraDir  string   `json:"lora_dir,omitempty"`
	Error    string   `json:"error,omitempty"`
}

// this is returned by the api server so that clients can see what
// config it's using e.g. filestore prefix
type ServerConfig struct {
	// used to prepend onto raw filestore paths to download files
	// the filestore path will have the user info in it - i.e.
	// it's a low level filestore path
	// if we are using an object storage thing - then this URL
	// can be the prefix to the bucket
	FilestorePrefix string `json:"filestore_prefix"`
}

type ModelInstanceJob struct {
	Created       time.Time `json:"created"`
	SessionID     string    `json:"session_id"`
	InteractionID string    `json:"interaction_id"`
}

type ModelInstanceState struct {
	ID               string      `json:"id"`
	ModelName        ModelName   `json:"model_name"`
	Mode             SessionMode `json:"mode"`
	LoraDir          string      `json:"lora_dir"`
	InitialSessionID string      `json:"initial_session_id"`
	// this is either the currently running session
	// or the queued session that will be run next but is currently downloading
	CurrentSession *Session            `json:"current_session"`
	JobHistory     []*ModelInstanceJob `json:"job_history"`
}

// the basic struct reported by a runner when it connects
// and keeps reporting it's status to the api server
// we expire these records after a certain amount of time
type RunnerState struct {
	ID      string    `json:"id"`
	Created time.Time `json:"created"`
	// the URL that the runner will POST to to get a task
	TotalMemory    uint64                `json:"total_memory"`
	FreeMemory     uint64                `json:"free_memory"`
	Labels         map[string]string     `json:"labels"`
	ModelInstances []*ModelInstanceState `json:"model_instances"`
}

type DashboardData struct {
	SessionQueue []*Session     `json:"session_queue"`
	Runners      []*RunnerState `json:"runners"`
}

type CreateSessionRequest struct {
	SessionID       string
	SessionMode     SessionMode
	SessionType     SessionType
	ParentSession   string
	ModelName       ModelName
	Owner           string
	OwnerType       OwnerType
	UserInteraction Interaction
}

type UpdateSessionRequest struct {
	SessionID       string
	UserInteraction Interaction
}
