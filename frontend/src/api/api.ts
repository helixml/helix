/* eslint-disable */
/* tslint:disable */
/*
 * ---------------------------------------------------------------
 * ## THIS FILE WAS GENERATED VIA SWAGGER-TYPESCRIPT-API        ##
 * ##                                                           ##
 * ## AUTHOR: acacode                                           ##
 * ## SOURCE: https://github.com/acacode/swagger-typescript-api ##
 * ---------------------------------------------------------------
 */

export interface GithubComHelixmlHelixApiPkgTypesConfig {
  rules?: TypesRule[];
}

export interface GithubComHelixmlHelixApiPkgTypesTool {
  config?: TypesToolConfig;
  description?: string;
  global?: boolean;
  id?: string;
  name?: string;
  /** E.g. As a restaurant expert, you provide personalized restaurant recommendations */
  system_prompt?: string;
  tool_type?: GithubComHelixmlHelixApiPkgTypesToolType;
}

export enum GithubComHelixmlHelixApiPkgTypesToolType {
  ToolTypeAPI = "api",
  ToolTypeGPTScript = "gptscript",
  ToolTypeZapier = "zapier",
}

export interface GithubComHelixmlHelixApiPkgTypesUsage {
  completion_tokens?: number;
  /** How long the request took in milliseconds */
  duration_ms?: number;
  prompt_tokens?: number;
  total_tokens?: number;
}

export interface GithubComSashabaranovGoOpenaiChatCompletionChoice {
  content_filter_results?: GithubComSashabaranovGoOpenaiContentFilterResults;
  /**
   * FinishReason
   * stop: API returned complete message,
   * or a message terminated by one of the stop sequences provided via the stop parameter
   * length: Incomplete model output due to max_tokens parameter or token limit
   * function_call: The model decided to call a function
   * content_filter: Omitted content due to a flag from our content filters
   * null: API response still in progress or incomplete
   */
  finish_reason?: GithubComSashabaranovGoOpenaiFinishReason;
  index?: number;
  logprobs?: GithubComSashabaranovGoOpenaiLogProbs;
  message?: GithubComSashabaranovGoOpenaiChatCompletionMessage;
}

export interface GithubComSashabaranovGoOpenaiChatCompletionMessage {
  content?: string;
  function_call?: GithubComSashabaranovGoOpenaiFunctionCall;
  multiContent?: GithubComSashabaranovGoOpenaiChatMessagePart[];
  /**
   * This property isn't in the official documentation, but it's in
   * the documentation for the official library for python:
   * - https://github.com/openai/openai-python/blob/main/chatml.md
   * - https://github.com/openai/openai-cookbook/blob/main/examples/How_to_count_tokens_with_tiktoken.ipynb
   */
  name?: string;
  refusal?: string;
  role?: string;
  /** For Role=tool prompts this should be set to the ID given in the assistant's prior request to call a tool. */
  tool_call_id?: string;
  /** For Role=assistant prompts this may be set to the tool calls generated by the model, such as function calls. */
  tool_calls?: GithubComSashabaranovGoOpenaiToolCall[];
}

export interface GithubComSashabaranovGoOpenaiChatCompletionRequest {
  frequency_penalty?: number;
  /** Deprecated: use ToolChoice instead. */
  function_call?: any;
  /** Deprecated: use Tools instead. */
  functions?: GithubComSashabaranovGoOpenaiFunctionDefinition[];
  /**
   * LogitBias is must be a token id string (specified by their token ID in the tokenizer), not a word string.
   * incorrect: `"logit_bias":{"You": 6}`, correct: `"logit_bias":{"1639": 6}`
   * refs: https://platform.openai.com/docs/api-reference/chat/create#chat/create-logit_bias
   */
  logit_bias?: Record<string, number>;
  /**
   * LogProbs indicates whether to return log probabilities of the output tokens or not.
   * If true, returns the log probabilities of each output token returned in the content of message.
   * This option is currently not available on the gpt-4-vision-preview model.
   */
  logprobs?: boolean;
  /**
   * MaxCompletionTokens An upper bound for the number of tokens that can be generated for a completion,
   * including visible output tokens and reasoning tokens https://platform.openai.com/docs/guides/reasoning
   */
  max_completion_tokens?: number;
  /**
   * MaxTokens The maximum number of tokens that can be generated in the chat completion.
   * This value can be used to control costs for text generated via API.
   * This value is now deprecated in favor of max_completion_tokens, and is not compatible with o1 series models.
   * refs: https://platform.openai.com/docs/api-reference/chat/create#chat-create-max_tokens
   */
  max_tokens?: number;
  messages?: GithubComSashabaranovGoOpenaiChatCompletionMessage[];
  /** Metadata to store with the completion. */
  metadata?: Record<string, string>;
  model?: string;
  n?: number;
  /** Disable the default behavior of parallel tool calls by setting it: false. */
  parallel_tool_calls?: any;
  presence_penalty?: number;
  /** Controls effort on reasoning for reasoning models. It can be set to "low", "medium", or "high". */
  reasoning_effort?: string;
  response_format?: GithubComSashabaranovGoOpenaiChatCompletionResponseFormat;
  seed?: number;
  stop?: string[];
  /**
   * Store can be set to true to store the output of this completion request for use in distillations and evals.
   * https://platform.openai.com/docs/api-reference/chat/create#chat-create-store
   */
  store?: boolean;
  stream?: boolean;
  /** Options for streaming response. Only set this when you set stream: true. */
  stream_options?: GithubComSashabaranovGoOpenaiStreamOptions;
  temperature?: number;
  /** This can be either a string or an ToolChoice object. */
  tool_choice?: any;
  tools?: GithubComSashabaranovGoOpenaiTool[];
  /**
   * TopLogProbs is an integer between 0 and 5 specifying the number of most likely tokens to return at each
   * token position, each with an associated log probability.
   * logprobs must be set to true if this parameter is used.
   */
  top_logprobs?: number;
  top_p?: number;
  user?: string;
}

export interface GithubComSashabaranovGoOpenaiChatCompletionResponse {
  choices?: GithubComSashabaranovGoOpenaiChatCompletionChoice[];
  created?: number;
  id?: string;
  model?: string;
  object?: string;
  prompt_filter_results?: OpenaiPromptFilterResult[];
  system_fingerprint?: string;
  usage?: GithubComSashabaranovGoOpenaiUsage;
}

export interface GithubComSashabaranovGoOpenaiChatCompletionResponseFormat {
  json_schema?: OpenaiChatCompletionResponseFormatJSONSchema;
  type?: GithubComSashabaranovGoOpenaiChatCompletionResponseFormatType;
}

export enum GithubComSashabaranovGoOpenaiChatCompletionResponseFormatType {
  ChatCompletionResponseFormatTypeJSONObject = "json_object",
  ChatCompletionResponseFormatTypeJSONSchema = "json_schema",
  ChatCompletionResponseFormatTypeText = "text",
}

export interface GithubComSashabaranovGoOpenaiChatMessageImageURL {
  detail?: GithubComSashabaranovGoOpenaiImageURLDetail;
  url?: string;
}

export interface GithubComSashabaranovGoOpenaiChatMessagePart {
  image_url?: GithubComSashabaranovGoOpenaiChatMessageImageURL;
  text?: string;
  type?: GithubComSashabaranovGoOpenaiChatMessagePartType;
}

export enum GithubComSashabaranovGoOpenaiChatMessagePartType {
  ChatMessagePartTypeText = "text",
  ChatMessagePartTypeImageURL = "image_url",
}

export interface GithubComSashabaranovGoOpenaiContentFilterResults {
  hate?: GithubComSashabaranovGoOpenaiHate;
  jailbreak?: OpenaiJailBreak;
  profanity?: OpenaiProfanity;
  self_harm?: GithubComSashabaranovGoOpenaiSelfHarm;
  sexual?: GithubComSashabaranovGoOpenaiSexual;
  violence?: GithubComSashabaranovGoOpenaiViolence;
}

export enum GithubComSashabaranovGoOpenaiFinishReason {
  FinishReasonStop = "stop",
  FinishReasonLength = "length",
  FinishReasonFunctionCall = "function_call",
  FinishReasonToolCalls = "tool_calls",
  FinishReasonContentFilter = "content_filter",
  FinishReasonNull = "null",
}

export interface GithubComSashabaranovGoOpenaiFunctionCall {
  /** call function with arguments in JSON format */
  arguments?: string;
  name?: string;
}

export interface GithubComSashabaranovGoOpenaiFunctionDefinition {
  description?: string;
  name?: string;
  /**
   * Parameters is an object describing the function.
   * You can pass json.RawMessage to describe the schema,
   * or you can pass in a struct which serializes to the proper JSON schema.
   * The jsonschema package is provided for convenience, but you should
   * consider another specialized library if you require more complex schemas.
   */
  parameters?: any;
  strict?: boolean;
}

export interface GithubComSashabaranovGoOpenaiHate {
  filtered?: boolean;
  severity?: string;
}

export enum GithubComSashabaranovGoOpenaiImageURLDetail {
  ImageURLDetailHigh = "high",
  ImageURLDetailLow = "low",
  ImageURLDetailAuto = "auto",
}

export interface GithubComSashabaranovGoOpenaiLogProb {
  /** Omitting the field if it is null */
  bytes?: number[];
  logprob?: number;
  token?: string;
  /**
   * TopLogProbs is a list of the most likely tokens and their log probability, at this token position.
   * In rare cases, there may be fewer than the number of requested top_logprobs returned.
   */
  top_logprobs?: GithubComSashabaranovGoOpenaiTopLogProbs[];
}

export interface GithubComSashabaranovGoOpenaiLogProbs {
  /** Content is a list of message content tokens with log probability information. */
  content?: GithubComSashabaranovGoOpenaiLogProb[];
}

export interface GithubComSashabaranovGoOpenaiSelfHarm {
  filtered?: boolean;
  severity?: string;
}

export interface GithubComSashabaranovGoOpenaiSexual {
  filtered?: boolean;
  severity?: string;
}

export interface GithubComSashabaranovGoOpenaiStreamOptions {
  /**
   * If set, an additional chunk will be streamed before the data: [DONE] message.
   * The usage field on this chunk shows the token usage statistics for the entire request,
   * and the choices field will always be an empty array.
   * All other chunks will also include a usage field, but with a null value.
   */
  include_usage?: boolean;
}

export interface GithubComSashabaranovGoOpenaiTool {
  function?: GithubComSashabaranovGoOpenaiFunctionDefinition;
  type?: GithubComSashabaranovGoOpenaiToolType;
}

export interface GithubComSashabaranovGoOpenaiToolCall {
  function?: GithubComSashabaranovGoOpenaiFunctionCall;
  id?: string;
  /** Index is not nil only in chat completion chunk object */
  index?: number;
  type?: GithubComSashabaranovGoOpenaiToolType;
}

export enum GithubComSashabaranovGoOpenaiToolType {
  ToolTypeFunction = "function",
}

export interface GithubComSashabaranovGoOpenaiTopLogProbs {
  bytes?: number[];
  logprob?: number;
  token?: string;
}

export interface GithubComSashabaranovGoOpenaiUsage {
  completion_tokens?: number;
  completion_tokens_details?: OpenaiCompletionTokensDetails;
  prompt_tokens?: number;
  prompt_tokens_details?: OpenaiPromptTokensDetails;
  total_tokens?: number;
}

export interface GithubComSashabaranovGoOpenaiViolence {
  filtered?: boolean;
  severity?: string;
}

export interface GormDeletedAt {
  time?: string;
  /** Valid is true if Time is not NULL */
  valid?: boolean;
}

export interface OpenaiChatCompletionResponseFormatJSONSchema {
  description?: string;
  name?: string;
  schema?: any;
  strict?: boolean;
}

export interface OpenaiCompletionTokensDetails {
  audio_tokens?: number;
  reasoning_tokens?: number;
}

export interface OpenaiEmbedding {
  embedding?: number[];
  index?: number;
  object?: string;
}

export enum OpenaiEmbeddingEncodingFormat {
  EmbeddingEncodingFormatFloat = "float",
  EmbeddingEncodingFormatBase64 = "base64",
}

export enum OpenaiEmbeddingModel {
  AdaSimilarity = "text-similarity-ada-001",
  BabbageSimilarity = "text-similarity-babbage-001",
  CurieSimilarity = "text-similarity-curie-001",
  DavinciSimilarity = "text-similarity-davinci-001",
  AdaSearchDocument = "text-search-ada-doc-001",
  AdaSearchQuery = "text-search-ada-query-001",
  BabbageSearchDocument = "text-search-babbage-doc-001",
  BabbageSearchQuery = "text-search-babbage-query-001",
  CurieSearchDocument = "text-search-curie-doc-001",
  CurieSearchQuery = "text-search-curie-query-001",
  DavinciSearchDocument = "text-search-davinci-doc-001",
  DavinciSearchQuery = "text-search-davinci-query-001",
  AdaCodeSearchCode = "code-search-ada-code-001",
  AdaCodeSearchText = "code-search-ada-text-001",
  BabbageCodeSearchCode = "code-search-babbage-code-001",
  BabbageCodeSearchText = "code-search-babbage-text-001",
  AdaEmbeddingV2 = "text-embedding-ada-002",
  SmallEmbedding3 = "text-embedding-3-small",
  LargeEmbedding3 = "text-embedding-3-large",
}

export interface OpenaiEmbeddingRequest {
  /**
   * Dimensions The number of dimensions the resulting output embeddings should have.
   * Only supported in text-embedding-3 and later models.
   */
  dimensions?: number;
  encoding_format?: OpenaiEmbeddingEncodingFormat;
  input?: any;
  model?: OpenaiEmbeddingModel;
  user?: string;
}

export interface OpenaiEmbeddingResponse {
  data?: OpenaiEmbedding[];
  model?: OpenaiEmbeddingModel;
  object?: string;
  usage?: GithubComSashabaranovGoOpenaiUsage;
}

export interface OpenaiJailBreak {
  detected?: boolean;
  filtered?: boolean;
}

export interface OpenaiProfanity {
  detected?: boolean;
  filtered?: boolean;
}

export interface OpenaiPromptFilterResult {
  content_filter_results?: GithubComSashabaranovGoOpenaiContentFilterResults;
  index?: number;
}

export interface OpenaiPromptTokensDetails {
  audio_tokens?: number;
  cached_tokens?: number;
}

export interface ServerLicenseKeyRequest {
  license_key?: string;
}

export interface SystemHTTPError {
  message?: string;
  statusCode?: number;
}

export interface TypesAccessGrant {
  created_at?: string;
  id?: string;
  /** If granted to an organization */
  organization_id?: string;
  /** App ID, Knowledge ID, etc */
  resource_id?: string;
  roles?: TypesRole[];
  /** If granted to a team */
  team_id?: string;
  updated_at?: string;
  /** Populated by the server if UserID is set */
  user?: TypesUser;
  /** If granted to a user */
  user_id?: string;
}

export enum TypesAction {
  ActionGet = "Get",
  ActionList = "List",
  ActionDelete = "Delete",
  ActionUpdate = "Update",
  ActionCreate = "Create",
  ActionUseAction = "UseAction",
}

export interface TypesAddOrganizationMemberRequest {
  role?: TypesOrganizationRole;
  /** Either user ID or user email */
  user_reference?: string;
}

export interface TypesAddTeamMemberRequest {
  /** Either user ID or user email */
  user_reference?: string;
}

export interface TypesAggregatedUsageMetric {
  completion_tokens?: number;
  /** ID    string    `json:"id" gorm:"primaryKey"` */
  date?: string;
  latency_ms?: number;
  prompt_tokens?: number;
  request_size_bytes?: number;
  response_size_bytes?: number;
  total_tokens?: number;
}

export interface TypesApp {
  app_source?: TypesAppSource;
  config?: TypesAppConfig;
  created?: string;
  global?: boolean;
  id?: string;
  organization_id?: string;
  /** uuid of owner entity */
  owner?: string;
  /** e.g. user, system, org */
  owner_type?: TypesOwnerType;
  updated?: string;
  /** Owner user struct, populated by the server for organization views */
  user?: TypesUser;
}

export interface TypesAppConfig {
  allowed_domains?: string[];
  github?: TypesAppGithubConfig;
  helix?: TypesAppHelixConfig;
  secrets?: Record<string, string>;
}

export interface TypesAppGithubConfig {
  hash?: string;
  key_pair?: TypesKeyPair;
  last_update?: TypesAppGithubConfigUpdate;
  repo?: string;
  webhook_secret?: string;
}

export interface TypesAppGithubConfigUpdate {
  error?: string;
  hash?: string;
  updated?: string;
}

export interface TypesAppHelixConfig {
  assistants?: TypesAssistantConfig[];
  avatar?: string;
  description?: string;
  external_url?: string;
  image?: string;
  name?: string;
  triggers?: TypesTrigger[];
}

export enum TypesAppSource {
  AppSourceHelix = "helix",
  AppSourceGithub = "github",
}

export interface TypesAssistantAPI {
  description?: string;
  headers?: Record<string, string>;
  name?: string;
  /** OAuth configuration */
  oauth_provider?: string;
  /** Required OAuth scopes for this API */
  oauth_scopes?: string[];
  query?: Record<string, string>;
  request_prep_template?: string;
  response_error_template?: string;
  response_success_template?: string;
  schema?: string;
  system_prompt?: string;
  url?: string;
}

export interface TypesAssistantConfig {
  /** AgentMode triggers the use of the agent loop */
  agent_mode?: boolean;
  apis?: TypesAssistantAPI[];
  avatar?: string;
  /**
   * ContextLimit - the number of messages to include in the context for the AI assistant.
   * When set to 1, the AI assistant will only see and remember the most recent message.
   */
  context_limit?: number;
  description?: string;
  /**
   * How much to penalize new tokens based on their frequency in the text so far.
   * Increases the model's likelihood to talk about new topics
   * 0 - balanced
   * 2 - less repetitive
   */
  frequency_penalty?: number;
  generation_model?: string;
  gptscripts?: TypesAssistantGPTScript[];
  id?: string;
  image?: string;
  /** Defaults to 4 */
  is_actionable_history_length?: number;
  is_actionable_template?: string;
  knowledge?: TypesAssistantKnowledge[];
  lora_id?: string;
  /** The maximum number of tokens to generate before stopping. */
  max_tokens?: number;
  model?: string;
  name?: string;
  /**
   * How much to penalize new tokens based on whether they appear in the text so far.
   * Increases the model's likelihood to talk about new topics
   * 0 - balanced
   * 2 - open minded
   */
  presence_penalty?: number;
  provider?: string;
  rag_source_id?: string;
  /** Controls effort on reasoning for reasoning models. It can be set to "low", "medium", or "high". */
  reasoning_effort?: string;
  reasoning_model?: string;
  small_generation_model?: string;
  small_reasoning_model?: string;
  system_prompt?: string;
  /**
   * Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
   * 0.01 - precise
   * 1 - neutral
   * 2 - creative
   */
  temperature?: number;
  tests?: {
    name?: string;
    steps?: TypesTestStep[];
  }[];
  tools?: GithubComHelixmlHelixApiPkgTypesTool[];
  /**
   * An alternative to sampling with temperature, called nucleus sampling,
   * where the model considers the results of the tokens with top_p probability mass.
   * So 0.1 means only the tokens comprising the top 10% probability mass are considered.
   * 0 - balanced
   * 2 - more creative
   */
  top_p?: number;
  zapier?: TypesAssistantZapier[];
}

export interface TypesAssistantGPTScript {
  content?: string;
  /** When to use this tool (required) */
  description?: string;
  file?: string;
  name?: string;
}

export interface TypesAssistantKnowledge {
  /**
   * Description of the knowledge, will be used in the prompt
   * to explain the knowledge to the assistant
   */
  description?: string;
  /** Name of the knowledge, will be unique within the Helix app */
  name?: string;
  /**
   * RAGSettings defines the settings for the RAG system, how
   * chunking is configured and where the index/query service is
   * hosted.
   */
  rag_settings?: TypesRAGSettings;
  /**
   * RefreshEnabled defines if the knowledge should be refreshed periodically
   * or on events. For example a Google Drive knowledge can be refreshed
   * every 24 hours.
   */
  refresh_enabled?: boolean;
  /**
   * RefreshSchedule defines the schedule for refreshing the knowledge.
   * It can be specified in cron format or as a duration for example '@every 2h'
   * or 'every 5m' or '0 0 * * *' for daily at midnight.
   */
  refresh_schedule?: string;
  /**
   * Source defines where the raw data is fetched from. It can be
   * directly uploaded files, S3, GCS, Google Drive, Gmail, etc.
   */
  source?: TypesKnowledgeSource;
}

export interface TypesAssistantZapier {
  api_key?: string;
  description?: string;
  max_iterations?: number;
  model?: string;
  name?: string;
}

export interface TypesAuthenticatedResponse {
  authenticated?: boolean;
}

export interface TypesChoice {
  delta?: TypesOpenAIMessage;
  finish_reason?: string;
  index?: number;
  message?: TypesOpenAIMessage;
  text?: string;
}

export interface TypesContextMenuAction {
  /** Forms the grouping in the UI */
  action_label?: string;
  /** The label that will be shown in the UI */
  label?: string;
  /** The value written to the text area when the action is selected */
  value?: string;
}

export interface TypesContextMenuResponse {
  data?: TypesContextMenuAction[];
}

export interface TypesCrawledSources {
  urls?: TypesCrawledURL[];
}

export interface TypesCrawledURL {
  document_id?: string;
  duration_ms?: number;
  message?: string;
  status_code?: number;
  url?: string;
}

export interface TypesCreateAccessGrantRequest {
  /** Role names */
  roles?: string[];
  /** Team ID */
  team_id?: string;
  /** User ID or email */
  user_reference?: string;
}

export interface TypesCreateTeamRequest {
  name?: string;
  organization_id?: string;
}

export enum TypesCreatorType {
  CreatorTypeSystem = "system",
  CreatorTypeAssistant = "assistant",
  CreatorTypeUser = "user",
  CreatorTypeTool = "tool",
}

export interface TypesCronTrigger {
  input?: string;
  schedule?: string;
}

export interface TypesDashboardData {
  queue?: TypesWorkloadSummary[];
  runners?: TypesDashboardRunner[];
}

export interface TypesDashboardRunner {
  allocated_memory?: number;
  created?: string;
  free_memory?: number;
  id?: string;
  labels?: Record<string, string>;
  models?: TypesRunnerModelStatus[];
  slots?: TypesRunnerSlot[];
  total_memory?: number;
  updated?: string;
  used_memory?: number;
  version?: string;
}

export interface TypesDataPrepChunk {
  error?: string;
  index?: number;
  prompt_name?: string;
  question_count?: number;
}

export interface TypesDiscordTrigger {
  server_name?: string;
}

export enum TypesEffect {
  EffectAllow = "allow",
  EffectDeny = "deny",
}

export interface TypesFirecrawl {
  api_key?: string;
  api_url?: string;
}

export interface TypesGptScriptRequest {
  file_path?: string;
  input?: string;
}

export interface TypesGptScriptResponse {
  error?: string;
  output?: string;
  retries?: number;
}

export interface TypesInteraction {
  completed?: string;
  /** Original content received from the API. This will include the Message and any images. */
  content?: TypesMessageContent;
  created?: string;
  /** e.g. User */
  creator?: TypesCreatorType;
  data_prep_chunks?: Record<string, TypesDataPrepChunk[]>;
  /** If true, the data prep is limited to a certain number of chunks due to quotas */
  data_prep_limit?: number;
  /** If true, the data prep is limited to a certain number of chunks due to quotas */
  data_prep_limited?: boolean;
  data_prep_stage?: TypesTextDataPrepStage;
  data_prep_total_chunks?: number;
  /** if this is defined, the UI will always display it instead of the message (so we can augment the internal prompt with RAG context) */
  display_message?: string;
  error?: string;
  /** list of filepath paths */
  files?: string[];
  /** if true, the message has finished being written to, and is ready for a response (e.g. from the other participant) */
  finished?: boolean;
  id?: string;
  /** we hoist this from files so a single interaction knows that it "Created a finetune file" */
  lora_dir?: string;
  /** TODO: remove and keep only content */
  message?: string;
  /** different modes and models can put values here - for example, the image fine tuning will keep labels here to display in the frontend */
  metadata?: Record<string, string>;
  /**
   * this let's us know if this interaction is part of the fine tuning process
   * or if it's a chat interaction that the user is using to interact with the model
   * once it's been fine-tuned
   * for fine-tune models, we can filter out inference interactions
   * to get down to what actually matters
   */
  mode?: TypesSessionMode;
  /** e.g. 0-100 */
  progress?: number;
  rag_results?: TypesSessionRAGResult[];
  /** e.g. json */
  response_format?: TypesResponseFormat;
  /** the ID of the runner that processed this interaction */
  runner?: string;
  scheduled?: string;
  state?: TypesInteractionState;
  status?: string;
  /** For Role=tool prompts this should be set to the ID given in the assistant's prior request to call a tool. */
  tool_call_id?: string;
  /** For Role=assistant prompts this may be set to the tool calls generated by the model, such as function calls. */
  tool_calls?: GithubComSashabaranovGoOpenaiToolCall[];
  /** This can be either a string or an ToolChoice object. */
  tool_choice?: any;
  /** Model function calling, not to be mistaken with Helix tools */
  tools?: GithubComSashabaranovGoOpenaiTool[];
  updated?: string;
  usage?: GithubComHelixmlHelixApiPkgTypesUsage;
}

export enum TypesInteractionState {
  InteractionStateNone = "",
  InteractionStateWaiting = "waiting",
  InteractionStateEditing = "editing",
  InteractionStateComplete = "complete",
  InteractionStateError = "error",
}

export interface TypesItem {
  b64_json?: string;
  embedding?: number[];
  index?: number;
  object?: string;
  /** Images */
  url?: string;
}

export interface TypesKeyPair {
  privateKey?: string;
  publicKey?: string;
  type?: string;
}

export interface TypesKnowledge {
  /** AppID through which the knowledge was created */
  app_id?: string;
  /** URLs crawled in the last run (should match last knowledge version) */
  crawled_sources?: TypesCrawledSources;
  created?: string;
  /**
   * Description of the knowledge, will be used in the prompt
   * to explain the knowledge to the assistant
   */
  description?: string;
  id?: string;
  /** Set if something wrong happens */
  message?: string;
  name?: string;
  /** Populated by the cron job controller */
  next_run?: string;
  /** User ID */
  owner?: string;
  /** e.g. user, system, org */
  owner_type?: TypesOwnerType;
  /** Ephemeral state from knowledge controller */
  progress?: TypesKnowledgeProgress;
  rag_settings?: TypesRAGSettings;
  /**
   * RefreshEnabled defines if the knowledge should be refreshed periodically
   * or on events. For example a Google Drive knowledge can be refreshed
   * every 24 hours.
   */
  refresh_enabled?: boolean;
  /**
   * RefreshSchedule defines the schedule for refreshing the knowledge.
   * It can be specified in cron format or as a duration for example '@every 2h'
   * or 'every 5m' or '0 0 * * *' for daily at midnight.
   */
  refresh_schedule?: string;
  /** Size of the knowledge in bytes */
  size?: number;
  /**
   * Source defines where the raw data is fetched from. It can be
   * directly uploaded files, S3, GCS, Google Drive, Gmail, etc.
   */
  source?: TypesKnowledgeSource;
  state?: TypesKnowledgeState;
  updated?: string;
  /**
   * Version of the knowledge, will be used to separate different versions
   * of the same knowledge when updating it. Format is
   * YYYY-MM-DD-HH-MM-SS.
   */
  version?: string;
  versions?: TypesKnowledgeVersion[];
}

export interface TypesKnowledgeProgress {
  elapsed_seconds?: number;
  message?: string;
  progress?: number;
  started_at?: string;
  step?: string;
}

export interface TypesKnowledgeSearchResult {
  duration_ms?: number;
  knowledge?: TypesKnowledge;
  results?: TypesSessionRAGResult[];
}

export interface TypesKnowledgeSource {
  filestore?: TypesKnowledgeSourceHelixFilestore;
  gcs?: TypesKnowledgeSourceGCS;
  s3?: TypesKnowledgeSourceS3;
  text?: string;
  web?: TypesKnowledgeSourceWeb;
}

export interface TypesKnowledgeSourceGCS {
  bucket?: string;
  path?: string;
}

export interface TypesKnowledgeSourceHelixFilestore {
  path?: string;
}

export interface TypesKnowledgeSourceS3 {
  bucket?: string;
  path?: string;
}

export interface TypesKnowledgeSourceWeb {
  auth?: TypesKnowledgeSourceWebAuth;
  /** Additional options for the crawler */
  crawler?: TypesWebsiteCrawler;
  excludes?: string[];
  urls?: string[];
}

export interface TypesKnowledgeSourceWebAuth {
  password?: string;
  username?: string;
}

export enum TypesKnowledgeState {
  KnowledgeStatePreparing = "preparing",
  KnowledgeStatePending = "pending",
  KnowledgeStateIndexing = "indexing",
  KnowledgeStateReady = "ready",
  KnowledgeStateError = "error",
}

export interface TypesKnowledgeVersion {
  crawled_sources?: TypesCrawledSources;
  created?: string;
  /** Model used to embed the knowledge */
  embeddings_model?: string;
  id?: string;
  knowledge_id?: string;
  /** Set if something wrong happens */
  message?: string;
  provider?: string;
  size?: number;
  state?: TypesKnowledgeState;
  updated?: string;
  version?: string;
}

export interface TypesLLMCall {
  app_id?: string;
  completionTokens?: number;
  created?: string;
  duration_ms?: number;
  id?: string;
  interaction_id?: string;
  model?: string;
  original_request?: number[];
  promptTokens?: number;
  provider?: string;
  request?: number[];
  response?: number[];
  session_id?: string;
  step?: TypesLLMCallStep;
  totalTokens?: number;
  updated?: string;
  user_id?: string;
}

export enum TypesLLMCallStep {
  LLMCallStepDefault = "default",
  LLMCallStepIsActionable = "is_actionable",
  LLMCallStepPrepareAPIRequest = "prepare_api_request",
  LLMCallStepInterpretResponse = "interpret_response",
  LLMCallStepGenerateTitle = "generate_title",
}

export interface TypesLoginRequest {
  redirect_uri?: string;
}

export interface TypesMessage {
  content?: TypesMessageContent;
  created_at?: string;
  /** Interaction ID */
  id?: string;
  role?: TypesCreatorType;
  state?: TypesInteractionState;
  updated_at?: string;
}

export interface TypesMessageContent {
  /** text, image_url, multimodal_text */
  content_type?: TypesMessageContentType;
  /**
   * Parts is a list of strings or objects. For example for text, it's a list of strings, for
   * multi-modal it can be an object:
   * "parts": [
   * 		{
   * 				"content_type": "image_asset_pointer",
   * 				"asset_pointer": "file-service://file-28uHss2LgJ8HUEEVAnXa70Tg",
   * 				"size_bytes": 185427,
   * 				"width": 2048,
   * 				"height": 1020,
   * 				"fovea": null,
   * 				"metadata": null
   * 		},
   * 		"what is in the image?"
   * ]
   */
  parts?: any[];
}

export enum TypesMessageContentType {
  MessageContentTypeText = "text",
}

export interface TypesModel {
  /** Whether to automatically pull the model if missing in the runner */
  auto_pull?: boolean;
  context_length?: number;
  created?: string;
  description?: string;
  enabled?: boolean;
  hide?: boolean;
  /** for example 'phi3.5:3.8b-mini-instruct-q8_0' */
  id?: string;
  /** in bytes, required */
  memory?: number;
  name?: string;
  runtime?: TypesRuntime;
  type?: TypesModelType;
  updated?: string;
}

export enum TypesModelType {
  ModelTypeChat = "chat",
  ModelTypeImage = "image",
  ModelTypeEmbed = "embed",
}

export interface TypesOpenAIMessage {
  /** The message content */
  content?: string;
  /** The message role */
  role?: string;
  /** For Role=tool prompts this should be set to the ID given in the assistant's prior request to call a tool. */
  tool_call_id?: string;
  /** For Role=assistant prompts this may be set to the tool calls generated by the model, such as function calls. */
  tool_calls?: GithubComSashabaranovGoOpenaiToolCall[];
}

export interface TypesOpenAIModel {
  context_length?: number;
  created?: number;
  description?: string;
  enabled?: boolean;
  hide?: boolean;
  id?: string;
  name?: string;
  object?: string;
  owned_by?: string;
  parent?: string;
  permission?: TypesOpenAIPermission[];
  root?: string;
  type?: string;
}

export interface TypesOpenAIModelsList {
  data?: TypesOpenAIModel[];
}

export interface TypesOpenAIPermission {
  allow_create_engine?: boolean;
  allow_fine_tuning?: boolean;
  allow_logprobs?: boolean;
  allow_sampling?: boolean;
  allow_search_indices?: boolean;
  allow_view?: boolean;
  created?: number;
  group?: any;
  id?: string;
  is_blocking?: boolean;
  object?: string;
  organization?: string;
}

export interface TypesOpenAIResponse {
  choices?: TypesChoice[];
  created?: number;
  data?: TypesItem[];
  id?: string;
  model?: string;
  object?: string;
  usage?: TypesOpenAIUsage;
}

export interface TypesOpenAIUsage {
  completion_tokens?: number;
  prompt_tokens?: number;
  total_tokens?: number;
}

export interface TypesOrganization {
  created_at?: string;
  deleted_at?: GormDeletedAt;
  display_name?: string;
  id?: string;
  /** Memberships in the organization */
  memberships?: TypesOrganizationMembership[];
  name?: string;
  /** Who created the org */
  owner?: string;
  /** Roles in the organization */
  roles?: TypesRole[];
  /** Teams in the organization */
  teams?: TypesTeam[];
  updated_at?: string;
}

export interface TypesOrganizationMembership {
  created_at?: string;
  organization_id?: string;
  /** Role - the role of the user in the organization (owner or member) */
  role?: TypesOrganizationRole;
  updated_at?: string;
  user?: TypesUser;
  /** composite key */
  user_id?: string;
}

export enum TypesOrganizationRole {
  OrganizationRoleOwner = "owner",
  OrganizationRoleMember = "member",
}

export enum TypesOwnerType {
  OwnerTypeUser = "user",
  OwnerTypeRunner = "runner",
  OwnerTypeSystem = "system",
  OwnerTypeSocket = "socket",
}

export interface TypesPaginatedLLMCalls {
  calls?: TypesLLMCall[];
  page?: number;
  pageSize?: number;
  totalCount?: number;
  totalPages?: number;
}

export enum TypesProvider {
  ProviderOpenAI = "openai",
  ProviderTogetherAI = "togetherai",
  ProviderHelix = "helix",
  ProviderVLLM = "vllm",
}

export interface TypesProviderEndpoint {
  api_key?: string;
  /** Must be mounted to the container */
  api_key_file?: string;
  available_models?: TypesOpenAIModel[];
  base_url?: string;
  created?: string;
  /** Set from environment variable */
  default?: boolean;
  description?: string;
  /** global, user (TODO: orgs, teams) */
  endpoint_type?: TypesProviderEndpointType;
  error?: string;
  id?: string;
  /** Optional */
  models?: string[];
  name?: string;
  owner?: string;
  /** user, system, org */
  owner_type?: TypesOwnerType;
  /** If we can't fetch models */
  status?: TypesProviderEndpointStatus;
  updated?: string;
}

export enum TypesProviderEndpointStatus {
  ProviderEndpointStatusOK = "ok",
  ProviderEndpointStatusError = "error",
  ProviderEndpointStatusLoading = "loading",
  ProviderEndpointStatusDisabled = "disabled",
}

export enum TypesProviderEndpointType {
  ProviderEndpointTypeGlobal = "global",
  ProviderEndpointTypeUser = "user",
}

export interface TypesRAGSettings {
  /** the amount of overlap between chunks - will default to 32 bytes */
  chunk_overflow?: number;
  /** the size of each text chunk - will default to 2000 bytes */
  chunk_size?: number;
  /** the URL of the delete endpoint (defaults to Helix RAG_DELETE_URL env var) */
  delete_url?: string;
  /** if true, we will not chunk the text and send the entire file to the RAG indexing endpoint */
  disable_chunking?: boolean;
  /** if true, we will not download the file and send the URL to the RAG indexing endpoint */
  disable_downloading?: boolean;
  /** this is one of l2, inner_product or cosine - will default to cosine */
  distance_function?: string;
  /** if true, we will use the vision pipeline -- Future - might want to specify different pipelines */
  enable_vision?: boolean;
  /** RAG endpoint configuration if used with a custom RAG service */
  index_url?: string;
  /** the prompt template to use for the RAG query */
  prompt_template?: string;
  /** the URL of the query endpoint (defaults to Helix RAG_QUERY_URL env var) */
  query_url?: string;
  /** this is the max number of results to return - will default to 3 */
  results_count?: number;
  /** Markdown if empty or 'text' */
  text_splitter?: TypesTextSplitterType;
  /** this is the threshold for a "good" answer - will default to 0.2 */
  threshold?: number;
  typesense?: {
    api_key?: string;
    collection?: string;
    url?: string;
  };
}

export enum TypesResource {
  ResourceTeam = "Team",
  ResourceOrganization = "Organization",
  ResourceRole = "Role",
  ResourceMembership = "Membership",
  ResourceMembershipRoleBinding = "MembershipRoleBinding",
  ResourceApplication = "Application",
  ResourceAccessGrants = "AccessGrants",
  ResourceKnowledge = "Knowledge",
  ResourceUser = "User",
  ResourceAny = "*",
  ResourceTypeDataset = "Dataset",
}

export interface TypesResponseFormat {
  schema?: OpenaiChatCompletionResponseFormatJSONSchema;
  type?: TypesResponseFormatType;
}

export enum TypesResponseFormatType {
  ResponseFormatTypeJSONObject = "json_object",
  ResponseFormatTypeText = "text",
}

export interface TypesRole {
  config?: GithubComHelixmlHelixApiPkgTypesConfig;
  created_at?: string;
  description?: string;
  id?: string;
  name?: string;
  organization_id?: string;
  updated_at?: string;
}

export interface TypesRule {
  actions?: TypesAction[];
  effect?: TypesEffect;
  resource?: TypesResource[];
}

export interface TypesRunAPIActionRequest {
  action?: string;
  parameters?: Record<string, any>;
}

export interface TypesRunAPIActionResponse {
  error?: string;
  /** Raw response from the API */
  response?: string;
}

export interface TypesRunnerModelStatus {
  download_in_progress?: boolean;
  download_percent?: number;
  error?: string;
  model_id?: string;
  runtime?: TypesRuntime;
}

export interface TypesRunnerSlot {
  active?: boolean;
  /** Context length used for the model, if specified */
  context_length?: number;
  id?: string;
  model?: string;
  ready?: boolean;
  runtime?: TypesRuntime;
  /** Runtime-specific arguments */
  runtime_args?: Record<string, any>;
  status?: string;
  version?: string;
}

export enum TypesRuntime {
  RuntimeOllama = "ollama",
  RuntimeDiffusers = "diffusers",
  RuntimeAxolotl = "axolotl",
  RuntimeVLLM = "vllm",
}

export interface TypesSecret {
  /** optional, if set, the secret will be available to the specified app */
  app_id?: string;
  created?: string;
  id?: string;
  name?: string;
  owner?: string;
  ownerType?: TypesOwnerType;
  updated?: string;
  value?: number[];
}

export interface TypesSession {
  /** named config for backward compat */
  config?: TypesSessionMetadata;
  created?: string;
  id?: string;
  /**
   * for now we just whack the entire history of the interaction in here, json
   * style
   */
  interactions?: TypesInteraction[];
  /**
   * if type == finetune, we record a filestore path to e.g. lora file here
   * currently the only place you can do inference on a finetune is within the
   * session where the finetune was generated
   */
  lora_dir?: string;
  /** e.g. inference, finetune */
  mode?: TypesSessionMode;
  model_name?: string;
  /**
   * name that goes in the UI - ideally autogenerated by AI but for now can be
   * named manually
   */
  name?: string;
  /** the organization this session belongs to, if any */
  organization_id?: string;
  /** uuid of owner entity */
  owner?: string;
  /** e.g. user, system, org */
  owner_type?: TypesOwnerType;
  /** the app this session was spawned from */
  parent_app?: string;
  parent_session?: string;
  /**
   * huggingface model name e.g. mistralai/Mistral-7B-Instruct-v0.1 or
   * stabilityai/stable-diffusion-xl-base-1.0
   */
  provider?: string;
  /** e.g. text, image */
  type?: TypesSessionType;
  updated?: string;
}

export interface TypesSessionChatRequest {
  /** Assign the session settings from the specified app */
  app_id?: string;
  /** Which assistant are we speaking to? */
  assistant_id?: string;
  lora_dir?: string;
  /** the fine tuned data entity we produced from this session */
  lora_id?: string;
  /** Initial messages */
  messages?: TypesMessage[];
  /** The model to use */
  model?: string;
  /** The organization this session belongs to, if any */
  organization_id?: string;
  /** The provider to use */
  provider?: TypesProvider;
  rag_source_id?: string;
  /** If true, we will regenerate the response for the last message */
  regenerate?: boolean;
  /** If empty, we will start a new session */
  session_id?: string;
  /** If true, we will stream the response */
  stream?: boolean;
  /** System message, only applicable when starting a new session */
  system?: string;
  /** Available tools to use in the session */
  tools?: string[];
  /** e.g. text, image */
  type?: TypesSessionType;
}

export interface TypesSessionLearnRequest {
  /** FINE-TUNE MODE ONLY */
  data_entity_id?: string;
  /** When doing RAG, allow the resulting inference session model to be specified */
  default_rag_model?: string;
  /** The organization this session belongs to, if any */
  organization_id?: string;
  /**
   * Do we want to create a RAG data entity from this session?
   * You must provide a data entity ID for the uploaded documents if yes
   */
  rag_enabled?: boolean;
  /** The settings we use for the RAG source */
  rag_settings?: TypesRAGSettings;
  /**
   * Do we want to create a lora output from this session?
   * You must provide a data entity ID for the uploaded documents if yes
   */
  text_finetune_enabled?: boolean;
  /** e.g. text, image */
  type?: TypesSessionType;
}

export interface TypesSessionMetadata {
  active_tools?: string[];
  /** Passing through user defined app params */
  app_query_params?: Record<string, string>;
  /** which assistant are we talking to? */
  assistant_id?: string;
  avatar?: string;
  document_group_id?: string;
  document_ids?: Record<string, string>;
  eval_automatic_reason?: string;
  eval_automatic_score?: string;
  eval_manual_reason?: string;
  eval_manual_score?: string;
  eval_original_user_prompts?: string[];
  /**
   * Evals are cool. Scores are strings of floats so we can distinguish ""
   * (not rated) from "0.0"
   */
  eval_run_id?: string;
  eval_user_reason?: string;
  eval_user_score?: string;
  /** the fine tuned data entity we produced from this session */
  finetune_data_entity_id?: string;
  helix_version?: string;
  manually_review_questions?: boolean;
  origin?: TypesSessionOrigin;
  original_mode?: TypesSessionMode;
  priority?: boolean;
  /**
   * these settings control which features of a session we want to use
   * even if we have a Lora file and RAG indexed prepared
   * we might choose to not use them (this will help our eval framework know what works the best)
   * we well as activate RAG - we also get to control some properties, e.g. which distance function to use,
   * and what the threshold for a "good" answer is
   */
  rag_enabled?: boolean;
  rag_settings?: TypesRAGSettings;
  /** the RAG source data entity we produced from this session */
  rag_source_data_entity_id?: string;
  session_rag_results?: TypesSessionRAGResult[];
  stream?: boolean;
  system_prompt?: string;
  /** without any user input, this will default to true */
  text_finetune_enabled?: boolean;
  /** when we do fine tuning or RAG, we need to know which data entity we used */
  uploaded_data_entity_id?: string;
}

export enum TypesSessionMode {
  SessionModeNone = "",
  SessionModeInference = "inference",
  SessionModeFinetune = "finetune",
  SessionModeAction = "action",
}

export interface TypesSessionOrigin {
  cloned_interaction_id?: string;
  cloned_session_id?: string;
  type?: TypesSessionOriginType;
}

export enum TypesSessionOriginType {
  SessionOriginTypeNone = "",
  SessionOriginTypeUserCreated = "user_created",
  SessionOriginTypeCloned = "cloned",
}

export interface TypesSessionRAGResult {
  content?: string;
  content_offset?: number;
  distance?: number;
  document_group_id?: string;
  document_id?: string;
  filename?: string;
  id?: string;
  interaction_id?: string;
  metadata?: Record<string, string>;
  session_id?: string;
  source?: string;
}

export enum TypesSessionType {
  SessionTypeNone = "",
  SessionTypeText = "text",
  SessionTypeImage = "image",
}

export interface TypesStepInfo {
  message?: string;
  name?: string;
  type?: string;
}

export interface TypesTeam {
  created_at?: string;
  deleted_at?: GormDeletedAt;
  id?: string;
  /** Memberships in the team */
  memberships?: TypesTeamMembership[];
  name?: string;
  organization_id?: string;
  updated_at?: string;
}

export interface TypesTeamMembership {
  created_at?: string;
  organization_id?: string;
  team?: TypesTeam;
  team_id?: string;
  updated_at?: string;
  /** extra data fields (optional) */
  user?: TypesUser;
  /** composite key */
  user_id?: string;
}

export interface TypesTemplateAppConfig {
  /** Base API URL for the provider */
  api_url?: string;
  assistants?: TypesAssistantConfig[];
  description?: string;
  metadata?: Record<string, any>;
  name?: string;
  type?: TypesTemplateAppType;
}

export enum TypesTemplateAppType {
  TemplateAppTypeGitHub = "github",
  TemplateAppTypeJira = "jira",
  TemplateAppTypeSlack = "slack",
  TemplateAppTypeGoogle = "google",
}

export interface TypesTestStep {
  expected_output?: string;
  prompt?: string;
}

export enum TypesTextDataPrepStage {
  TextDataPrepStageNone = "",
  TextDataPrepStageEditFiles = "edit_files",
  TextDataPrepStageExtractText = "extract_text",
  TextDataPrepStageIndexRag = "index_rag",
  TextDataPrepStageGenerateQuestions = "generate_questions",
  TextDataPrepStageEditQuestions = "edit_questions",
  TextDataPrepStageFineTune = "finetune",
  TextDataPrepStageComplete = "complete",
}

export enum TypesTextSplitterType {
  TextSplitterTypeMarkdown = "markdown",
  TextSplitterTypeText = "text",
}

export enum TypesTokenType {
  TokenTypeNone = "",
  TokenTypeRunner = "runner",
  TokenTypeKeycloak = "keycloak",
  TokenTypeOIDC = "oidc",
  TokenTypeAPIKey = "api_key",
  TokenTypeSocket = "socket",
}

export interface TypesToolAPIAction {
  description?: string;
  method?: string;
  name?: string;
  path?: string;
}

export interface TypesToolAPIConfig {
  /** Read-only, parsed from schema on creation */
  actions?: TypesToolAPIAction[];
  /** Headers (authentication, etc) */
  headers?: Record<string, string>;
  model?: string;
  /** OAuth configuration */
  oauth_provider?: string;
  /** Required OAuth scopes for this API */
  oauth_scopes?: string[];
  /** Query parameters that will be always set */
  query?: Record<string, string>;
  /** Template for request preparation, leave empty for default */
  request_prep_template?: string;
  /** Template for error response, leave empty for default */
  response_error_template?: string;
  /** Template for successful response, leave empty for default */
  response_success_template?: string;
  schema?: string;
  /** System prompt to guide the AI when using this API */
  system_prompt?: string;
  /** Server override */
  url?: string;
}

export interface TypesToolConfig {
  api?: TypesToolAPIConfig;
  gptscript?: TypesToolGPTScriptConfig;
  zapier?: TypesToolZapierConfig;
}

export interface TypesToolGPTScriptConfig {
  /** Program code */
  script?: string;
  /** URL to download the script */
  script_url?: string;
}

export interface TypesToolZapierConfig {
  api_key?: string;
  max_iterations?: number;
  model?: string;
}

export interface TypesTrigger {
  cron?: TypesCronTrigger;
  discord?: TypesDiscordTrigger;
}

export interface TypesUpdateOrganizationMemberRequest {
  role?: TypesOrganizationRole;
}

export interface TypesUpdateProviderEndpoint {
  api_key?: string;
  /** Must be mounted to the container */
  api_key_file?: string;
  base_url?: string;
  description?: string;
  /** global, user (TODO: orgs, teams) */
  endpoint_type?: TypesProviderEndpointType;
  models?: string[];
}

export interface TypesUpdateTeamRequest {
  name?: string;
}

export interface TypesUser {
  /** if the ID of the user is contained in the env setting */
  admin?: boolean;
  /** if the token is associated with an app */
  app_id?: string;
  created_at?: string;
  deleted_at?: GormDeletedAt;
  email?: string;
  full_name?: string;
  id?: string;
  /** the actual token used and its type */
  token?: string;
  /** none, runner. keycloak, api_key */
  token_type?: TypesTokenType;
  /**
   * these are set by the keycloak user based on the token
   * if it's an app token - the keycloak user is loaded from the owner of the app
   * if it's a runner token - these values will be empty
   */
  type?: TypesOwnerType;
  updated_at?: string;
  username?: string;
}

export interface TypesUserAppAccessResponse {
  can_read?: boolean;
  can_write?: boolean;
  is_admin?: boolean;
}

export interface TypesUserResponse {
  email?: string;
  id?: string;
  name?: string;
  token?: string;
}

export interface TypesUserSearchResponse {
  limit?: number;
  offset?: number;
  total_count?: number;
  users?: TypesUser[];
}

export interface TypesUsersAggregatedUsageMetric {
  metrics?: TypesAggregatedUsageMetric[];
  user?: TypesUser;
}

export interface TypesWebsiteCrawler {
  enabled?: boolean;
  firecrawl?: TypesFirecrawl;
  ignore_robots_txt?: boolean;
  /** Limit crawl depth to avoid infinite crawling */
  max_depth?: number;
  /** Apply readability middleware to the HTML content */
  readability?: boolean;
  user_agent?: string;
}

export interface TypesWorkloadSummary {
  created?: string;
  id?: string;
  lora_dir?: string;
  mode?: string;
  model_name?: string;
  runtime?: string;
  summary?: string;
  updated?: string;
}

import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, HeadersDefaults, ResponseType } from "axios";
import axios from "axios";

export type QueryParamsType = Record<string | number, any>;

export interface FullRequestParams extends Omit<AxiosRequestConfig, "data" | "params" | "url" | "responseType"> {
  /** set parameter to `true` for call `securityWorker` for this request */
  secure?: boolean;
  /** request path */
  path: string;
  /** content type of request body */
  type?: ContentType;
  /** query params */
  query?: QueryParamsType;
  /** format of response (i.e. response.json() -> format: "json") */
  format?: ResponseType;
  /** request body */
  body?: unknown;
}

export type RequestParams = Omit<FullRequestParams, "body" | "method" | "query" | "path">;

export interface ApiConfig<SecurityDataType = unknown> extends Omit<AxiosRequestConfig, "data" | "cancelToken"> {
  securityWorker?: (
    securityData: SecurityDataType | null,
  ) => Promise<AxiosRequestConfig | void> | AxiosRequestConfig | void;
  secure?: boolean;
  format?: ResponseType;
}

export enum ContentType {
  Json = "application/json",
  FormData = "multipart/form-data",
  UrlEncoded = "application/x-www-form-urlencoded",
  Text = "text/plain",
}

export class HttpClient<SecurityDataType = unknown> {
  public instance: AxiosInstance;
  private securityData: SecurityDataType | null = null;
  private securityWorker?: ApiConfig<SecurityDataType>["securityWorker"];
  private secure?: boolean;
  private format?: ResponseType;

  constructor({ securityWorker, secure, format, ...axiosConfig }: ApiConfig<SecurityDataType> = {}) {
    this.instance = axios.create({ ...axiosConfig, baseURL: axiosConfig.baseURL || "https://app.tryhelix.ai" });
    this.secure = secure;
    this.format = format;
    this.securityWorker = securityWorker;
  }

  public setSecurityData = (data: SecurityDataType | null) => {
    this.securityData = data;
  };

  protected mergeRequestParams(params1: AxiosRequestConfig, params2?: AxiosRequestConfig): AxiosRequestConfig {
    const method = params1.method || (params2 && params2.method);

    return {
      ...this.instance.defaults,
      ...params1,
      ...(params2 || {}),
      headers: {
        ...((method && this.instance.defaults.headers[method.toLowerCase() as keyof HeadersDefaults]) || {}),
        ...(params1.headers || {}),
        ...((params2 && params2.headers) || {}),
      },
    };
  }

  protected stringifyFormItem(formItem: unknown) {
    if (typeof formItem === "object" && formItem !== null) {
      return JSON.stringify(formItem);
    } else {
      return `${formItem}`;
    }
  }

  protected createFormData(input: Record<string, unknown>): FormData {
    if (input instanceof FormData) {
      return input;
    }
    return Object.keys(input || {}).reduce((formData, key) => {
      const property = input[key];
      const propertyContent: any[] = property instanceof Array ? property : [property];

      for (const formItem of propertyContent) {
        const isFileType = formItem instanceof Blob || formItem instanceof File;
        formData.append(key, isFileType ? formItem : this.stringifyFormItem(formItem));
      }

      return formData;
    }, new FormData());
  }

  public request = async <T = any, _E = any>({
    secure,
    path,
    type,
    query,
    format,
    body,
    ...params
  }: FullRequestParams): Promise<AxiosResponse<T>> => {
    const secureParams =
      ((typeof secure === "boolean" ? secure : this.secure) &&
        this.securityWorker &&
        (await this.securityWorker(this.securityData))) ||
      {};
    const requestParams = this.mergeRequestParams(params, secureParams);
    const responseFormat = format || this.format || undefined;

    if (type === ContentType.FormData && body && body !== null && typeof body === "object") {
      body = this.createFormData(body as Record<string, unknown>);
    }

    if (type === ContentType.Text && body && body !== null && typeof body !== "string") {
      body = JSON.stringify(body);
    }

    return this.instance.request({
      ...requestParams,
      headers: {
        ...(requestParams.headers || {}),
        ...(type ? { "Content-Type": type } : {}),
      },
      params: query,
      responseType: responseFormat,
      data: body,
      url: path,
    });
  };
}

/**
 * @title HelixML API reference
 * @version 0.1
 * @baseUrl https://app.tryhelix.ai
 * @contact Helix support <info@helixml.tech> (https://app.tryhelix.ai/)
 *
 * This is a HelixML AI API.
 */
export class Api<SecurityDataType extends unknown> extends HttpClient<SecurityDataType> {
  api = {
    /**
     * No description
     *
     * @name V1AppsList
     * @request GET:/api/v1/apps
     * @secure
     */
    v1AppsList: (
      query?: {
        /** Organization ID */
        organization_id?: string;
      },
      params: RequestParams = {},
    ) =>
      this.request<TypesApp[], any>({
        path: `/api/v1/apps`,
        method: "GET",
        query: query,
        secure: true,
        ...params,
      }),

    /**
     * No description
     *
     * @name V1AppsCreate
     * @request POST:/api/v1/apps
     * @secure
     */
    v1AppsCreate: (request: TypesApp, params: RequestParams = {}) =>
      this.request<TypesApp, any>({
        path: `/api/v1/apps`,
        method: "POST",
        body: request,
        secure: true,
        ...params,
      }),

    /**
     * No description
     *
     * @name V1AppsDelete
     * @request DELETE:/api/v1/apps/{id}
     * @secure
     */
    v1AppsDelete: (id: string, params: RequestParams = {}) =>
      this.request<void, any>({
        path: `/api/v1/apps/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * No description
     *
     * @name V1AppsDetail
     * @request GET:/api/v1/apps/{id}
     * @secure
     */
    v1AppsDetail: (id: string, params: RequestParams = {}) =>
      this.request<TypesApp, any>({
        path: `/api/v1/apps/${id}`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * No description
     *
     * @name V1AppsUpdate
     * @request PUT:/api/v1/apps/{id}
     * @secure
     */
    v1AppsUpdate: (id: string, request: TypesApp, params: RequestParams = {}) =>
      this.request<TypesApp, any>({
        path: `/api/v1/apps/${id}`,
        method: "PUT",
        body: request,
        secure: true,
        ...params,
      }),

    /**
     * @description List access grants for an app (organization owners and members can list access grants)
     *
     * @tags apps
     * @name V1AppsAccessGrantsDetail
     * @summary List app access grants
     * @request GET:/api/v1/apps/{id}/access-grants
     * @secure
     */
    v1AppsAccessGrantsDetail: (id: string, params: RequestParams = {}) =>
      this.request<TypesAccessGrant[], any>({
        path: `/api/v1/apps/${id}/access-grants`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description Grant access to an app to a team or organization member (organization owners can grant access to teams and organization members)
     *
     * @tags apps
     * @name V1AppsAccessGrantsCreate
     * @summary Grant access to an app to a team or organization member
     * @request POST:/api/v1/apps/{id}/access-grants
     * @secure
     */
    v1AppsAccessGrantsCreate: (id: string, request: TypesCreateAccessGrantRequest, params: RequestParams = {}) =>
      this.request<TypesAccessGrant, any>({
        path: `/api/v1/apps/${id}/access-grants`,
        method: "POST",
        body: request,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description Runs an API action for an app
     *
     * @name V1AppsApiActionsCreate
     * @summary Run an API action
     * @request POST:/api/v1/apps/{id}/api-actions
     * @secure
     */
    v1AppsApiActionsCreate: (id: string, request: TypesRunAPIActionRequest, params: RequestParams = {}) =>
      this.request<TypesRunAPIActionResponse, SystemHTTPError>({
        path: `/api/v1/apps/${id}/api-actions`,
        method: "POST",
        body: request,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * @description Get app daily usage
     *
     * @tags apps
     * @name V1AppsDailyUsageDetail
     * @summary Get app usage
     * @request GET:/api/v1/apps/{id}/daily-usage
     * @secure
     */
    v1AppsDailyUsageDetail: (
      id: string,
      query?: {
        /** Start date */
        from?: string;
        /** End date */
        to?: string;
      },
      params: RequestParams = {},
    ) =>
      this.request<TypesAggregatedUsageMetric[], SystemHTTPError>({
        path: `/api/v1/apps/${id}/daily-usage`,
        method: "GET",
        query: query,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * @description Runs a gptscript for an app
     *
     * @name V1AppsGptscriptCreate
     * @summary Run a GptScript
     * @request POST:/api/v1/apps/{id}/gptscript
     * @secure
     */
    v1AppsGptscriptCreate: (id: string, request: TypesGptScriptRequest, params: RequestParams = {}) =>
      this.request<TypesGptScriptResponse, SystemHTTPError>({
        path: `/api/v1/apps/${id}/gptscript`,
        method: "POST",
        body: request,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * @description List user's LLM calls with pagination and optional session filtering for a specific app
     *
     * @tags llm_calls
     * @name V1AppsLlmCallsDetail
     * @summary List LLM calls
     * @request GET:/api/v1/apps/{id}/llm-calls
     * @secure
     */
    v1AppsLlmCallsDetail: (
      id: string,
      query?: {
        /** Page number */
        page?: number;
        /** Page size */
        pageSize?: number;
        /** Filter by session ID */
        sessionFilter?: string;
      },
      params: RequestParams = {},
    ) =>
      this.request<TypesPaginatedLLMCalls, any>({
        path: `/api/v1/apps/${id}/llm-calls`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * @description Returns the access rights the current user has for this app
     *
     * @tags apps
     * @name V1AppsUserAccessDetail
     * @summary Get current user's access level for an app
     * @request GET:/api/v1/apps/{id}/user-access
     * @secure
     */
    v1AppsUserAccessDetail: (id: string, params: RequestParams = {}) =>
      this.request<TypesUserAppAccessResponse, any>({
        path: `/api/v1/apps/${id}/user-access`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description Get app users daily usage
     *
     * @tags apps
     * @name V1AppsUsersDailyUsageDetail
     * @summary Get app users daily usage
     * @request GET:/api/v1/apps/{id}/users-daily-usage
     * @secure
     */
    v1AppsUsersDailyUsageDetail: (
      id: string,
      query?: {
        /** Start date */
        from?: string;
        /** End date */
        to?: string;
      },
      params: RequestParams = {},
    ) =>
      this.request<TypesAggregatedUsageMetric[], SystemHTTPError>({
        path: `/api/v1/apps/${id}/users-daily-usage`,
        method: "GET",
        query: query,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @name V1AppsGithubUpdate
     * @request PUT:/api/v1/apps/github/{id}
     * @secure
     */
    v1AppsGithubUpdate: (id: string, request: TypesApp, params: RequestParams = {}) =>
      this.request<TypesApp, any>({
        path: `/api/v1/apps/github/${id}`,
        method: "PUT",
        body: request,
        secure: true,
        ...params,
      }),

    /**
     * @description Check if the user is authenticated
     *
     * @tags auth
     * @name V1AuthAuthenticatedList
     * @summary Authenticated
     * @request GET:/api/v1/auth/authenticated
     */
    v1AuthAuthenticatedList: (params: RequestParams = {}) =>
      this.request<TypesAuthenticatedResponse, any>({
        path: `/api/v1/auth/authenticated`,
        method: "GET",
        ...params,
      }),

    /**
     * @description The callback receiver from the OIDC provider
     *
     * @tags auth
     * @name V1AuthCallbackList
     * @summary Callback from OIDC provider
     * @request GET:/api/v1/auth/callback
     */
    v1AuthCallbackList: (
      query: {
        /** The code from the OIDC provider */
        code: string;
        /** The state from the OIDC provider */
        state: string;
      },
      params: RequestParams = {},
    ) =>
      this.request<void, any>({
        path: `/api/v1/auth/callback`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
     * @description Login to the application
     *
     * @tags auth
     * @name V1AuthLoginCreate
     * @summary Login
     * @request POST:/api/v1/auth/login
     */
    v1AuthLoginCreate: (request: TypesLoginRequest, params: RequestParams = {}) =>
      this.request<void, any>({
        path: `/api/v1/auth/login`,
        method: "POST",
        body: request,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description Logout the user
     *
     * @tags auth
     * @name V1AuthLogoutCreate
     * @summary Logout
     * @request POST:/api/v1/auth/logout
     */
    v1AuthLogoutCreate: (params: RequestParams = {}) =>
      this.request<void, any>({
        path: `/api/v1/auth/logout`,
        method: "POST",
        ...params,
      }),

    /**
     * @description Refresh the access token
     *
     * @tags auth
     * @name V1AuthRefreshCreate
     * @summary Refresh the access token
     * @request POST:/api/v1/auth/refresh
     */
    v1AuthRefreshCreate: (params: RequestParams = {}) =>
      this.request<void, any>({
        path: `/api/v1/auth/refresh`,
        method: "POST",
        ...params,
      }),

    /**
     * @description Get the current user's information
     *
     * @tags auth
     * @name V1AuthUserList
     * @summary User information
     * @request GET:/api/v1/auth/user
     */
    v1AuthUserList: (params: RequestParams = {}) =>
      this.request<TypesUserResponse, any>({
        path: `/api/v1/auth/user`,
        method: "GET",
        ...params,
      }),

    /**
     * @description contextMenuHandler
     *
     * @tags ui
     * @name V1ContextMenuList
     * @summary contextMenuHandler
     * @request GET:/api/v1/context-menu
     */
    v1ContextMenuList: (
      query: {
        /** App ID */
        app_id: string;
        /** Query string */
        q?: string;
      },
      params: RequestParams = {},
    ) =>
      this.request<TypesContextMenuResponse, any>({
        path: `/api/v1/context-menu`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
     * No description
     *
     * @name V1DashboardList
     * @request GET:/api/v1/dashboard
     * @secure
     */
    v1DashboardList: (params: RequestParams = {}) =>
      this.request<TypesDashboardData, any>({
        path: `/api/v1/dashboard`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description List all available Helix models, optionally filtering by type, name, or runtime.
     *
     * @tags models
     * @name V1HelixModelsList
     * @summary List Helix models
     * @request GET:/api/v1/helix-models
     * @secure
     */
    v1HelixModelsList: (
      query?: {
        /** Filter by model type (e.g., chat, embedding) */
        type?: string;
        /** Filter by model name */
        name?: string;
        /** Filter by model runtime (e.g., ollama, vllm) */
        runtime?: string;
      },
      params: RequestParams = {},
    ) =>
      this.request<TypesModel[], any>({
        path: `/api/v1/helix-models`,
        method: "GET",
        query: query,
        secure: true,
        ...params,
      }),

    /**
     * @description Create a new Helix model configuration. Requires admin privileges.
     *
     * @tags models
     * @name V1HelixModelsCreate
     * @summary Create a new Helix model
     * @request POST:/api/v1/helix-models
     * @secure
     */
    v1HelixModelsCreate: (request: TypesModel, params: RequestParams = {}) =>
      this.request<TypesModel, string>({
        path: `/api/v1/helix-models`,
        method: "POST",
        body: request,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description Delete a Helix model configuration. Requires admin privileges.
     *
     * @tags models
     * @name V1HelixModelsDelete
     * @summary Delete a Helix model
     * @request DELETE:/api/v1/helix-models/{id}
     * @secure
     */
    v1HelixModelsDelete: (id: string, params: RequestParams = {}) =>
      this.request<string, string>({
        path: `/api/v1/helix-models/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * @description Update an existing Helix model configuration. Requires admin privileges.
     *
     * @tags models
     * @name V1HelixModelsUpdate
     * @summary Update an existing Helix model
     * @request PUT:/api/v1/helix-models/{id}
     * @secure
     */
    v1HelixModelsUpdate: (id: string, request: TypesModel, params: RequestParams = {}) =>
      this.request<TypesModel, string>({
        path: `/api/v1/helix-models/${id}`,
        method: "PUT",
        body: request,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * No description
     *
     * @name V1KnowledgeList
     * @request GET:/api/v1/knowledge
     * @secure
     */
    v1KnowledgeList: (params: RequestParams = {}) =>
      this.request<TypesKnowledge[], any>({
        path: `/api/v1/knowledge`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description Delete knowledge
     *
     * @tags knowledge
     * @name V1KnowledgeDelete
     * @summary Delete knowledge
     * @request DELETE:/api/v1/knowledge/{id}
     * @secure
     */
    v1KnowledgeDelete: (id: string, params: RequestParams = {}) =>
      this.request<TypesKnowledge, any>({
        path: `/api/v1/knowledge/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * No description
     *
     * @name V1KnowledgeDetail
     * @request GET:/api/v1/knowledge/{id}
     */
    v1KnowledgeDetail: (id: string, params: RequestParams = {}) =>
      this.request<TypesKnowledge, any>({
        path: `/api/v1/knowledge/${id}`,
        method: "GET",
        ...params,
      }),

    /**
     * @description Complete knowledge preparation and move to pending state for indexing
     *
     * @tags knowledge
     * @name V1KnowledgeCompleteCreate
     * @summary Complete knowledge preparation
     * @request POST:/api/v1/knowledge/{id}/complete
     * @secure
     */
    v1KnowledgeCompleteCreate: (id: string, params: RequestParams = {}) =>
      this.request<TypesKnowledge, any>({
        path: `/api/v1/knowledge/${id}/complete`,
        method: "POST",
        secure: true,
        ...params,
      }),

    /**
     * @description Refresh knowledge
     *
     * @tags knowledge
     * @name V1KnowledgeRefreshCreate
     * @summary Refresh knowledge
     * @request POST:/api/v1/knowledge/{id}/refresh
     * @secure
     */
    v1KnowledgeRefreshCreate: (id: string, params: RequestParams = {}) =>
      this.request<TypesKnowledge, any>({
        path: `/api/v1/knowledge/${id}/refresh`,
        method: "POST",
        secure: true,
        ...params,
      }),

    /**
     * @description List knowledge versions
     *
     * @tags knowledge
     * @name V1KnowledgeVersionsDetail
     * @summary List knowledge versions
     * @request GET:/api/v1/knowledge/{id}/versions
     * @secure
     */
    v1KnowledgeVersionsDetail: (id: string, params: RequestParams = {}) =>
      this.request<TypesKnowledgeVersion[], any>({
        path: `/api/v1/knowledge/${id}/versions`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description Get the license key for the current user
     *
     * @name V1LicenseList
     * @summary Get license key
     * @request GET:/api/v1/license
     * @secure
     */
    v1LicenseList: (params: RequestParams = {}) =>
      this.request<ServerLicenseKeyRequest, any>({
        path: `/api/v1/license`,
        method: "GET",
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * @description Set the license key for the current user
     *
     * @name V1LicenseCreate
     * @summary Set license key
     * @request POST:/api/v1/license
     * @secure
     */
    v1LicenseCreate: (params: RequestParams = {}) =>
      this.request<ServerLicenseKeyRequest, any>({
        path: `/api/v1/license`,
        method: "POST",
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * @description List LLM calls with pagination and optional session filtering
     *
     * @tags llm_calls
     * @name V1LlmCallsList
     * @summary List LLM calls
     * @request GET:/api/v1/llm_calls
     * @secure
     */
    v1LlmCallsList: (
      query?: {
        /** Page number */
        page?: number;
        /** Page size */
        pageSize?: number;
        /** Filter by session ID */
        sessionFilter?: string;
      },
      params: RequestParams = {},
    ) =>
      this.request<TypesPaginatedLLMCalls, any>({
        path: `/api/v1/llm_calls`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @name V1OrganizationsList
     * @request GET:/api/v1/organizations
     * @secure
     */
    v1OrganizationsList: (params: RequestParams = {}) =>
      this.request<TypesOrganization[], any>({
        path: `/api/v1/organizations`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description Create a new organization. Only admin users can create organizations.
     *
     * @tags organizations
     * @name V1OrganizationsCreate
     * @summary Create a new organization
     * @request POST:/api/v1/organizations
     * @secure
     */
    v1OrganizationsCreate: (request: TypesOrganization, params: RequestParams = {}) =>
      this.request<TypesOrganization, any>({
        path: `/api/v1/organizations`,
        method: "POST",
        body: request,
        secure: true,
        ...params,
      }),

    /**
     * No description
     *
     * @name V1OrganizationsDelete
     * @request DELETE:/api/v1/organizations/{id}
     * @secure
     */
    v1OrganizationsDelete: (id: string, params: RequestParams = {}) =>
      this.request<TypesOrganization, any>({
        path: `/api/v1/organizations/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * No description
     *
     * @name V1OrganizationsDetail
     * @request GET:/api/v1/organizations/{id}
     */
    v1OrganizationsDetail: (id: string, params: RequestParams = {}) =>
      this.request<TypesOrganization, any>({
        path: `/api/v1/organizations/${id}`,
        method: "GET",
        ...params,
      }),

    /**
     * @description Update an organization, must be an owner of the organization
     *
     * @tags organizations
     * @name V1OrganizationsUpdate
     * @summary Update an organization
     * @request PUT:/api/v1/organizations/{id}
     * @secure
     */
    v1OrganizationsUpdate: (id: string, request: TypesOrganization, params: RequestParams = {}) =>
      this.request<TypesOrganization, any>({
        path: `/api/v1/organizations/${id}`,
        method: "PUT",
        body: request,
        secure: true,
        ...params,
      }),

    /**
     * @description List members of an organization
     *
     * @tags organizations
     * @name V1OrganizationsMembersDetail
     * @summary List organization members
     * @request GET:/api/v1/organizations/{id}/members
     * @secure
     */
    v1OrganizationsMembersDetail: (id: string, params: RequestParams = {}) =>
      this.request<TypesOrganizationMembership[], any>({
        path: `/api/v1/organizations/${id}/members`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description Add a member to an organization
     *
     * @tags organizations
     * @name V1OrganizationsMembersCreate
     * @summary Add an organization member
     * @request POST:/api/v1/organizations/{id}/members
     * @secure
     */
    v1OrganizationsMembersCreate: (
      id: string,
      request: TypesAddOrganizationMemberRequest,
      params: RequestParams = {},
    ) =>
      this.request<TypesOrganizationMembership, any>({
        path: `/api/v1/organizations/${id}/members`,
        method: "POST",
        body: request,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description Remove a member from an organization
     *
     * @tags organizations
     * @name V1OrganizationsMembersDelete
     * @summary Remove an organization member
     * @request DELETE:/api/v1/organizations/{id}/members/{user_id}
     * @secure
     */
    v1OrganizationsMembersDelete: (id: string, userId: string, params: RequestParams = {}) =>
      this.request<void, any>({
        path: `/api/v1/organizations/${id}/members/${userId}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * @description Update a member's role in an organization
     *
     * @tags organizations
     * @name V1OrganizationsMembersUpdate
     * @summary Update an organization member
     * @request PUT:/api/v1/organizations/{id}/members/{user_id}
     * @secure
     */
    v1OrganizationsMembersUpdate: (
      id: string,
      userId: string,
      request: TypesUpdateOrganizationMemberRequest,
      params: RequestParams = {},
    ) =>
      this.request<TypesOrganizationMembership, any>({
        path: `/api/v1/organizations/${id}/members/${userId}`,
        method: "PUT",
        body: request,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description List all roles in an organization. Organization members can list roles.
     *
     * @tags organizations
     * @name V1OrganizationsRolesDetail
     * @summary List roles in an organization
     * @request GET:/api/v1/organizations/{id}/roles
     * @secure
     */
    v1OrganizationsRolesDetail: (id: string, params: RequestParams = {}) =>
      this.request<TypesRole[], any>({
        path: `/api/v1/organizations/${id}/roles`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description List all teams in an organization. Organization members can list teams.
     *
     * @tags organizations
     * @name V1OrganizationsTeamsDetail
     * @summary List teams in an organization
     * @request GET:/api/v1/organizations/{id}/teams
     * @secure
     */
    v1OrganizationsTeamsDetail: (id: string, params: RequestParams = {}) =>
      this.request<TypesTeam[], any>({
        path: `/api/v1/organizations/${id}/teams`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description Create a new team in an organization. Only organization owners can create teams.
     *
     * @tags organizations
     * @name V1OrganizationsTeamsCreate
     * @summary Create a new team
     * @request POST:/api/v1/organizations/{id}/teams
     * @secure
     */
    v1OrganizationsTeamsCreate: (id: string, request: TypesCreateTeamRequest, params: RequestParams = {}) =>
      this.request<TypesTeam, any>({
        path: `/api/v1/organizations/${id}/teams`,
        method: "POST",
        body: request,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * @description Delete a team from an organization. Only organization owners can delete teams.
     *
     * @tags organizations
     * @name V1OrganizationsTeamsDelete
     * @summary Delete a team
     * @request DELETE:/api/v1/organizations/{id}/teams/{team_id}
     * @secure
     */
    v1OrganizationsTeamsDelete: (id: string, teamId: string, params: RequestParams = {}) =>
      this.request<void, any>({
        path: `/api/v1/organizations/${id}/teams/${teamId}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * @description Update a team's details. Only organization owners can update teams.
     *
     * @tags organizations
     * @name V1OrganizationsTeamsUpdate
     * @summary Update a team
     * @request PUT:/api/v1/organizations/{id}/teams/{team_id}
     * @secure
     */
    v1OrganizationsTeamsUpdate: (
      id: string,
      teamId: string,
      request: TypesUpdateTeamRequest,
      params: RequestParams = {},
    ) =>
      this.request<TypesTeam, any>({
        path: `/api/v1/organizations/${id}/teams/${teamId}`,
        method: "PUT",
        body: request,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * @description List all members of a team.
     *
     * @tags organizations
     * @name V1OrganizationsTeamsMembersDetail
     * @summary List members of a team
     * @request GET:/api/v1/organizations/{id}/teams/{team_id}/members
     * @secure
     */
    v1OrganizationsTeamsMembersDetail: (id: string, teamId: string, params: RequestParams = {}) =>
      this.request<TypesTeamMembership[], any>({
        path: `/api/v1/organizations/${id}/teams/${teamId}/members`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description Add a new member to a team. Only organization owners can add members to teams.
     *
     * @tags organizations
     * @name V1OrganizationsTeamsMembersCreate
     * @summary Add a new member to a team
     * @request POST:/api/v1/organizations/{id}/teams/{team_id}/members
     * @secure
     */
    v1OrganizationsTeamsMembersCreate: (
      id: string,
      teamId: string,
      request: TypesAddTeamMemberRequest,
      params: RequestParams = {},
    ) =>
      this.request<TypesTeamMembership, any>({
        path: `/api/v1/organizations/${id}/teams/${teamId}/members`,
        method: "POST",
        body: request,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @name V1ProviderEndpointsList
     * @request GET:/api/v1/provider-endpoints
     * @secure
     */
    v1ProviderEndpointsList: (
      query?: {
        /** Include models */
        with_models?: boolean;
      },
      params: RequestParams = {},
    ) =>
      this.request<TypesProviderEndpoint[], any>({
        path: `/api/v1/provider-endpoints`,
        method: "GET",
        query: query,
        secure: true,
        ...params,
      }),

    /**
     * No description
     *
     * @name V1ProviderEndpointsCreate
     * @request POST:/api/v1/provider-endpoints
     * @secure
     */
    v1ProviderEndpointsCreate: (params: RequestParams = {}) =>
      this.request<TypesProviderEndpoint, any>({
        path: `/api/v1/provider-endpoints`,
        method: "POST",
        secure: true,
        ...params,
      }),

    /**
     * No description
     *
     * @name V1ProviderEndpointsDelete
     * @request DELETE:/api/v1/provider-endpoints/{id}
     * @secure
     */
    v1ProviderEndpointsDelete: (id: string, params: RequestParams = {}) =>
      this.request<void, any>({
        path: `/api/v1/provider-endpoints/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * No description
     *
     * @name V1ProviderEndpointsUpdate
     * @request PUT:/api/v1/provider-endpoints/{id}
     * @secure
     */
    v1ProviderEndpointsUpdate: (id: string, params: RequestParams = {}) =>
      this.request<TypesUpdateProviderEndpoint, any>({
        path: `/api/v1/provider-endpoints/${id}`,
        method: "PUT",
        secure: true,
        ...params,
      }),

    /**
     * @description Get provider daily usage
     *
     * @tags providers
     * @name V1ProviderEndpointsDailyUsageDetail
     * @summary Get provider daily usage
     * @request GET:/api/v1/provider-endpoints/{id}/daily-usage
     * @secure
     */
    v1ProviderEndpointsDailyUsageDetail: (
      id: string,
      query?: {
        /** Start date */
        from?: string;
        /** End date */
        to?: string;
      },
      params: RequestParams = {},
    ) =>
      this.request<TypesAggregatedUsageMetric[], SystemHTTPError>({
        path: `/api/v1/provider-endpoints/${id}/daily-usage`,
        method: "GET",
        query: query,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * @description Get provider daily usage per user
     *
     * @tags providers
     * @name V1ProviderEndpointsUsersDailyUsageDetail
     * @summary Get provider daily usage per user
     * @request GET:/api/v1/provider-endpoints/{id}/users-daily-usage
     * @secure
     */
    v1ProviderEndpointsUsersDailyUsageDetail: (
      id: string,
      query?: {
        /** Start date */
        from?: string;
        /** End date */
        to?: string;
      },
      params: RequestParams = {},
    ) =>
      this.request<TypesUsersAggregatedUsageMetric[], SystemHTTPError>({
        path: `/api/v1/provider-endpoints/${id}/users-daily-usage`,
        method: "GET",
        query: query,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @name V1ProvidersList
     * @request GET:/api/v1/providers
     * @secure
     */
    v1ProvidersList: (params: RequestParams = {}) =>
      this.request<TypesProvider[], any>({
        path: `/api/v1/providers`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description Search knowledges for a given app and prompt
     *
     * @tags knowledge
     * @name V1SearchList
     * @summary Search knowledges
     * @request GET:/api/v1/search
     * @secure
     */
    v1SearchList: (
      query: {
        /** App ID */
        app_id: string;
        /** Knowledge ID */
        knowledge_id?: string;
        /** Search prompt */
        prompt: string;
      },
      params: RequestParams = {},
    ) =>
      this.request<TypesKnowledgeSearchResult[], any>({
        path: `/api/v1/search`,
        method: "GET",
        query: query,
        secure: true,
        ...params,
      }),

    /**
     * @description List secrets for the user.
     *
     * @tags secrets
     * @name V1SecretsList
     * @summary List secrets
     * @request GET:/api/v1/secrets
     * @secure
     */
    v1SecretsList: (params: RequestParams = {}) =>
      this.request<TypesSecret[], any>({
        path: `/api/v1/secrets`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description Create a new secret for the user.
     *
     * @tags secrets
     * @name V1SecretsCreate
     * @summary Create new secret
     * @request POST:/api/v1/secrets
     * @secure
     */
    v1SecretsCreate: (request: TypesSecret, params: RequestParams = {}) =>
      this.request<TypesSecret, any>({
        path: `/api/v1/secrets`,
        method: "POST",
        body: request,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description Delete a secret for the user.
     *
     * @tags secrets
     * @name V1SecretsDelete
     * @summary Delete a secret
     * @request DELETE:/api/v1/secrets/{id}
     * @secure
     */
    v1SecretsDelete: (id: string, params: RequestParams = {}) =>
      this.request<TypesSecret, any>({
        path: `/api/v1/secrets/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * @description Update an existing secret for the user.
     *
     * @tags secrets
     * @name V1SecretsUpdate
     * @summary Update an existing secret
     * @request PUT:/api/v1/secrets/{id}
     * @secure
     */
    v1SecretsUpdate: (id: string, request: TypesSecret, params: RequestParams = {}) =>
      this.request<TypesSecret, any>({
        path: `/api/v1/secrets/${id}`,
        method: "PUT",
        body: request,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * No description
     *
     * @name V1SessionsStepInfoDetail
     * @request GET:/api/v1/sessions/{id}/step-info
     * @secure
     */
    v1SessionsStepInfoDetail: (id: string, params: RequestParams = {}) =>
      this.request<TypesStepInfo[], any>({
        path: `/api/v1/sessions/${id}/step-info`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * No description
     *
     * @name V1SessionsChatCreate
     * @request POST:/api/v1/sessions/chat
     * @secure
     */
    v1SessionsChatCreate: (request: TypesSessionChatRequest, params: RequestParams = {}) =>
      this.request<TypesOpenAIResponse, any>({
        path: `/api/v1/sessions/chat`,
        method: "POST",
        body: request,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * No description
     *
     * @name V1SessionsLearnCreate
     * @request POST:/api/v1/sessions/learn
     * @secure
     */
    v1SessionsLearnCreate: (request: TypesSessionLearnRequest, params: RequestParams = {}) =>
      this.request<TypesSession, any>({
        path: `/api/v1/sessions/learn`,
        method: "POST",
        body: request,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description List available template apps configurations.
     *
     * @tags template_apps
     * @name V1TemplateAppsList
     * @summary List template apps
     * @request GET:/api/v1/template-apps
     * @secure
     */
    v1TemplateAppsList: (params: RequestParams = {}) =>
      this.request<TypesTemplateAppConfig[], any>({
        path: `/api/v1/template-apps`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description Get template app configuration by type.
     *
     * @tags template_apps
     * @name V1TemplateAppsDetail
     * @summary Get template app by type
     * @request GET:/api/v1/template-apps/{type}
     * @secure
     */
    v1TemplateAppsDetail: (type: string, params: RequestParams = {}) =>
      this.request<TypesTemplateAppConfig, SystemHTTPError>({
        path: `/api/v1/template-apps/${type}`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description Search users by email, name, or username
     *
     * @tags users
     * @name V1UsersSearchList
     * @summary Search users
     * @request GET:/api/v1/users/search
     * @secure
     */
    v1UsersSearchList: (
      query: {
        /** Query */
        query: string;
        /** Organization ID */
        organization_id?: string;
        /** Limit */
        limit?: number;
        /** Offset */
        offset?: number;
      },
      params: RequestParams = {},
    ) =>
      this.request<TypesUserSearchResponse, any>({
        path: `/api/v1/users/search`,
        method: "GET",
        query: query,
        secure: true,
        ...params,
      }),
  };
  v1 = {
    /**
     * @description Creates a model response for the given chat conversation.
     *
     * @tags chat
     * @name ChatCompletionsCreate
     * @summary Stream responses for chat
     * @request POST:/v1/chat/completions
     * @secure
     */
    chatCompletionsCreate: (request: GithubComSashabaranovGoOpenaiChatCompletionRequest, params: RequestParams = {}) =>
      this.request<GithubComSashabaranovGoOpenaiChatCompletionResponse, any>({
        path: `/v1/chat/completions`,
        method: "POST",
        body: request,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description Creates an embedding vector representing the input text
     *
     * @tags embeddings
     * @name EmbeddingsCreate
     * @summary Creates an embedding vector representing the input text
     * @request POST:/v1/embeddings
     * @secure
     */
    embeddingsCreate: (request: OpenaiEmbeddingRequest, params: RequestParams = {}) =>
      this.request<OpenaiEmbeddingResponse, any>({
        path: `/v1/embeddings`,
        method: "POST",
        body: request,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * No description
     *
     * @name ModelsList
     * @request GET:/v1/models
     * @secure
     */
    modelsList: (
      query?: {
        /** Provider */
        provider?: string;
      },
      params: RequestParams = {},
    ) =>
      this.request<TypesOpenAIModelsList[], any>({
        path: `/v1/models`,
        method: "GET",
        query: query,
        secure: true,
        ...params,
      }),
  };
}
