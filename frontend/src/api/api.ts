/* eslint-disable */
/* tslint:disable */
/*
 * ---------------------------------------------------------------
 * ## THIS FILE WAS GENERATED VIA SWAGGER-TYPESCRIPT-API        ##
 * ##                                                           ##
 * ## AUTHOR: acacode                                           ##
 * ## SOURCE: https://github.com/acacode/swagger-typescript-api ##
 * ---------------------------------------------------------------
 */

export interface GithubComHelixmlHelixApiPkgTypesConfig {
  rules?: TypesRule[];
}

export interface GithubComHelixmlHelixApiPkgTypesTool {
  config?: TypesToolConfig;
  created?: string;
  description?: string;
  global?: boolean;
  id?: string;
  name?: string;
  /** uuid of owner entity */
  owner?: string;
  /** e.g. user, system, org */
  owner_type?: TypesOwnerType;
  tool_type?: GithubComHelixmlHelixApiPkgTypesToolType;
  updated?: string;
}

export enum GithubComHelixmlHelixApiPkgTypesToolType {
  ToolTypeAPI = "api",
  ToolTypeGPTScript = "gptscript",
  ToolTypeZapier = "zapier",
}

export interface GithubComHelixmlHelixApiPkgTypesUsage {
  completion_tokens?: number;
  /** How long the request took in milliseconds */
  duration_ms?: number;
  prompt_tokens?: number;
  total_tokens?: number;
}

export interface GithubComSashabaranovGoOpenaiChatCompletionChoice {
  /**
   * FinishReason
   * stop: API returned complete message,
   * or a message terminated by one of the stop sequences provided via the stop parameter
   * length: Incomplete model output due to max_tokens parameter or token limit
   * function_call: The model decided to call a function
   * content_filter: Omitted content due to a flag from our content filters
   * null: API response still in progress or incomplete
   */
  finish_reason?: GithubComSashabaranovGoOpenaiFinishReason;
  index?: number;
  logprobs?: GithubComSashabaranovGoOpenaiLogProbs;
  message?: GithubComSashabaranovGoOpenaiChatCompletionMessage;
}

export interface GithubComSashabaranovGoOpenaiChatCompletionMessage {
  content?: string;
  function_call?: GithubComSashabaranovGoOpenaiFunctionCall;
  multiContent?: GithubComSashabaranovGoOpenaiChatMessagePart[];
  /**
   * This property isn't in the official documentation, but it's in
   * the documentation for the official library for python:
   * - https://github.com/openai/openai-python/blob/main/chatml.md
   * - https://github.com/openai/openai-cookbook/blob/main/examples/How_to_count_tokens_with_tiktoken.ipynb
   */
  name?: string;
  refusal?: string;
  role?: string;
  /** For Role=tool prompts this should be set to the ID given in the assistant's prior request to call a tool. */
  tool_call_id?: string;
  /** For Role=assistant prompts this may be set to the tool calls generated by the model, such as function calls. */
  tool_calls?: GithubComSashabaranovGoOpenaiToolCall[];
}

export interface GithubComSashabaranovGoOpenaiChatCompletionRequest {
  frequency_penalty?: number;
  /** Deprecated: use ToolChoice instead. */
  function_call?: any;
  /** Deprecated: use Tools instead. */
  functions?: GithubComSashabaranovGoOpenaiFunctionDefinition[];
  /**
   * LogitBias is must be a token id string (specified by their token ID in the tokenizer), not a word string.
   * incorrect: `"logit_bias":{"You": 6}`, correct: `"logit_bias":{"1639": 6}`
   * refs: https://platform.openai.com/docs/api-reference/chat/create#chat/create-logit_bias
   */
  logit_bias?: Record<string, number>;
  /**
   * LogProbs indicates whether to return log probabilities of the output tokens or not.
   * If true, returns the log probabilities of each output token returned in the content of message.
   * This option is currently not available on the gpt-4-vision-preview model.
   */
  logprobs?: boolean;
  /**
   * MaxCompletionsTokens An upper bound for the number of tokens that can be generated for a completion,
   * including visible output tokens and reasoning tokens https://platform.openai.com/docs/guides/reasoning
   */
  max_completion_tokens?: number;
  /**
   * MaxTokens The maximum number of tokens that can be generated in the chat completion.
   * This value can be used to control costs for text generated via API.
   * This value is now deprecated in favor of max_completion_tokens, and is not compatible with o1 series models.
   * refs: https://platform.openai.com/docs/api-reference/chat/create#chat-create-max_tokens
   */
  max_tokens?: number;
  messages?: GithubComSashabaranovGoOpenaiChatCompletionMessage[];
  model?: string;
  n?: number;
  /** Disable the default behavior of parallel tool calls by setting it: false. */
  parallel_tool_calls?: any;
  presence_penalty?: number;
  response_format?: GithubComSashabaranovGoOpenaiChatCompletionResponseFormat;
  seed?: number;
  stop?: string[];
  stream?: boolean;
  /** Options for streaming response. Only set this when you set stream: true. */
  stream_options?: GithubComSashabaranovGoOpenaiStreamOptions;
  temperature?: number;
  /** This can be either a string or an ToolChoice object. */
  tool_choice?: any;
  tools?: GithubComSashabaranovGoOpenaiTool[];
  /**
   * TopLogProbs is an integer between 0 and 5 specifying the number of most likely tokens to return at each
   * token position, each with an associated log probability.
   * logprobs must be set to true if this parameter is used.
   */
  top_logprobs?: number;
  top_p?: number;
  user?: string;
}

export interface GithubComSashabaranovGoOpenaiChatCompletionResponse {
  choices?: GithubComSashabaranovGoOpenaiChatCompletionChoice[];
  created?: number;
  id?: string;
  model?: string;
  object?: string;
  system_fingerprint?: string;
  usage?: GithubComSashabaranovGoOpenaiUsage;
}

export interface GithubComSashabaranovGoOpenaiChatCompletionResponseFormat {
  json_schema?: OpenaiChatCompletionResponseFormatJSONSchema;
  type?: GithubComSashabaranovGoOpenaiChatCompletionResponseFormatType;
}

export enum GithubComSashabaranovGoOpenaiChatCompletionResponseFormatType {
  ChatCompletionResponseFormatTypeJSONObject = "json_object",
  ChatCompletionResponseFormatTypeJSONSchema = "json_schema",
  ChatCompletionResponseFormatTypeText = "text",
}

export interface GithubComSashabaranovGoOpenaiChatMessageImageURL {
  detail?: GithubComSashabaranovGoOpenaiImageURLDetail;
  url?: string;
}

export interface GithubComSashabaranovGoOpenaiChatMessagePart {
  image_url?: GithubComSashabaranovGoOpenaiChatMessageImageURL;
  text?: string;
  type?: GithubComSashabaranovGoOpenaiChatMessagePartType;
}

export enum GithubComSashabaranovGoOpenaiChatMessagePartType {
  ChatMessagePartTypeText = "text",
  ChatMessagePartTypeImageURL = "image_url",
}

export enum GithubComSashabaranovGoOpenaiFinishReason {
  FinishReasonStop = "stop",
  FinishReasonLength = "length",
  FinishReasonFunctionCall = "function_call",
  FinishReasonToolCalls = "tool_calls",
  FinishReasonContentFilter = "content_filter",
  FinishReasonNull = "null",
}

export interface GithubComSashabaranovGoOpenaiFunctionCall {
  /** call function with arguments in JSON format */
  arguments?: string;
  name?: string;
}

export interface GithubComSashabaranovGoOpenaiFunctionDefinition {
  description?: string;
  name?: string;
  /**
   * Parameters is an object describing the function.
   * You can pass json.RawMessage to describe the schema,
   * or you can pass in a struct which serializes to the proper JSON schema.
   * The jsonschema package is provided for convenience, but you should
   * consider another specialized library if you require more complex schemas.
   */
  parameters?: any;
  strict?: boolean;
}

export enum GithubComSashabaranovGoOpenaiImageURLDetail {
  ImageURLDetailHigh = "high",
  ImageURLDetailLow = "low",
  ImageURLDetailAuto = "auto",
}

export interface GithubComSashabaranovGoOpenaiLogProb {
  /** Omitting the field if it is null */
  bytes?: number[];
  logprob?: number;
  token?: string;
  /**
   * TopLogProbs is a list of the most likely tokens and their log probability, at this token position.
   * In rare cases, there may be fewer than the number of requested top_logprobs returned.
   */
  top_logprobs?: GithubComSashabaranovGoOpenaiTopLogProbs[];
}

export interface GithubComSashabaranovGoOpenaiLogProbs {
  /** Content is a list of message content tokens with log probability information. */
  content?: GithubComSashabaranovGoOpenaiLogProb[];
}

export interface GithubComSashabaranovGoOpenaiStreamOptions {
  /**
   * If set, an additional chunk will be streamed before the data: [DONE] message.
   * The usage field on this chunk shows the token usage statistics for the entire request,
   * and the choices field will always be an empty array.
   * All other chunks will also include a usage field, but with a null value.
   */
  include_usage?: boolean;
}

export interface GithubComSashabaranovGoOpenaiTool {
  function?: GithubComSashabaranovGoOpenaiFunctionDefinition;
  type?: GithubComSashabaranovGoOpenaiToolType;
}

export interface GithubComSashabaranovGoOpenaiToolCall {
  function?: GithubComSashabaranovGoOpenaiFunctionCall;
  id?: string;
  /** Index is not nil only in chat completion chunk object */
  index?: number;
  type?: GithubComSashabaranovGoOpenaiToolType;
}

export enum GithubComSashabaranovGoOpenaiToolType {
  ToolTypeFunction = "function",
}

export interface GithubComSashabaranovGoOpenaiTopLogProbs {
  bytes?: number[];
  logprob?: number;
  token?: string;
}

export interface GithubComSashabaranovGoOpenaiUsage {
  completion_tokens?: number;
  completion_tokens_details?: OpenaiCompletionTokensDetails;
  prompt_tokens?: number;
  total_tokens?: number;
}

export interface GormDeletedAt {
  time?: string;
  /** Valid is true if Time is not NULL */
  valid?: boolean;
}

export interface OpenaiChatCompletionResponseFormatJSONSchema {
  description?: string;
  name?: string;
  schema?: any;
  strict?: boolean;
}

export interface OpenaiCompletionTokensDetails {
  reasoning_tokens?: number;
}

export interface OpenaiEmbedding {
  embedding?: number[];
  index?: number;
  object?: string;
}

export enum OpenaiEmbeddingEncodingFormat {
  EmbeddingEncodingFormatFloat = "float",
  EmbeddingEncodingFormatBase64 = "base64",
}

export enum OpenaiEmbeddingModel {
  AdaSimilarity = "text-similarity-ada-001",
  BabbageSimilarity = "text-similarity-babbage-001",
  CurieSimilarity = "text-similarity-curie-001",
  DavinciSimilarity = "text-similarity-davinci-001",
  AdaSearchDocument = "text-search-ada-doc-001",
  AdaSearchQuery = "text-search-ada-query-001",
  BabbageSearchDocument = "text-search-babbage-doc-001",
  BabbageSearchQuery = "text-search-babbage-query-001",
  CurieSearchDocument = "text-search-curie-doc-001",
  CurieSearchQuery = "text-search-curie-query-001",
  DavinciSearchDocument = "text-search-davinci-doc-001",
  DavinciSearchQuery = "text-search-davinci-query-001",
  AdaCodeSearchCode = "code-search-ada-code-001",
  AdaCodeSearchText = "code-search-ada-text-001",
  BabbageCodeSearchCode = "code-search-babbage-code-001",
  BabbageCodeSearchText = "code-search-babbage-text-001",
  AdaEmbeddingV2 = "text-embedding-ada-002",
  SmallEmbedding3 = "text-embedding-3-small",
  LargeEmbedding3 = "text-embedding-3-large",
}

export interface OpenaiEmbeddingRequest {
  /**
   * Dimensions The number of dimensions the resulting output embeddings should have.
   * Only supported in text-embedding-3 and later models.
   */
  dimensions?: number;
  encoding_format?: OpenaiEmbeddingEncodingFormat;
  input?: any;
  model?: OpenaiEmbeddingModel;
  user?: string;
}

export interface OpenaiEmbeddingResponse {
  data?: OpenaiEmbedding[];
  model?: OpenaiEmbeddingModel;
  object?: string;
  usage?: GithubComSashabaranovGoOpenaiUsage;
}

export interface TypesAccessGrant {
  created_at?: string;
  id?: string;
  /** If granted to an organization */
  organization_id?: string;
  /** App ID, Knowledge ID, etc */
  resource_id?: string;
  /** Kind of resource (app, knowledge, provider endpoint, etc) */
  resource_type?: TypesResource;
  roles?: TypesRole[];
  /** If granted to a team */
  team_id?: string;
  updated_at?: string;
  /** Populated by the server if UserID is set */
  user?: TypesUser;
  /** If granted to a user */
  user_id?: string;
}

export enum TypesAction {
  ActionGet = "Get",
  ActionList = "List",
  ActionDelete = "Delete",
  ActionUpdate = "Update",
  ActionCreate = "Create",
  ActionUseAction = "UseAction",
}

export interface TypesAddOrganizationMemberRequest {
  role?: TypesOrganizationRole;
  /** Either user ID or user email */
  user_reference?: string;
}

export interface TypesAddTeamMemberRequest {
  /** Either user ID or user email */
  user_reference?: string;
}

export interface TypesApp {
  app_source?: TypesAppSource;
  config?: TypesAppConfig;
  created?: string;
  global?: boolean;
  id?: string;
  organization_id?: string;
  /** uuid of owner entity */
  owner?: string;
  /** e.g. user, system, org */
  owner_type?: TypesOwnerType;
  shared?: boolean;
  updated?: string;
  /** Owner user struct, populated by the server for organization views */
  user?: TypesUser;
}

export interface TypesAppConfig {
  allowed_domains?: string[];
  github?: TypesAppGithubConfig;
  helix?: TypesAppHelixConfig;
  secrets?: Record<string, string>;
}

export interface TypesAppGithubConfig {
  hash?: string;
  key_pair?: TypesKeyPair;
  last_update?: TypesAppGithubConfigUpdate;
  repo?: string;
  webhook_secret?: string;
}

export interface TypesAppGithubConfigUpdate {
  error?: string;
  hash?: string;
  updated?: string;
}

export interface TypesAppHelixConfig {
  assistants?: TypesAssistantConfig[];
  avatar?: string;
  description?: string;
  external_url?: string;
  image?: string;
  name?: string;
  triggers?: TypesTrigger[];
}

export enum TypesAppSource {
  AppSourceHelix = "helix",
  AppSourceGithub = "github",
}

export interface TypesAssistantAPI {
  description?: string;
  headers?: Record<string, string>;
  name?: string;
  query?: Record<string, string>;
  request_prep_template?: string;
  response_error_template?: string;
  response_success_template?: string;
  schema?: string;
  url?: string;
}

export interface TypesAssistantConfig {
  apis?: TypesAssistantAPI[];
  avatar?: string;
  description?: string;
  gptscripts?: TypesAssistantGPTScript[];
  id?: string;
  image?: string;
  is_actionable_template?: string;
  knowledge?: TypesAssistantKnowledge[];
  lora_id?: string;
  model?: string;
  name?: string;
  provider?: string;
  rag_source_id?: string;
  system_prompt?: string;
  tests?: {
    name?: string;
    steps?: TypesTestStep[];
  }[];
  tools?: GithubComHelixmlHelixApiPkgTypesTool[];
  type?: TypesSessionType;
  zapier?: TypesAssistantZapier[];
}

export interface TypesAssistantGPTScript {
  content?: string;
  /** When to use this tool (required) */
  description?: string;
  file?: string;
  name?: string;
}

export interface TypesAssistantKnowledge {
  /**
   * Description of the knowledge, will be used in the prompt
   * to explain the knowledge to the assistant
   */
  description?: string;
  /** Name of the knowledge, will be unique within the Helix app */
  name?: string;
  /**
   * RAGSettings defines the settings for the RAG system, how
   * chunking is configured and where the index/query service is
   * hosted.
   */
  rag_settings?: TypesRAGSettings;
  /**
   * RefreshEnabled defines if the knowledge should be refreshed periodically
   * or on events. For example a Google Drive knowledge can be refreshed
   * every 24 hours.
   */
  refresh_enabled?: boolean;
  /**
   * RefreshSchedule defines the schedule for refreshing the knowledge.
   * It can be specified in cron format or as a duration for example '@every 2h'
   * or 'every 5m' or '0 0 * * *' for daily at midnight.
   */
  refresh_schedule?: string;
  /**
   * Source defines where the raw data is fetched from. It can be
   * directly uploaded files, S3, GCS, Google Drive, Gmail, etc.
   */
  source?: TypesKnowledgeSource;
}

export interface TypesAssistantZapier {
  api_key?: string;
  description?: string;
  max_iterations?: number;
  model?: string;
  name?: string;
}

export interface TypesChoice {
  delta?: TypesOpenAIMessage;
  finish_reason?: string;
  index?: number;
  message?: TypesOpenAIMessage;
  text?: string;
}

export interface TypesCreateAccessGrantRequest {
  /** Role names */
  roles?: string[];
  /** Team ID */
  team_id?: string;
  /** User ID or email */
  user_reference?: string;
}

export interface TypesCreateTeamRequest {
  name?: string;
  organization_id?: string;
}

export enum TypesCreatorType {
  CreatorTypeSystem = "system",
  CreatorTypeAssistant = "assistant",
  CreatorTypeUser = "user",
  CreatorTypeTool = "tool",
}

export interface TypesCronTrigger {
  input?: string;
  schedule?: string;
}

export interface TypesDataPrepChunk {
  error?: string;
  index?: number;
  prompt_name?: string;
  question_count?: number;
}

export interface TypesDiscordTrigger {
  server_name?: string;
}

export enum TypesEffect {
  EffectAllow = "allow",
  EffectDeny = "deny",
}

export interface TypesFirecrawl {
  api_key?: string;
  api_url?: string;
}

export interface TypesGptScriptRequest {
  file_path?: string;
  input?: string;
}

export interface TypesGptScriptResponse {
  error?: string;
  output?: string;
  retries?: number;
}

export interface TypesInteraction {
  completed?: string;
  created?: string;
  /** e.g. User */
  creator?: TypesCreatorType;
  data_prep_chunks?: Record<string, TypesDataPrepChunk[]>;
  /** If true, the data prep is limited to a certain number of chunks due to quotas */
  data_prep_limit?: number;
  /** If true, the data prep is limited to a certain number of chunks due to quotas */
  data_prep_limited?: boolean;
  data_prep_stage?: TypesTextDataPrepStage;
  data_prep_total_chunks?: number;
  /** if this is defined, the UI will always display it instead of the message (so we can augment the internal prompt with RAG context) */
  display_message?: string;
  error?: string;
  /** list of filepath paths */
  files?: string[];
  /** if true, the message has finished being written to, and is ready for a response (e.g. from the other participant) */
  finished?: boolean;
  id?: string;
  /** we hoist this from files so a single interaction knows that it "Created a finetune file" */
  lora_dir?: string;
  /** e.g. Prove pythagoras */
  message?: string;
  /** different modes and models can put values here - for example, the image fine tuning will keep labels here to display in the frontend */
  metadata?: Record<string, string>;
  /**
   * this let's us know if this interaction is part of the fine tuning process
   * or if it's a chat interaction that the user is using to interact with the model
   * once it's been fine-tuned
   * for fine-tune models, we can filter out inference interactions
   * to get down to what actually matters
   */
  mode?: TypesSessionMode;
  /** e.g. 0-100 */
  progress?: number;
  rag_results?: TypesSessionRAGResult[];
  /** e.g. json */
  response_format?: TypesResponseFormat;
  /** the ID of the runner that processed this interaction */
  runner?: string;
  scheduled?: string;
  state?: TypesInteractionState;
  status?: string;
  /** For Role=tool prompts this should be set to the ID given in the assistant's prior request to call a tool. */
  tool_call_id?: string;
  /** For Role=assistant prompts this may be set to the tool calls generated by the model, such as function calls. */
  tool_calls?: GithubComSashabaranovGoOpenaiToolCall[];
  /** This can be either a string or an ToolChoice object. */
  tool_choice?: any;
  /** Model function calling, not to be mistaken with Helix tools */
  tools?: GithubComSashabaranovGoOpenaiTool[];
  updated?: string;
  usage?: GithubComHelixmlHelixApiPkgTypesUsage;
}

export enum TypesInteractionState {
  InteractionStateNone = "",
  InteractionStateWaiting = "waiting",
  InteractionStateEditing = "editing",
  InteractionStateComplete = "complete",
  InteractionStateError = "error",
}

export interface TypesItem {
  b64_json?: string;
  embedding?: number[];
  index?: number;
  object?: string;
  /** Images */
  url?: string;
}

export interface TypesKeyPair {
  privateKey?: string;
  publicKey?: string;
  type?: string;
}

export interface TypesKnowledgeSource {
  filestore?: TypesKnowledgeSourceHelixFilestore;
  gcs?: TypesKnowledgeSourceGCS;
  s3?: TypesKnowledgeSourceS3;
  text?: string;
  web?: TypesKnowledgeSourceWeb;
}

export interface TypesKnowledgeSourceGCS {
  bucket?: string;
  path?: string;
}

export interface TypesKnowledgeSourceHelixFilestore {
  path?: string;
}

export interface TypesKnowledgeSourceS3 {
  bucket?: string;
  path?: string;
}

export interface TypesKnowledgeSourceWeb {
  auth?: TypesKnowledgeSourceWebAuth;
  /** Additional options for the crawler */
  crawler?: TypesWebsiteCrawler;
  excludes?: string[];
  urls?: string[];
}

export interface TypesKnowledgeSourceWebAuth {
  password?: string;
  username?: string;
}

export interface TypesLLMCall {
  app_id?: string;
  completionTokens?: number;
  created?: string;
  duration_ms?: number;
  id?: string;
  interaction_id?: string;
  model?: string;
  original_request?: number[];
  promptTokens?: number;
  provider?: string;
  request?: number[];
  response?: number[];
  session_id?: string;
  step?: TypesLLMCallStep;
  totalTokens?: number;
  updated?: string;
  user_id?: string;
}

export enum TypesLLMCallStep {
  LLMCallStepDefault = "default",
  LLMCallStepIsActionable = "is_actionable",
  LLMCallStepPrepareAPIRequest = "prepare_api_request",
  LLMCallStepInterpretResponse = "interpret_response",
  LLMCallStepGenerateTitle = "generate_title",
}

export interface TypesMessage {
  content?: TypesMessageContent;
  created_at?: string;
  /** Interaction ID */
  id?: string;
  role?: TypesCreatorType;
  state?: TypesInteractionState;
  updated_at?: string;
}

export interface TypesMessageContent {
  /** text, image, multimodal_text */
  content_type?: TypesMessageContentType;
  /**
   * Parts is a list of strings or objects. For example for text, it's a list of strings, for
   * multi-modal it can be an object:
   * "parts": [
   * 		{
   * 				"content_type": "image_asset_pointer",
   * 				"asset_pointer": "file-service://file-28uHss2LgJ8HUEEVAnXa70Tg",
   * 				"size_bytes": 185427,
   * 				"width": 2048,
   * 				"height": 1020,
   * 				"fovea": null,
   * 				"metadata": null
   * 		},
   * 		"what is in the image?"
   * ]
   */
  parts?: any[];
}

export enum TypesMessageContentType {
  MessageContentTypeText = "text",
}

export interface TypesOpenAIMessage {
  /** The message content */
  content?: string;
  /** The message role */
  role?: string;
  /** For Role=tool prompts this should be set to the ID given in the assistant's prior request to call a tool. */
  tool_call_id?: string;
  /** For Role=assistant prompts this may be set to the tool calls generated by the model, such as function calls. */
  tool_calls?: GithubComSashabaranovGoOpenaiToolCall[];
}

export interface TypesOpenAIResponse {
  choices?: TypesChoice[];
  created?: number;
  data?: TypesItem[];
  id?: string;
  model?: string;
  object?: string;
  usage?: TypesOpenAIUsage;
}

export interface TypesOpenAIUsage {
  completion_tokens?: number;
  prompt_tokens?: number;
  total_tokens?: number;
}

export interface TypesOrganization {
  created_at?: string;
  deleted_at?: GormDeletedAt;
  display_name?: string;
  id?: string;
  /** Memberships in the organization */
  memberships?: TypesOrganizationMembership[];
  name?: string;
  /** Who created the org */
  owner?: string;
  /** Roles in the organization */
  roles?: TypesRole[];
  /** Teams in the organization */
  teams?: TypesTeam[];
  updated_at?: string;
}

export interface TypesOrganizationMembership {
  created_at?: string;
  organization_id?: string;
  /** Role - the role of the user in the organization (owner or member) */
  role?: TypesOrganizationRole;
  updated_at?: string;
  user?: TypesUser;
  /** composite key */
  user_id?: string;
}

export enum TypesOrganizationRole {
  OrganizationRoleOwner = "owner",
  OrganizationRoleMember = "member",
}

export enum TypesOwnerType {
  OwnerTypeUser = "user",
  OwnerTypeRunner = "runner",
  OwnerTypeSystem = "system",
  OwnerTypeSocket = "socket",
}

export interface TypesPaginatedLLMCalls {
  calls?: TypesLLMCall[];
  page?: number;
  pageSize?: number;
  totalCount?: number;
  totalPages?: number;
}

export enum TypesProvider {
  ProviderOpenAI = "openai",
  ProviderTogetherAI = "togetherai",
  ProviderHelix = "helix",
  ProviderVLLM = "vllm",
}

export interface TypesProviderEndpoint {
  api_key?: string;
  /** Must be mounted to the container */
  api_key_file?: string;
  base_url?: string;
  created?: string;
  /** Set from environment variable */
  default?: boolean;
  description?: string;
  /** global, user (TODO: orgs, teams) */
  endpoint_type?: TypesProviderEndpointType;
  id?: string;
  /** Optional */
  models?: string[];
  name?: string;
  owner?: string;
  /** user, system, org */
  owner_type?: TypesOwnerType;
  updated?: string;
}

export enum TypesProviderEndpointType {
  ProviderEndpointTypeGlobal = "global",
  ProviderEndpointTypeUser = "user",
}

export interface TypesRAGSettings {
  /** the amount of overlap between chunks - will default to 32 bytes */
  chunk_overflow?: number;
  /** the size of each text chunk - will default to 2000 bytes */
  chunk_size?: number;
  /** the URL of the delete endpoint (defaults to Helix RAG_DELETE_URL env var) */
  delete_url?: string;
  /** if true, we will not chunk the text and send the entire file to the RAG indexing endpoint */
  disable_chunking?: boolean;
  /** if true, we will not download the file and send the URL to the RAG indexing endpoint */
  disable_downloading?: boolean;
  /** this is one of l2, inner_product or cosine - will default to cosine */
  distance_function?: string;
  /** RAG endpoint configuration if used with a custom RAG service */
  index_url?: string;
  /** the prompt template to use for the RAG query */
  prompt_template?: string;
  /** the URL of the query endpoint (defaults to Helix RAG_QUERY_URL env var) */
  query_url?: string;
  /** this is the max number of results to return - will default to 3 */
  results_count?: number;
  /** Markdown if empty or 'text' */
  text_splitter?: TypesTextSplitterType;
  /** this is the threshold for a "good" answer - will default to 0.2 */
  threshold?: number;
  typesense?: {
    api_key?: string;
    collection?: string;
    url?: string;
  };
}

export enum TypesResource {
  ResourceTeam = "Team",
  ResourceOrganization = "Organization",
  ResourceRole = "Role",
  ResourceMembership = "Membership",
  ResourceMembershipRoleBinding = "MembershipRoleBinding",
  ResourceApplication = "Application",
  ResourceAccessGrants = "AccessGrants",
  ResourceKnowledge = "Knowledge",
  ResourceUser = "User",
  ResourceAny = "*",
  ResourceTypeDataset = "Dataset",
}

export interface TypesResponseFormat {
  schema?: OpenaiChatCompletionResponseFormatJSONSchema;
  type?: TypesResponseFormatType;
}

export enum TypesResponseFormatType {
  ResponseFormatTypeJSONObject = "json_object",
  ResponseFormatTypeText = "text",
}

export interface TypesRole {
  config?: GithubComHelixmlHelixApiPkgTypesConfig;
  created_at?: string;
  description?: string;
  id?: string;
  name?: string;
  organization_id?: string;
  updated_at?: string;
}

export interface TypesRule {
  actions?: TypesAction[];
  effect?: TypesEffect;
  resource?: TypesResource[];
}

export interface TypesRunAPIActionRequest {
  action?: string;
  parameters?: Record<string, string>;
}

export interface TypesRunAPIActionResponse {
  error?: string;
  /** Raw response from the API */
  response?: string;
}

export interface TypesSecret {
  /** optional, if set, the secret will be available to the specified app */
  app_id?: string;
  created?: string;
  id?: string;
  name?: string;
  owner?: string;
  ownerType?: TypesOwnerType;
  updated?: string;
  value?: number[];
}

export interface TypesSession {
  /** named config for backward compat */
  config?: TypesSessionMetadata;
  created?: string;
  id?: string;
  /**
   * for now we just whack the entire history of the interaction in here, json
   * style
   */
  interactions?: TypesInteraction[];
  /**
   * if type == finetune, we record a filestore path to e.g. lora file here
   * currently the only place you can do inference on a finetune is within the
   * session where the finetune was generated
   */
  lora_dir?: string;
  /** e.g. inference, finetune */
  mode?: TypesSessionMode;
  /**
   * huggingface model name e.g. mistralai/Mistral-7B-Instruct-v0.1 or
   * stabilityai/stable-diffusion-xl-base-1.0
   */
  model_name?: string;
  /**
   * name that goes in the UI - ideally autogenerated by AI but for now can be
   * named manually
   */
  name?: string;
  /** uuid of owner entity */
  owner?: string;
  /** e.g. user, system, org */
  owner_type?: TypesOwnerType;
  /** the app this session was spawned from */
  parent_app?: string;
  parent_session?: string;
  /** e.g. text, image */
  type?: TypesSessionType;
  updated?: string;
}

export interface TypesSessionChatRequest {
  /** Assign the session settings from the specified app */
  app_id?: string;
  /** Which assistant are we speaking to? */
  assistant_id?: string;
  lora_dir?: string;
  /** the fine tuned data entity we produced from this session */
  lora_id?: string;
  /** Initial messages */
  messages?: TypesMessage[];
  /** The model to use */
  model?: string;
  /** The provider to use */
  provider?: TypesProvider;
  rag_source_id?: string;
  /** If empty, we will start a new session */
  session_id?: string;
  /** If true, we will stream the response */
  stream?: boolean;
  /** System message, only applicable when starting a new session */
  system?: string;
  /** Available tools to use in the session */
  tools?: string[];
  /** e.g. text, image */
  type?: TypesSessionType;
}

export interface TypesSessionLearnRequest {
  /** FINE-TUNE MODE ONLY */
  data_entity_id?: string;
  /** When doing RAG, allow the resulting inference session model to be specified */
  default_rag_model?: string;
  /**
   * Do we want to create a RAG data entity from this session?
   * You must provide a data entity ID for the uploaded documents if yes
   */
  rag_enabled?: boolean;
  /** The settings we use for the RAG source */
  rag_settings?: TypesRAGSettings;
  /**
   * Do we want to create a lora output from this session?
   * You must provide a data entity ID for the uploaded documents if yes
   */
  text_finetune_enabled?: boolean;
  /** e.g. text, image */
  type?: TypesSessionType;
}

export interface TypesSessionMetadata {
  active_tools?: string[];
  /** Passing through user defined app params */
  app_query_params?: Record<string, string>;
  /** which assistant are we talking to? */
  assistant_id?: string;
  avatar?: string;
  document_group_id?: string;
  document_ids?: Record<string, string>;
  eval_automatic_reason?: string;
  eval_automatic_score?: string;
  eval_manual_reason?: string;
  eval_manual_score?: string;
  eval_original_user_prompts?: string[];
  /**
   * Evals are cool. Scores are strings of floats so we can distinguish ""
   * (not rated) from "0.0"
   */
  eval_run_id?: string;
  eval_user_reason?: string;
  eval_user_score?: string;
  /** the fine tuned data entity we produced from this session */
  finetune_data_entity_id?: string;
  helix_version?: string;
  manually_review_questions?: boolean;
  origin?: TypesSessionOrigin;
  original_mode?: TypesSessionMode;
  priority?: boolean;
  /**
   * these settings control which features of a session we want to use
   * even if we have a Lora file and RAG indexed prepared
   * we might choose to not use them (this will help our eval framework know what works the best)
   * we well as activate RAG - we also get to control some properties, e.g. which distance function to use,
   * and what the threshold for a "good" answer is
   */
  rag_enabled?: boolean;
  rag_settings?: TypesRAGSettings;
  /** the RAG source data entity we produced from this session */
  rag_source_data_entity_id?: string;
  shared?: boolean;
  stream?: boolean;
  system_prompt?: string;
  /** without any user input, this will default to true */
  text_finetune_enabled?: boolean;
  /** when we do fine tuning or RAG, we need to know which data entity we used */
  uploaded_data_entity_id?: string;
}

export enum TypesSessionMode {
  SessionModeNone = "",
  SessionModeInference = "inference",
  SessionModeFinetune = "finetune",
  SessionModeAction = "action",
}

export interface TypesSessionOrigin {
  cloned_interaction_id?: string;
  cloned_session_id?: string;
  type?: TypesSessionOriginType;
}

export enum TypesSessionOriginType {
  SessionOriginTypeNone = "",
  SessionOriginTypeUserCreated = "user_created",
  SessionOriginTypeCloned = "cloned",
}

export interface TypesSessionRAGResult {
  content?: string;
  content_offset?: number;
  distance?: number;
  document_group_id?: string;
  document_id?: string;
  filename?: string;
  id?: string;
  interaction_id?: string;
  session_id?: string;
  source?: string;
}

export enum TypesSessionType {
  SessionTypeNone = "",
  SessionTypeText = "text",
  SessionTypeImage = "image",
}

export interface TypesTeam {
  created_at?: string;
  deleted_at?: GormDeletedAt;
  id?: string;
  /** Memberships in the team */
  memberships?: TypesTeamMembership[];
  name?: string;
  organization_id?: string;
  updated_at?: string;
}

export interface TypesTeamMembership {
  created_at?: string;
  organization_id?: string;
  team?: TypesTeam;
  team_id?: string;
  updated_at?: string;
  /** extra data fields (optional) */
  user?: TypesUser;
  /** composite key */
  user_id?: string;
}

export interface TypesTestStep {
  expected_output?: string;
  prompt?: string;
}

export enum TypesTextDataPrepStage {
  TextDataPrepStageNone = "",
  TextDataPrepStageEditFiles = "edit_files",
  TextDataPrepStageExtractText = "extract_text",
  TextDataPrepStageIndexRag = "index_rag",
  TextDataPrepStageGenerateQuestions = "generate_questions",
  TextDataPrepStageEditQuestions = "edit_questions",
  TextDataPrepStageFineTune = "finetune",
  TextDataPrepStageComplete = "complete",
}

export enum TypesTextSplitterType {
  TextSplitterTypeMarkdown = "markdown",
  TextSplitterTypeText = "text",
}

export enum TypesTokenType {
  TokenTypeNone = "",
  TokenTypeRunner = "runner",
  TokenTypeKeycloak = "keycloak",
  TokenTypeAPIKey = "api_key",
  TokenTypeSocket = "socket",
}

export interface TypesToolAPIAction {
  description?: string;
  method?: string;
  name?: string;
  path?: string;
}

export interface TypesToolAPIConfig {
  /** Read-only, parsed from schema on creation */
  actions?: TypesToolAPIAction[];
  /** Headers (authentication, etc) */
  headers?: Record<string, string>;
  model?: string;
  /** Query parameters that will be always set */
  query?: Record<string, string>;
  /** Template for request preparation, leave empty for default */
  request_prep_template?: string;
  /** Template for error response, leave empty for default */
  response_error_template?: string;
  /** Template for successful response, leave empty for default */
  response_success_template?: string;
  schema?: string;
  /** Server override */
  url?: string;
}

export interface TypesToolConfig {
  api?: TypesToolAPIConfig;
  gptscript?: TypesToolGPTScriptConfig;
  zapier?: TypesToolZapierConfig;
}

export interface TypesToolGPTScriptConfig {
  /** Program code */
  script?: string;
  /** URL to download the script */
  script_url?: string;
}

export interface TypesToolZapierConfig {
  api_key?: string;
  max_iterations?: number;
  model?: string;
}

export interface TypesTrigger {
  cron?: TypesCronTrigger;
  discord?: TypesDiscordTrigger;
}

export interface TypesUpdateOrganizationMemberRequest {
  role?: TypesOrganizationRole;
}

export interface TypesUpdateProviderEndpoint {
  api_key?: string;
  /** Must be mounted to the container */
  api_key_file?: string;
  base_url?: string;
  description?: string;
  /** global, user (TODO: orgs, teams) */
  endpoint_type?: TypesProviderEndpointType;
  models?: string[];
}

export interface TypesUpdateTeamRequest {
  name?: string;
}

export interface TypesUser {
  /** if the ID of the user is contained in the env setting */
  admin?: boolean;
  /** if the token is associated with an app */
  appID?: string;
  created_at?: string;
  deleted_at?: GormDeletedAt;
  email?: string;
  fullName?: string;
  id?: string;
  /** the actual token used and its type */
  token?: string;
  /** none, runner. keycloak, api_key */
  tokenType?: TypesTokenType;
  /**
   * these are set by the keycloak user based on the token
   * if it's an app token - the keycloak user is loaded from the owner of the app
   * if it's a runner token - these values will be empty
   */
  type?: TypesOwnerType;
  updated_at?: string;
  username?: string;
}

export interface TypesWebsiteCrawler {
  enabled?: boolean;
  firecrawl?: TypesFirecrawl;
  ignore_robots_txt?: boolean;
  /** Limit crawl depth to avoid infinite crawling */
  max_depth?: number;
  /** Apply readability middleware to the HTML content */
  readability?: boolean;
  user_agent?: string;
}

import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, HeadersDefaults, ResponseType } from "axios";
import axios from "axios";

export type QueryParamsType = Record<string | number, any>;

export interface FullRequestParams extends Omit<AxiosRequestConfig, "data" | "params" | "url" | "responseType"> {
  /** set parameter to `true` for call `securityWorker` for this request */
  secure?: boolean;
  /** request path */
  path: string;
  /** content type of request body */
  type?: ContentType;
  /** query params */
  query?: QueryParamsType;
  /** format of response (i.e. response.json() -> format: "json") */
  format?: ResponseType;
  /** request body */
  body?: unknown;
}

export type RequestParams = Omit<FullRequestParams, "body" | "method" | "query" | "path">;

export interface ApiConfig<SecurityDataType = unknown> extends Omit<AxiosRequestConfig, "data" | "cancelToken"> {
  securityWorker?: (
    securityData: SecurityDataType | null,
  ) => Promise<AxiosRequestConfig | void> | AxiosRequestConfig | void;
  secure?: boolean;
  format?: ResponseType;
}

export enum ContentType {
  Json = "application/json",
  FormData = "multipart/form-data",
  UrlEncoded = "application/x-www-form-urlencoded",
  Text = "text/plain",
}

export class HttpClient<SecurityDataType = unknown> {
  public instance: AxiosInstance;
  private securityData: SecurityDataType | null = null;
  private securityWorker?: ApiConfig<SecurityDataType>["securityWorker"];
  private secure?: boolean;
  private format?: ResponseType;

  constructor({ securityWorker, secure, format, ...axiosConfig }: ApiConfig<SecurityDataType> = {}) {
    this.instance = axios.create({ ...axiosConfig, baseURL: axiosConfig.baseURL || "https://app.tryhelix.ai" });
    this.secure = secure;
    this.format = format;
    this.securityWorker = securityWorker;
  }

  public setSecurityData = (data: SecurityDataType | null) => {
    this.securityData = data;
  };

  protected mergeRequestParams(params1: AxiosRequestConfig, params2?: AxiosRequestConfig): AxiosRequestConfig {
    const method = params1.method || (params2 && params2.method);

    return {
      ...this.instance.defaults,
      ...params1,
      ...(params2 || {}),
      headers: {
        ...((method && this.instance.defaults.headers[method.toLowerCase() as keyof HeadersDefaults]) || {}),
        ...(params1.headers || {}),
        ...((params2 && params2.headers) || {}),
      },
    };
  }

  protected stringifyFormItem(formItem: unknown) {
    if (typeof formItem === "object" && formItem !== null) {
      return JSON.stringify(formItem);
    } else {
      return `${formItem}`;
    }
  }

  protected createFormData(input: Record<string, unknown>): FormData {
    if (input instanceof FormData) {
      return input;
    }
    return Object.keys(input || {}).reduce((formData, key) => {
      const property = input[key];
      const propertyContent: any[] = property instanceof Array ? property : [property];

      for (const formItem of propertyContent) {
        const isFileType = formItem instanceof Blob || formItem instanceof File;
        formData.append(key, isFileType ? formItem : this.stringifyFormItem(formItem));
      }

      return formData;
    }, new FormData());
  }

  public request = async <T = any, _E = any>({
    secure,
    path,
    type,
    query,
    format,
    body,
    ...params
  }: FullRequestParams): Promise<AxiosResponse<T>> => {
    const secureParams =
      ((typeof secure === "boolean" ? secure : this.secure) &&
        this.securityWorker &&
        (await this.securityWorker(this.securityData))) ||
      {};
    const requestParams = this.mergeRequestParams(params, secureParams);
    const responseFormat = format || this.format || undefined;

    if (type === ContentType.FormData && body && body !== null && typeof body === "object") {
      body = this.createFormData(body as Record<string, unknown>);
    }

    if (type === ContentType.Text && body && body !== null && typeof body !== "string") {
      body = JSON.stringify(body);
    }

    return this.instance.request({
      ...requestParams,
      headers: {
        ...(requestParams.headers || {}),
        ...(type ? { "Content-Type": type } : {}),
      },
      params: query,
      responseType: responseFormat,
      data: body,
      url: path,
    });
  };
}

/**
 * @title HelixML API reference
 * @version 0.1
 * @baseUrl https://app.tryhelix.ai
 * @contact Helix support <info@helix.ml> (https://app.tryhelix.ai/)
 *
 * This is a HelixML AI API.
 */
export class Api<SecurityDataType extends unknown> extends HttpClient<SecurityDataType> {
  api = {
    /**
     * No description
     *
     * @name V1AppsList
     * @request GET:/api/v1/apps
     * @secure
     */
    v1AppsList: (
      query?: {
        /** Organization ID */
        organization_id?: string;
      },
      params: RequestParams = {},
    ) =>
      this.request<TypesApp[], any>({
        path: `/api/v1/apps`,
        method: "GET",
        query: query,
        secure: true,
        ...params,
      }),

    /**
     * No description
     *
     * @name V1AppsCreate
     * @request POST:/api/v1/apps
     * @secure
     */
    v1AppsCreate: (request: TypesApp, params: RequestParams = {}) =>
      this.request<TypesApp, any>({
        path: `/api/v1/apps`,
        method: "POST",
        body: request,
        secure: true,
        ...params,
      }),

    /**
     * No description
     *
     * @name V1AppsDelete
     * @request DELETE:/api/v1/apps/{id}
     * @secure
     */
    v1AppsDelete: (id: string, params: RequestParams = {}) =>
      this.request<void, any>({
        path: `/api/v1/apps/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * No description
     *
     * @name V1AppsDetail
     * @request GET:/api/v1/apps/{id}
     * @secure
     */
    v1AppsDetail: (id: string, params: RequestParams = {}) =>
      this.request<TypesApp, any>({
        path: `/api/v1/apps/${id}`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * No description
     *
     * @name V1AppsUpdate
     * @request PUT:/api/v1/apps/{id}
     * @secure
     */
    v1AppsUpdate: (id: string, request: TypesApp, params: RequestParams = {}) =>
      this.request<TypesApp, any>({
        path: `/api/v1/apps/${id}`,
        method: "PUT",
        body: request,
        secure: true,
        ...params,
      }),

    /**
     * @description List access grants for an app (organization owners and members can list access grants)
     *
     * @tags apps
     * @name V1AppsAccessGrantsDetail
     * @summary List app access grants
     * @request GET:/api/v1/apps/{id}/access-grants
     * @secure
     */
    v1AppsAccessGrantsDetail: (id: string, params: RequestParams = {}) =>
      this.request<TypesAccessGrant[], any>({
        path: `/api/v1/apps/${id}/access-grants`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description Grant access to an app to a team or organization member (organization owners can grant access to teams and organization members)
     *
     * @tags apps
     * @name V1AppsAccessGrantsCreate
     * @summary Grant access to an app to a team or organization member
     * @request POST:/api/v1/apps/{id}/access-grants
     * @secure
     */
    v1AppsAccessGrantsCreate: (id: string, request: TypesCreateAccessGrantRequest, params: RequestParams = {}) =>
      this.request<TypesAccessGrant, any>({
        path: `/api/v1/apps/${id}/access-grants`,
        method: "POST",
        body: request,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * No description
     *
     * @name V1AppsApiActionsCreate
     * @request POST:/api/v1/apps/{id}/api-actions
     * @secure
     */
    v1AppsApiActionsCreate: (id: string, request: TypesRunAPIActionRequest, params: RequestParams = {}) =>
      this.request<TypesRunAPIActionResponse, any>({
        path: `/api/v1/apps/${id}/api-actions`,
        method: "POST",
        body: request,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * No description
     *
     * @name V1AppsGptscriptCreate
     * @request POST:/api/v1/apps/{id}/gptscript
     * @secure
     */
    v1AppsGptscriptCreate: (id: string, request: TypesGptScriptRequest, params: RequestParams = {}) =>
      this.request<TypesGptScriptResponse, any>({
        path: `/api/v1/apps/${id}/gptscript`,
        method: "POST",
        body: request,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * No description
     *
     * @name V1AppsGithubUpdate
     * @request PUT:/api/v1/apps/github/{id}
     * @secure
     */
    v1AppsGithubUpdate: (id: string, request: TypesApp, params: RequestParams = {}) =>
      this.request<TypesApp, any>({
        path: `/api/v1/apps/github/${id}`,
        method: "PUT",
        body: request,
        secure: true,
        ...params,
      }),

    /**
     * @description List user's LLM calls with pagination and optional session filtering for a specific app
     *
     * @tags llm_calls
     * @name V1LlmCallsList
     * @summary List LLM calls
     * @request GET:/api/v1/llm_calls
     * @secure
     */
    v1LlmCallsList: (
      query?: {
        /** Page number */
        page?: number;
        /** Page size */
        pageSize?: number;
        /** Filter by session ID */
        sessionFilter?: string;
      },
      params: RequestParams = {},
    ) =>
      this.request<TypesPaginatedLLMCalls, any>({
        path: `/api/v1/llm_calls`,
        method: "GET",
        query: query,
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @name V1OrganizationsList
     * @request GET:/api/v1/organizations
     * @secure
     */
    v1OrganizationsList: (params: RequestParams = {}) =>
      this.request<TypesOrganization[], any>({
        path: `/api/v1/organizations`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description Create a new organization
     *
     * @tags organizations
     * @name V1OrganizationsCreate
     * @summary Create a new organization
     * @request POST:/api/v1/organizations
     * @secure
     */
    v1OrganizationsCreate: (request: TypesOrganization, params: RequestParams = {}) =>
      this.request<TypesOrganization, any>({
        path: `/api/v1/organizations`,
        method: "POST",
        body: request,
        secure: true,
        ...params,
      }),

    /**
     * No description
     *
     * @name V1OrganizationsDelete
     * @request DELETE:/api/v1/organizations/{id}
     * @secure
     */
    v1OrganizationsDelete: (id: string, params: RequestParams = {}) =>
      this.request<TypesOrganization, any>({
        path: `/api/v1/organizations/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * No description
     *
     * @name V1OrganizationsDetail
     * @request GET:/api/v1/organizations/{id}
     */
    v1OrganizationsDetail: (id: string, params: RequestParams = {}) =>
      this.request<TypesOrganization, any>({
        path: `/api/v1/organizations/${id}`,
        method: "GET",
        ...params,
      }),

    /**
     * @description Update an organization, must be an owner of the organization
     *
     * @tags organizations
     * @name V1OrganizationsUpdate
     * @summary Update an organization
     * @request PUT:/api/v1/organizations/{id}
     * @secure
     */
    v1OrganizationsUpdate: (id: string, request: TypesOrganization, params: RequestParams = {}) =>
      this.request<TypesOrganization, any>({
        path: `/api/v1/organizations/${id}`,
        method: "PUT",
        body: request,
        secure: true,
        ...params,
      }),

    /**
     * @description List members of an organization
     *
     * @tags organizations
     * @name V1OrganizationsMembersDetail
     * @summary List organization members
     * @request GET:/api/v1/organizations/{id}/members
     * @secure
     */
    v1OrganizationsMembersDetail: (id: string, params: RequestParams = {}) =>
      this.request<TypesOrganizationMembership[], any>({
        path: `/api/v1/organizations/${id}/members`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description Add a member to an organization
     *
     * @tags organizations
     * @name V1OrganizationsMembersCreate
     * @summary Add an organization member
     * @request POST:/api/v1/organizations/{id}/members
     * @secure
     */
    v1OrganizationsMembersCreate: (
      id: string,
      request: TypesAddOrganizationMemberRequest,
      params: RequestParams = {},
    ) =>
      this.request<TypesOrganizationMembership, any>({
        path: `/api/v1/organizations/${id}/members`,
        method: "POST",
        body: request,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description Remove a member from an organization
     *
     * @tags organizations
     * @name V1OrganizationsMembersDelete
     * @summary Remove an organization member
     * @request DELETE:/api/v1/organizations/{id}/members/{user_id}
     * @secure
     */
    v1OrganizationsMembersDelete: (id: string, userId: string, params: RequestParams = {}) =>
      this.request<void, any>({
        path: `/api/v1/organizations/${id}/members/${userId}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * @description Update a member's role in an organization
     *
     * @tags organizations
     * @name V1OrganizationsMembersUpdate
     * @summary Update an organization member
     * @request PUT:/api/v1/organizations/{id}/members/{user_id}
     * @secure
     */
    v1OrganizationsMembersUpdate: (
      id: string,
      userId: string,
      request: TypesUpdateOrganizationMemberRequest,
      params: RequestParams = {},
    ) =>
      this.request<TypesOrganizationMembership, any>({
        path: `/api/v1/organizations/${id}/members/${userId}`,
        method: "PUT",
        body: request,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description List all roles in an organization. Organization members can list roles.
     *
     * @tags organizations
     * @name V1OrganizationsRolesDetail
     * @summary List roles in an organization
     * @request GET:/api/v1/organizations/{id}/roles
     * @secure
     */
    v1OrganizationsRolesDetail: (id: string, params: RequestParams = {}) =>
      this.request<TypesRole[], any>({
        path: `/api/v1/organizations/${id}/roles`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description List all teams in an organization. Organization members can list teams.
     *
     * @tags organizations
     * @name V1OrganizationsTeamsDetail
     * @summary List teams in an organization
     * @request GET:/api/v1/organizations/{id}/teams
     * @secure
     */
    v1OrganizationsTeamsDetail: (id: string, params: RequestParams = {}) =>
      this.request<TypesTeam[], any>({
        path: `/api/v1/organizations/${id}/teams`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description Create a new team in an organization. Only organization owners can create teams.
     *
     * @tags organizations
     * @name V1OrganizationsTeamsCreate
     * @summary Create a new team
     * @request POST:/api/v1/organizations/{id}/teams
     * @secure
     */
    v1OrganizationsTeamsCreate: (id: string, request: TypesCreateTeamRequest, params: RequestParams = {}) =>
      this.request<TypesTeam, any>({
        path: `/api/v1/organizations/${id}/teams`,
        method: "POST",
        body: request,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * @description Delete a team from an organization. Only organization owners can delete teams.
     *
     * @tags organizations
     * @name V1OrganizationsTeamsDelete
     * @summary Delete a team
     * @request DELETE:/api/v1/organizations/{id}/teams/{team_id}
     * @secure
     */
    v1OrganizationsTeamsDelete: (id: string, teamId: string, params: RequestParams = {}) =>
      this.request<void, any>({
        path: `/api/v1/organizations/${id}/teams/${teamId}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * @description Update a team's details. Only organization owners can update teams.
     *
     * @tags organizations
     * @name V1OrganizationsTeamsUpdate
     * @summary Update a team
     * @request PUT:/api/v1/organizations/{id}/teams/{team_id}
     * @secure
     */
    v1OrganizationsTeamsUpdate: (
      id: string,
      teamId: string,
      request: TypesUpdateTeamRequest,
      params: RequestParams = {},
    ) =>
      this.request<TypesTeam, any>({
        path: `/api/v1/organizations/${id}/teams/${teamId}`,
        method: "PUT",
        body: request,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * @description List all members of a team.
     *
     * @tags organizations
     * @name V1OrganizationsTeamsMembersDetail
     * @summary List members of a team
     * @request GET:/api/v1/organizations/{id}/teams/{team_id}/members
     * @secure
     */
    v1OrganizationsTeamsMembersDetail: (id: string, teamId: string, params: RequestParams = {}) =>
      this.request<TypesTeamMembership[], any>({
        path: `/api/v1/organizations/${id}/teams/${teamId}/members`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description Add a new member to a team. Only organization owners can add members to teams.
     *
     * @tags organizations
     * @name V1OrganizationsTeamsMembersCreate
     * @summary Add a new member to a team
     * @request POST:/api/v1/organizations/{id}/teams/{team_id}/members
     * @secure
     */
    v1OrganizationsTeamsMembersCreate: (
      id: string,
      teamId: string,
      request: TypesAddTeamMemberRequest,
      params: RequestParams = {},
    ) =>
      this.request<TypesTeamMembership, any>({
        path: `/api/v1/organizations/${id}/teams/${teamId}/members`,
        method: "POST",
        body: request,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @name V1ProvidersList
     * @request GET:/api/v1/providers
     * @secure
     */
    v1ProvidersList: (params: RequestParams = {}) =>
      this.request<TypesProvider[], any>({
        path: `/api/v1/providers`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * No description
     *
     * @name V1ProvidersEndpointsList
     * @request GET:/api/v1/providers-endpoints
     * @secure
     */
    v1ProvidersEndpointsList: (params: RequestParams = {}) =>
      this.request<TypesProviderEndpoint[], any>({
        path: `/api/v1/providers-endpoints`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * No description
     *
     * @name V1ProvidersEndpointsCreate
     * @request POST:/api/v1/providers-endpoints
     * @secure
     */
    v1ProvidersEndpointsCreate: (params: RequestParams = {}) =>
      this.request<TypesProviderEndpoint, any>({
        path: `/api/v1/providers-endpoints`,
        method: "POST",
        secure: true,
        ...params,
      }),

    /**
     * No description
     *
     * @name V1ProvidersEndpointsDelete
     * @request DELETE:/api/v1/providers-endpoints/{id}
     * @secure
     */
    v1ProvidersEndpointsDelete: (id: string, params: RequestParams = {}) =>
      this.request<void, any>({
        path: `/api/v1/providers-endpoints/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * No description
     *
     * @name V1ProvidersEndpointsUpdate
     * @request PUT:/api/v1/providers-endpoints/{id}
     * @secure
     */
    v1ProvidersEndpointsUpdate: (id: string, params: RequestParams = {}) =>
      this.request<TypesUpdateProviderEndpoint, any>({
        path: `/api/v1/providers-endpoints/${id}`,
        method: "PUT",
        secure: true,
        ...params,
      }),

    /**
     * @description List secrets for the user.
     *
     * @tags secrets
     * @name V1SecretsList
     * @summary List secrets
     * @request GET:/api/v1/secrets
     * @secure
     */
    v1SecretsList: (params: RequestParams = {}) =>
      this.request<TypesSecret[], any>({
        path: `/api/v1/secrets`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description Create a new secret for the user.
     *
     * @tags secrets
     * @name V1SecretsCreate
     * @summary Create new secret
     * @request POST:/api/v1/secrets
     * @secure
     */
    v1SecretsCreate: (request: TypesSecret, params: RequestParams = {}) =>
      this.request<TypesSecret, any>({
        path: `/api/v1/secrets`,
        method: "POST",
        body: request,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description Delete a secret for the user.
     *
     * @tags secrets
     * @name V1SecretsDelete
     * @summary Delete a secret
     * @request DELETE:/api/v1/secrets/{id}
     * @secure
     */
    v1SecretsDelete: (id: string, params: RequestParams = {}) =>
      this.request<TypesSecret, any>({
        path: `/api/v1/secrets/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * @description Update an existing secret for the user.
     *
     * @tags secrets
     * @name V1SecretsUpdate
     * @summary Update an existing secret
     * @request PUT:/api/v1/secrets/{id}
     * @secure
     */
    v1SecretsUpdate: (id: string, request: TypesSecret, params: RequestParams = {}) =>
      this.request<TypesSecret, any>({
        path: `/api/v1/secrets/${id}`,
        method: "PUT",
        body: request,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * No description
     *
     * @name V1SessionsChatCreate
     * @request POST:/api/v1/sessions/chat
     * @secure
     */
    v1SessionsChatCreate: (request: TypesSessionChatRequest, params: RequestParams = {}) =>
      this.request<TypesOpenAIResponse, any>({
        path: `/api/v1/sessions/chat`,
        method: "POST",
        body: request,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * No description
     *
     * @name V1SessionsLearnCreate
     * @request POST:/api/v1/sessions/learn
     * @secure
     */
    v1SessionsLearnCreate: (request: TypesSessionLearnRequest, params: RequestParams = {}) =>
      this.request<TypesSession, any>({
        path: `/api/v1/sessions/learn`,
        method: "POST",
        body: request,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),
  };
  v1 = {
    /**
     * @description Creates a model response for the given chat conversation.
     *
     * @tags chat
     * @name ChatCompletionsCreate
     * @summary Stream responses for chat
     * @request POST:/v1/chat/completions
     * @secure
     */
    chatCompletionsCreate: (request: GithubComSashabaranovGoOpenaiChatCompletionRequest, params: RequestParams = {}) =>
      this.request<GithubComSashabaranovGoOpenaiChatCompletionResponse, any>({
        path: `/v1/chat/completions`,
        method: "POST",
        body: request,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description Creates an embedding vector representing the input text
     *
     * @tags embeddings
     * @name EmbeddingsCreate
     * @summary Creates an embedding vector representing the input text
     * @request POST:/v1/embeddings
     * @secure
     */
    embeddingsCreate: (request: OpenaiEmbeddingRequest, params: RequestParams = {}) =>
      this.request<OpenaiEmbeddingResponse, any>({
        path: `/v1/embeddings`,
        method: "POST",
        body: request,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),
  };
}
