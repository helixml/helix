import React, { useState, useEffect, useMemo, useCallback } from 'react';
import {
  Box,
  Typography,
  Card,
  CardContent,
  CardHeader,
  Grid,
  Button,
  Chip,
  LinearProgress,
  CircularProgress,
  Alert,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  TextField,
  IconButton,
  Collapse,
  Stack,
  Divider,
  Badge,
  Tooltip,
  Menu,
  MenuItem,
  Select,
  FormControl,
  InputLabel,
  Avatar,
} from '@mui/material';
import {
  Add as AddIcon,
  ExpandMore as ExpandMoreIcon,
  ExpandLess as ExpandLessIcon,
  GitBranch as GitIcon,
  Description as SpecIcon,
  PlayArrow as PlayIcon,
  CheckCircle as ApproveIcon,
  Cancel as CancelIcon,
  MoreVert as MoreIcon,
  Code as CodeIcon,
  Timeline as TimelineIcon,
  AccountTree as TreeIcon,
  Visibility as ViewIcon,
  Edit as EditIcon,
  Delete as DeleteIcon,
} from '@mui/icons-material';
import { DragDropContext, Droppable, Draggable, DropResult } from 'react-beautiful-dnd';
import { useTheme } from '@mui/material/styles';
import { format, formatDistanceToNow } from 'date-fns';

import useApi from '../../hooks/useApi';
import useAccount from '../../hooks/useAccount';
import specTaskService, {
  SpecTask,
  MultiSessionOverview,
  useSpecTask,
  useMultiSessionOverview,
} from '../../services/specTaskService';

// SpecTask types and statuses
type SpecTaskPhase = 'backlog' | 'planning' | 'review' | 'implementation' | 'completed';
type SpecTaskPriority = 'low' | 'medium' | 'high' | 'critical';

interface SpecTaskWithExtras extends SpecTask {
  hasSpecs: boolean;
  planningStatus?: 'none' | 'active' | 'pending_review' | 'completed' | 'failed';
  gitRepositoryId?: string;
  gitRepositoryUrl?: string;
  multiSessionOverview?: MultiSessionOverview;
  lastActivity?: string;
  activeSessionsCount?: number;
  completedSessionsCount?: number;
  specApprovalNeeded?: boolean;
}

interface KanbanColumn {
  id: SpecTaskPhase;
  title: string;
  color: string;
  backgroundColor: string;
  description: string;
  limit?: number;
  tasks: SpecTaskWithExtras[];
}

interface SpecTaskKanbanBoardProps {
  projectId?: string;
  userId?: string;
  onTaskClick?: (task: SpecTaskWithExtras) => void;
}

const SpecTaskKanbanBoard: React.FC<SpecTaskKanbanBoardProps> = ({
  projectId,
  userId,
  onTaskClick,
}) => {
  const theme = useTheme();
  const api = useApi();
  const account = useAccount();

  // State
  const [tasks, setTasks] = useState<SpecTaskWithExtras[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [createDialogOpen, setCreateDialogOpen] = useState(false);
  const [planningDialogOpen, setPlanningDialogOpen] = useState(false);
  const [selectedTask, setSelectedTask] = useState<SpecTaskWithExtras | null>(null);
  const [refreshing, setRefreshing] = useState(false);

  // Create task form state
  const [newTaskName, setNewTaskName] = useState('');
  const [newTaskDescription, setNewTaskDescription] = useState('');
  const [newTaskRequirements, setNewTaskRequirements] = useState('');
  const [selectedSampleType, setSelectedSampleType] = useState('');

  // Available sample types for planning
  const [sampleTypes, setSampleTypes] = useState<any[]>([]);

  // WIP limits for kanban columns
  const WIP_LIMITS = {
    backlog: undefined,
    planning: 3,
    review: 2,
    implementation: 5,
    completed: undefined,
  };

  // Kanban columns configuration
  const columns: KanbanColumn[] = useMemo(() => [
    {
      id: 'backlog',
      title: 'Backlog',
      color: theme.palette.text.secondary,
      backgroundColor: theme.palette.grey[100],
      description: 'Tasks without specifications',
      tasks: tasks.filter(t => t.phase === 'backlog' && !t.hasSpecs),
    },
    {
      id: 'planning',
      title: 'Planning',
      color: theme.palette.warning.main,
      backgroundColor: theme.palette.warning.light + '20',
      description: 'Specs being generated by Zed agents',
      limit: WIP_LIMITS.planning,
      tasks: tasks.filter(t => t.phase === 'planning' || t.planningStatus === 'active'),
    },
    {
      id: 'review',
      title: 'Spec Review',
      color: theme.palette.info.main,
      backgroundColor: theme.palette.info.light + '20',
      description: 'Specs ready for human review',
      limit: WIP_LIMITS.review,
      tasks: tasks.filter(t => t.phase === 'review' || t.specApprovalNeeded),
    },
    {
      id: 'implementation',
      title: 'Implementation',
      color: theme.palette.success.main,
      backgroundColor: theme.palette.success.light + '20',
      description: 'Multi-session implementation in progress',
      limit: WIP_LIMITS.implementation,
      tasks: tasks.filter(t => t.phase === 'implementation' && t.activeSessionsCount > 0),
    },
    {
      id: 'completed',
      title: 'Completed',
      color: theme.palette.success.dark,
      backgroundColor: theme.palette.success.dark + '20',
      description: 'Completed tasks',
      tasks: tasks.filter(t => t.phase === 'completed' || t.status === 'completed'),
    },
  ], [tasks, theme]);

  // Load tasks and related data
  const loadTasks = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);

      // Load SpecTasks
      const response = await api.get('/api/v1/spec-tasks', {
        params: {
          project_id: projectId,
          user_id: userId || account.user?.id,
        },
      });

      const specTasks: SpecTask[] = response.data || [];

      // Enhance tasks with additional data
      const enhancedTasks: SpecTaskWithExtras[] = await Promise.all(
        specTasks.map(async (task) => {
          try {
            // Check if task has specs
            const hasSpecs = task.status === 'spec_approved' || 
                           task.status === 'implementing' || 
                           task.status === 'completed';

            // Get multi-session overview if available
            let multiSessionOverview;
            let activeSessionsCount = 0;
            let completedSessionsCount = 0;

            if (hasSpecs) {
              try {
                const overviewResponse = await api.get(`/api/v1/spec-tasks/${task.id}/multi-session-overview`);
                multiSessionOverview = overviewResponse.data;
                activeSessionsCount = multiSessionOverview?.active_sessions || 0;
                completedSessionsCount = multiSessionOverview?.completed_sessions || 0;
              } catch (err) {
                console.warn('Failed to load multi-session overview for task', task.id);
              }
            }

            // Determine planning status and phase
            let planningStatus: 'none' | 'active' | 'pending_review' | 'completed' | 'failed' = 'none';
            let phase: SpecTaskPhase = 'backlog';
            let specApprovalNeeded = false;

            if (task.status === 'completed') {
              phase = 'completed';
            } else if (task.status === 'implementing' || activeSessionsCount > 0) {
              phase = 'implementation';
              planningStatus = 'completed';
            } else if (task.status === 'spec_approved') {
              phase = 'implementation';
              planningStatus = 'completed';
            } else if (task.status === 'pending_approval') {
              phase = 'review';
              planningStatus = 'pending_review';
              specApprovalNeeded = true;
            } else if (task.status === 'planning') {
              phase = 'planning';
              planningStatus = 'active';
            } else {
              phase = 'backlog';
              planningStatus = 'none';
            }

            return {
              ...task,
              hasSpecs,
              planningStatus,
              phase,
              specApprovalNeeded,
              multiSessionOverview,
              activeSessionsCount,
              completedSessionsCount,
              lastActivity: multiSessionOverview?.last_activity || task.updated_at,
            };
          } catch (err) {
            console.error('Failed to enhance task', task.id, err);
            return {
              ...task,
              hasSpecs: false,
              planningStatus: 'none' as const,
              phase: 'backlog' as const,
              activeSessionsCount: 0,
              completedSessionsCount: 0,
            };
          }
        })
      );

      setTasks(enhancedTasks);
    } catch (err) {
      console.error('Failed to load tasks:', err);
      setError('Failed to load tasks. Please try again.');
    } finally {
      setLoading(false);
    }
  }, [api, projectId, userId, account.user?.id]);

  // Load sample types for planning
  const loadSampleTypes = useCallback(async () => {
    try {
      const response = await api.get('/api/v1/zed/planning/sample-types');
      setSampleTypes(response.data.sample_types || []);
    } catch (err) {
      console.warn('Failed to load sample types:', err);
    }
  }, [api]);

  // Load initial data
  useEffect(() => {
    loadTasks();
    loadSampleTypes();
  }, [loadTasks, loadSampleTypes]);

  // Auto-refresh every 30 seconds
  useEffect(() => {
    const interval = setInterval(() => {
      setRefreshing(true);
      loadTasks().finally(() => setRefreshing(false));
    }, 30000);

    return () => clearInterval(interval);
  }, [loadTasks]);

  // Handle drag and drop
  const onDragEnd = useCallback((result: DropResult) => {
    const { destination, source, draggableId } = result;

    if (!destination) return;
    if (destination.droppableId === source.droppableId && destination.index === source.index) return;

    const task = tasks.find(t => t.id === draggableId);
    if (!task) return;

    const newPhase = destination.droppableId as SpecTaskPhase;
    const column = columns.find(c => c.id === newPhase);

    // Check WIP limits
    if (column?.limit && column.tasks.length >= column.limit) {
      setError(`Cannot move to ${column.title}: WIP limit of ${column.limit} reached`);
      return;
    }

    // Handle phase transitions
    handlePhaseTransition(task, newPhase);
  }, [tasks, columns]);

  // Handle phase transitions with appropriate actions
  const handlePhaseTransition = async (task: SpecTaskWithExtras, newPhase: SpecTaskPhase) => {
    try {
      if (newPhase === 'planning' && !task.hasSpecs) {
        // Start planning session
        setSelectedTask(task);
        setPlanningDialogOpen(true);
      } else if (newPhase === 'review' && task.planningStatus === 'pending_review') {
        // Specs are ready for review - just update the local state
        // The actual review will be done through the review interface
        setTasks(prev => prev.map(t => 
          t.id === task.id ? { ...t, phase: newPhase } : t
        ));
      } else if (newPhase === 'implementation' && task.hasSpecs) {
        // Start implementation sessions
        await startImplementation(task);
      } else {
        // Generic status update
        await updateTaskStatus(task.id, newPhase);
      }
    } catch (err) {
      console.error('Failed to handle phase transition:', err);
      setError('Failed to update task. Please try again.');
    }
  };

  // Start planning session for a task
  const startPlanning = async (task: SpecTaskWithExtras, sampleType?: string) => {
    try {
      const planningRequest = {
        spec_task_id: task.id,
        project_name: task.name,
        description: task.description,
        requirements: newTaskRequirements || task.description,
        owner_id: account.user?.id,
        create_repo: true,
        sample_type: sampleType,
      };

      const response = await api.post('/api/v1/zed/planning/from-sample', planningRequest);
      
      if (response.data.success) {
        // Update task status
        setTasks(prev => prev.map(t => 
          t.id === task.id 
            ? { ...t, phase: 'planning', planningStatus: 'active' }
            : t
        ));
        
        setPlanningDialogOpen(false);
        setSelectedTask(null);
        setNewTaskRequirements('');
        setSelectedSampleType('');
      }
    } catch (err) {
      console.error('Failed to start planning:', err);
      setError('Failed to start planning session. Please try again.');
    }
  };

  // Start implementation sessions
  const startImplementation = async (task: SpecTaskWithExtras) => {
    try {
      const response = await api.post(`/api/v1/spec-tasks/${task.id}/implementation-sessions`, {
        session_count: 3, // Default to 3 parallel sessions
        agent_types: ['zed', 'zed', 'zed'],
      });

      if (response.data) {
        // Update task status
        setTasks(prev => prev.map(t => 
          t.id === task.id 
            ? { 
                ...t, 
                phase: 'implementation',
                activeSessionsCount: response.data.work_session_count || 3
              }
            : t
        ));
      }
    } catch (err) {
      console.error('Failed to start implementation:', err);
      setError('Failed to start implementation. Please try again.');
    }
  };

  // Update task status
  const updateTaskStatus = async (taskId: string, phase: SpecTaskPhase) => {
    try {
      // Map phase to status
      const statusMap: Record<SpecTaskPhase, string> = {
        backlog: 'draft',
        planning: 'planning',
        review: 'pending_approval',
        implementation: 'implementing',
        completed: 'completed',
      };

      await api.put(`/api/v1/spec-tasks/${taskId}`, {
        status: statusMap[phase],
      });

      // Update local state
      setTasks(prev => prev.map(t => 
        t.id === taskId ? { ...t, phase, status: statusMap[phase] } : t
      ));
    } catch (err) {
      console.error('Failed to update task status:', err);
      throw err;
    }
  };

  // Create new SpecTask
  const createTask = async () => {
    try {
      const response = await api.post('/api/v1/spec-tasks/from-prompt', {
        name: newTaskName,
        description: newTaskDescription,
        project_id: projectId,
      });

      if (response.data) {
        // Add to local state
        const newTask: SpecTaskWithExtras = {
          ...response.data,
          hasSpecs: false,
          planningStatus: 'none',
          phase: 'backlog',
          activeSessionsCount: 0,
          completedSessionsCount: 0,
        };
        
        setTasks(prev => [...prev, newTask]);
        setCreateDialogOpen(false);
        setNewTaskName('');
        setNewTaskDescription('');
      }
    } catch (err) {
      console.error('Failed to create task:', err);
      setError('Failed to create task. Please try again.');
    }
  };

  // Get priority color
  const getPriorityColor = (priority: string) => {
    switch (priority) {
      case 'critical': return theme.palette.error.main;
      case 'high': return theme.palette.warning.main;
      case 'medium': return theme.palette.info.main;
      case 'low': return theme.palette.success.main;
      default: return theme.palette.grey[500];
    }
  };

  // Get spec status icon and color
  const getSpecStatusInfo = (task: SpecTaskWithExtras) => {
    if (!task.hasSpecs && task.planningStatus === 'none') {
      return { icon: <SpecIcon />, color: theme.palette.error.main, text: 'No specs' };
    } else if (task.planningStatus === 'active') {
      return { icon: <CircularProgress size={16} />, color: theme.palette.warning.main, text: 'Generating specs' };
    } else if (task.planningStatus === 'pending_review') {
      return { icon: <ViewIcon />, color: theme.palette.info.main, text: 'Review needed' };
    } else if (task.planningStatus === 'completed') {
      return { icon: <CheckCircle />, color: theme.palette.success.main, text: 'Specs approved' };
    } else if (task.planningStatus === 'failed') {
      return { icon: <CancelIcon />, color: theme.palette.error.main, text: 'Planning failed' };
    }
    return { icon: <SpecIcon />, color: theme.palette.grey[500], text: 'Unknown' };
  };

  // Render task card
  const renderTaskCard = (task: SpecTaskWithExtras, index: number) => {
    const specStatus = getSpecStatusInfo(task);
    
    return (
      <Draggable key={task.id} draggableId={task.id} index={index}>
        {(provided, snapshot) => (
          <Card
            ref={provided.innerRef}
            {...provided.draggableProps}
            {...provided.dragHandleProps}
            sx={{
              mb: 1,
              cursor: 'pointer',
              borderLeft: `4px solid ${getPriorityColor(task.priority)}`,
              backgroundColor: snapshot.isDragging ? theme.palette.action.hover : 'white',
              '&:hover': {
                boxShadow: theme.shadows[4],
              },
            }}
            onClick={() => onTaskClick?.(task)}
          >
            <CardContent sx={{ p: 2, '&:last-child': { pb: 2 } }}>
              {/* Task header */}
              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', mb: 1 }}>
                <Typography variant="subtitle2" sx={{ fontWeight: 600, flex: 1 }}>
                  {task.name}
                </Typography>
                <IconButton size="small" onClick={(e) => e.stopPropagation()}>
                  <MoreIcon fontSize="small" />
                </IconButton>
              </Box>

              {/* Task description */}
              <Typography variant="body2" color="text.secondary" sx={{ mb: 1 }}>
                {task.description.length > 100 
                  ? `${task.description.substring(0, 100)}...` 
                  : task.description
                }
              </Typography>

              {/* Status chips */}
              <Box sx={{ display: 'flex', gap: 0.5, flexWrap: 'wrap', mb: 1 }}>
                {/* Spec status */}
                <Chip
                  icon={specStatus.icon}
                  label={specStatus.text}
                  size="small"
                  sx={{ 
                    backgroundColor: specStatus.color + '20',
                    color: specStatus.color,
                  }}
                />

                {/* Priority */}
                <Chip
                  label={task.priority}
                  size="small"
                  sx={{ 
                    backgroundColor: getPriorityColor(task.priority) + '20',
                    color: getPriorityColor(task.priority),
                  }}
                />

                {/* Active sessions indicator */}
                {task.activeSessionsCount > 0 && (
                  <Chip
                    icon={<CodeIcon />}
                    label={`${task.activeSessionsCount} active`}
                    size="small"
                    color="success"
                  />
                )}

                {/* Git repository indicator */}
                {task.gitRepositoryId && (
                  <Chip
                    icon={<GitIcon />}
                    label="Git repo"
                    size="small"
                    color="primary"
                  />
                )}
              </Box>

              {/* Progress indicator for implementation */}
              {task.phase === 'implementation' && task.multiSessionOverview && (
                <Box sx={{ mt: 1 }}>
                  <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 0.5 }}>
                    <Typography variant="caption">Progress</Typography>
                    <Typography variant="caption">
                      {task.completedSessionsCount}/{task.activeSessionsCount + task.completedSessionsCount}
                    </Typography>
                  </Box>
                  <LinearProgress
                    variant="determinate"
                    value={
                      task.completedSessionsCount / 
                      (task.activeSessionsCount + task.completedSessionsCount) * 100
                    }
                    sx={{ height: 4, borderRadius: 2 }}
                  />
                </Box>
              )}

              {/* Last activity */}
              <Typography variant="caption" color="text.secondary" sx={{ mt: 1, display: 'block' }}>
                {task.lastActivity ? formatDistanceToNow(new Date(task.lastActivity), { addSuffix: true }) : 'No activity'}
              </Typography>
            </CardContent>
          </Card>
        )}
      </Draggable>
    );
  };

  // Render column
  const renderColumn = (column: KanbanColumn) => (
    <Box key={column.id} sx={{ width: 320, mx: 1 }}>
      <Card sx={{ height: '100%', display: 'flex', flexDirection: 'column' }}>
        <CardHeader
          title={
            <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
              <Typography variant="h6" sx={{ color: column.color }}>
                {column.title}
              </Typography>
              <Badge badgeContent={column.tasks.length} color="primary" />
              {column.limit && column.tasks.length >= column.limit && (
                <Chip label="WIP Limit" size="small" color="warning" />
              )}
            </Box>
          }
          subheader={column.description}
          sx={{ 
            backgroundColor: column.backgroundColor,
            borderBottom: `3px solid ${column.color}`,
          }}
        />
        
        <Droppable droppableId={column.id}>
          {(provided, snapshot) => (
            <Box
              ref={provided.innerRef}
              {...provided.droppableProps}
              sx={{
                flex: 1,
                p: 1,
                backgroundColor: snapshot.isDraggingOver ? theme.palette.action.hover : 'transparent',
                minHeight: 200,
              }}
            >
              {column.tasks.map((task, index) => renderTaskCard(task, index))}
              {provided.placeholder}
            </Box>
          )}
        </Droppable>
      </Card>
    </Box>
  );

  if (loading) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: 400 }}>
        <CircularProgress />
      </Box>
    );
  }

  return (
    <Box sx={{ height: '100%', display: 'flex', flexDirection: 'column' }}>
      {/* Header */}
      <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
        <Typography variant="h4" sx={{ fontWeight: 600 }}>
          SpecTask Board
        </Typography>
        
        <Box sx={{ display: 'flex', gap: 1 }}>
          <Button
            variant="outlined"
            startIcon={refreshing ? <CircularProgress size={16} /> : <TimelineIcon />}
            onClick={() => {
              setRefreshing(true);
              loadTasks().finally(() => setRefreshing(false));
            }}
            disabled={refreshing}
          >
            Refresh
          </Button>
          
          <Button
            variant="contained"
            startIcon={<AddIcon />}
            onClick={() => setCreateDialogOpen(true)}
          >
            New Task
          </Button>
        </Box>
      </Box>

      {error && <Alert severity="error" sx={{ mb: 2 }} onClose={() => setError(null)}>{error}</Alert>}

      {/* Kanban Board */}
      <DragDropContext onDragEnd={onDragEnd}>
        <Box sx={{ display: 'flex', gap: 1, height: 'calc(100vh - 200px)', overflow: 'auto' }}>
          {columns.map(renderColumn)}
        </Box>
      </DragDropContext>

      {/* Create Task Dialog */}
      <Dialog open={createDialogOpen} onClose={() => setCreateDialogOpen(false)} maxWidth="md" fullWidth>
        <DialogTitle>Create New SpecTask</DialogTitle>
        <DialogContent>
          <Stack spacing={2} sx={{ mt: 1 }}>
            <TextField
              label="Task Name"
              fullWidth
              value={newTaskName}
              onChange={(e) => setNewTaskName(e.target.value)}
            />
            <TextField
              label="Description"
              fullWidth
              multiline
              rows={3}
              value={newTaskDescription}
              onChange={(e) => setNewTaskDescription(e.target.value)}
            />
          </Stack>
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setCreateDialogOpen(false)}>Cancel</Button>
          <Button onClick={createTask} variant="contained" disabled={!newTaskName.trim()}>
            Create Task
          </Button>
        </DialogActions>
      </Dialog>

      {/* Planning Dialog */}
      <Dialog open={planningDialogOpen} onClose={() => setPlanningDialogOpen(false)} maxWidth="md" fullWidth>
        <DialogTitle>Start Planning Session</DialogTitle>
        <DialogContent>
          <Stack spacing={2} sx={{ mt: 1 }}>
            <Typography variant="body2" color="text.secondary">
              Start a Zed planning session for: <strong>{selectedTask?.name}</strong>
            </Typography>
            
            <TextField
              label="Requirements"
              fullWidth
              multiline
              rows={4}
              value={newTaskRequirements}
              onChange={(e) => setNewTaskRequirements(e.target.value)}
              helperText="Describe what you want the planning agent to implement"
            />
            
            <FormControl fullWidth>
              <InputLabel>Sample Project Type</InputLabel>
              <Select
                value={selectedSampleType}
                onChange={(e) => setSelectedSampleType(e.target.value)}
              >
                {sampleTypes.map((type) => (
                  <MenuItem key={type.id} value={type.id}>
                    {type.name} - {type.description}
                  </MenuItem>
                ))}
              </Select>
            </FormControl>
          </Stack>
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setPlanningDialogOpen(false)}>Cancel</Button>
          <Button 
            onClick={() => selectedTask && startPlanning(selectedTask, selectedSampleType)}
            variant="contained"
            disabled={!newTaskRequirements.trim() || !selectedSampleType}
          >
            Start Planning
          </Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
};

export default SpecTaskKanbanBoard;