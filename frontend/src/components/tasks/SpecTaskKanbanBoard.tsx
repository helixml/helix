import React, { useState, useEffect, useMemo, useCallback } from 'react';
import {
  Box,
  Typography,
  Card,
  CardContent,
  CardHeader,
  Grid,
  Button,
  Chip,
  LinearProgress,
  CircularProgress,
  Alert,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  TextField,
  IconButton,
  Collapse,
  Stack,
  Divider,
  Badge,
  Tooltip,
  Menu,
  MenuItem,
  Select,
  FormControl,
  InputLabel,
  Avatar,
} from '@mui/material';
import {
  Add as AddIcon,
  ExpandMore as ExpandMoreIcon,
  ExpandLess as ExpandLessIcon,
  Source as GitIcon,
  Description as SpecIcon,
  PlayArrow as PlayIcon,
  CheckCircle as ApproveIcon,
  Cancel as CancelIcon,
  MoreVert as MoreIcon,
  Code as CodeIcon,
  Timeline as TimelineIcon,
  AccountTree as TreeIcon,
  Visibility as ViewIcon,
  Edit as EditIcon,
  Delete as DeleteIcon,
} from '@mui/icons-material';
// Temporarily disabled drag-and-drop to fix TypeScript issues
// import { DragDropContext, Droppable, Draggable, DropResult } from 'react-beautiful-dnd';
import { useTheme } from '@mui/material/styles';
// Removed date-fns dependency - using native JavaScript instead

import useApi from '../../hooks/useApi';
import useAccount from '../../hooks/useAccount';
import specTaskService, {
  SpecTask,
  MultiSessionOverview,
  useSpecTask,
  useMultiSessionOverview,
} from '../../services/specTaskService';
import gitRepositoryService, {
  SampleType,
  useSampleTypes,
  useCreateSampleRepository,
  getSampleTypeIcon,
  getSampleTypeCategory,
  isBusinessTask,
  getBusinessTaskDescription,
} from '../../services/gitRepositoryService';

// SpecTask types and statuses
type SpecTaskPhase = 'backlog' | 'planning' | 'review' | 'implementation' | 'completed';
type SpecTaskPriority = 'low' | 'medium' | 'high' | 'critical';

interface SpecTaskWithExtras extends SpecTask {
  hasSpecs: boolean;
  phase: SpecTaskPhase;
  planningStatus?: 'none' | 'active' | 'pending_review' | 'completed' | 'failed';
  gitRepositoryId?: string;
  gitRepositoryUrl?: string;
  multiSessionOverview?: MultiSessionOverview;
  lastActivity?: string;
  activeSessionsCount?: number;
  completedSessionsCount?: number;
  specApprovalNeeded?: boolean;
}

interface KanbanColumn {
  id: SpecTaskPhase;
  title: string;
  color: string;
  backgroundColor: string;
  description: string;
  limit?: number;
  tasks: SpecTaskWithExtras[];
}

interface SpecTaskKanbanBoardProps {
  projectId?: string;
  userId?: string;
  onTaskClick?: (task: SpecTaskWithExtras) => void;
}

const SpecTaskKanbanBoard: React.FC<SpecTaskKanbanBoardProps> = ({
  projectId,
  userId,
  onTaskClick,
}) => {
  const theme = useTheme();
  const api = useApi();
  const account = useAccount();

  // State
  const [tasks, setTasks] = useState<SpecTaskWithExtras[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [createDialogOpen, setCreateDialogOpen] = useState(false);
  const [planningDialogOpen, setPlanningDialogOpen] = useState(false);
  const [selectedTask, setSelectedTask] = useState<SpecTaskWithExtras | null>(null);
  const [refreshing, setRefreshing] = useState(false);

  // Create task form state
  const [newTaskName, setNewTaskName] = useState('');
  const [newTaskDescription, setNewTaskDescription] = useState('');
  const [newTaskRequirements, setNewTaskRequirements] = useState('');
  const [selectedSampleType, setSelectedSampleType] = useState('');

  // Available sample types for planning
  const [sampleTypes, setSampleTypes] = useState<any[]>([]);

  // WIP limits for kanban columns
  const WIP_LIMITS = {
    backlog: undefined,
    planning: 3,
    review: 2,
    implementation: 5,
    completed: undefined,
  };

  // Kanban columns configuration
  const columns: KanbanColumn[] = useMemo(() => [
    {
      id: 'backlog',
      title: 'Backlog',
      color: theme.palette.text.secondary,
      backgroundColor: theme.palette.grey[100],
      description: 'Tasks without specifications',
      tasks: tasks.filter(t => (t as any).phase === 'backlog' && !t.hasSpecs),
    },
    {
      id: 'planning',
      title: 'Planning',
      color: theme.palette.warning.main,
      backgroundColor: theme.palette.warning.light + '20',
      description: 'Specs being generated by Zed agents',
      limit: WIP_LIMITS.planning,
      tasks: tasks.filter(t => (t as any).phase === 'planning' || t.planningStatus === 'active'),
    },
    {
      id: 'review',
      title: 'Spec Review',
      color: theme.palette.info.main,
      backgroundColor: theme.palette.info.light + '20',
      description: 'Specs ready for human review',
      limit: WIP_LIMITS.review,
      tasks: tasks.filter(t => (t as any).phase === 'review' || t.specApprovalNeeded),
    },
    {
      id: 'implementation',
      title: 'Implementation',
      color: theme.palette.success.main,
      backgroundColor: theme.palette.success.light + '20',
      description: 'Multi-session implementation in progress',
      limit: WIP_LIMITS.implementation,
      tasks: tasks.filter(t => (t as any).phase === 'implementation' && (t.activeSessionsCount || 0) > 0),
    },
    {
      id: 'completed',
      title: 'Completed',
      color: theme.palette.success.dark,
      backgroundColor: theme.palette.success.dark + '20',
      description: 'Completed tasks',
      tasks: tasks.filter(t => (t as any).phase === 'completed' || t.status === 'completed'),
    },
  ], [tasks, theme]);

  // Load tasks and related data
  const loadTasks = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);

      // Load SpecTasks
      const response = await api.get('/api/v1/spec-tasks', {
        params: {
          project_id: projectId,
          user_id: userId || account.user?.id,
        },
      });

      const specTasks: SpecTask[] = response.data || [];

      // Enhance tasks with additional data
      const enhancedTasks: SpecTaskWithExtras[] = await Promise.all(
        specTasks.map(async (task) => {
          try {
            // Check if task has specs
            const hasSpecs = task.status === 'spec_approved' || 
                           task.status === 'implementing' || 
                           task.status === 'completed';

            // Get multi-session overview if available
            let multiSessionOverview;
            let activeSessionsCount = 0;
            let completedSessionsCount = 0;

            if (hasSpecs) {
              try {
                const overviewResponse = await api.get(`/api/v1/spec-tasks/${task.id}/multi-session-overview`);
                multiSessionOverview = overviewResponse.data;
                activeSessionsCount = multiSessionOverview?.active_sessions || 0;
                completedSessionsCount = multiSessionOverview?.completed_sessions || 0;
              } catch (err) {
                console.warn('Failed to load multi-session overview for task', task.id);
              }
            }

            // Determine planning status and phase
            let planningStatus: 'none' | 'active' | 'pending_review' | 'completed' | 'failed' = 'none';
            let phase: SpecTaskPhase = 'backlog';
            let specApprovalNeeded = false;

            if (task.status === 'completed') {
              phase = 'completed';
            } else if (task.status === 'implementing' || activeSessionsCount > 0) {
              phase = 'implementation';
              planningStatus = 'completed';
            } else if (task.status === 'spec_approved') {
              phase = 'implementation';
              planningStatus = 'completed';
            } else if (task.status === 'pending_approval') {
              phase = 'review';
              planningStatus = 'pending_review';
              specApprovalNeeded = true;
            } else if (task.status === 'planning') {
              phase = 'planning';
              planningStatus = 'active';
            } else {
              phase = 'backlog';
              planningStatus = 'none';
            }

            return {
              ...task,
              hasSpecs,
              planningStatus,
              phase,
              specApprovalNeeded,
              multiSessionOverview,
              activeSessionsCount,
              completedSessionsCount,
              lastActivity: multiSessionOverview?.last_activity || task.updated_at,
            };
          } catch (err) {
            console.error('Failed to enhance task', task.id, err);
            return {
              ...task,
              hasSpecs: false,
              planningStatus: 'none' as const,
              phase: 'backlog' as const,
              activeSessionsCount: 0,
              completedSessionsCount: 0,
            };
          }
        })
      );

      setTasks(enhancedTasks);
    } catch (err) {
      console.error('Failed to load tasks:', err);
      setError('Failed to load tasks. Please try again.');
    } finally {
      setLoading(false);
    }
  }, [api, projectId, userId, account.user?.id]);

  // Load sample types using generated client
  const { data: sampleTypesData, isLoading: sampleTypesLoading } = useSampleTypes();
  
  const loadSampleTypes = useCallback(() => {
    if (sampleTypesData?.sample_types) {
      setSampleTypes(sampleTypesData.sample_types);
    }
  }, [sampleTypesData]);

  // Load initial data
  useEffect(() => {
    loadTasks();
  }, [loadTasks]);

  // Update sample types when data changes
  useEffect(() => {
    loadSampleTypes();
  }, [loadSampleTypes]);

  // Auto-refresh every 30 seconds
  useEffect(() => {
    const interval = setInterval(() => {
      setRefreshing(true);
      loadTasks().finally(() => setRefreshing(false));
    }, 30000);

    return () => clearInterval(interval);
  }, [loadTasks]);

  // Drag and drop temporarily disabled - use click handlers instead
  const handleTaskPhaseChange = useCallback((task: SpecTaskWithExtras, newPhase: SpecTaskPhase) => {
    const column = columns.find(c => c.id === newPhase);

    // Check WIP limits
    if (column?.limit && column.tasks.length >= column.limit) {
      setError(`Cannot move to ${column.title}: WIP limit of ${column.limit} reached`);
      return;
    }

    // Handle phase transitions
    handlePhaseTransition(task, newPhase);
  }, [tasks, columns]);

  // Handle phase transitions with appropriate actions
  const handlePhaseTransition = async (task: SpecTaskWithExtras, newPhase: SpecTaskPhase) => {
    try {
      if (newPhase === 'planning' && !task.hasSpecs) {
        // Start planning session
        setSelectedTask(task);
        setPlanningDialogOpen(true);
      } else if (newPhase === 'review' && task.planningStatus === 'pending_review') {
        // Specs are ready for review - just update the local state
        // The actual review will be done through the review interface
        setTasks(prev => prev.map(t => 
          t.id === task.id ? { ...t, phase: newPhase } : t
        ));
      } else if (newPhase === 'implementation' && task.hasSpecs) {
        // Start implementation sessions
        await startImplementation(task);
      } else {
        // Generic status update
        await updateTaskStatus(task.id || '', newPhase);
      }
    } catch (err) {
      console.error('Failed to handle phase transition:', err);
      setError('Failed to update task. Please try again.');
    }
  };

  // Start planning session for a task
  const createSampleRepoMutation = useCreateSampleRepository();
  
  const startPlanning = async (task: SpecTaskWithExtras, sampleType?: string) => {
    try {
      if (!sampleType || !account.user?.id) {
        setError('Sample type and user ID are required');
        return;
      }

      // First create the sample repository
      const sampleRepo = await createSampleRepoMutation.mutateAsync({
        name: `${task.name} - ${sampleType}`,
        description: task.description,
        owner_id: account.user.id,
        sample_type: sampleType,
      });

      if (sampleRepo) {
        // Update task with repository info
        setTasks(prev => prev.map(t => 
          t.id === task.id 
            ? { 
                ...t, 
                phase: 'planning', 
                planningStatus: 'active',
                gitRepositoryId: sampleRepo.id,
                gitRepositoryUrl: sampleRepo.clone_url
              }
            : t
        ));
        
        setPlanningDialogOpen(false);
        setSelectedTask(null);
        setNewTaskRequirements('');
        setSelectedSampleType('');
      }
    } catch (err) {
      console.error('Failed to start planning:', err);
      setError('Failed to start planning session. Please try again.');
    }
  };

  // Start implementation sessions
  const startImplementation = async (task: SpecTaskWithExtras) => {
    try {
      const response = await api.post(`/api/v1/spec-tasks/${task.id}/implementation-sessions`, {
        session_count: 3, // Default to 3 parallel sessions
        agent_types: ['zed', 'zed', 'zed'],
      });

      if (response.data) {
        // Update task status
        setTasks(prev => prev.map(t => 
          t.id === task.id 
            ? { 
                ...t, 
                phase: 'implementation',
                activeSessionsCount: response.data.work_session_count || 3
              }
            : t
        ));
      }
    } catch (err) {
      console.error('Failed to start implementation:', err);
      setError('Failed to start implementation. Please try again.');
    }
  };

  // Update task status
  const updateTaskStatus = async (taskId: string, phase: SpecTaskPhase) => {
    try {
      // Map phase to status
      const statusMap: Record<SpecTaskPhase, string> = {
        backlog: 'draft',
        planning: 'planning',
        review: 'pending_approval',
        implementation: 'implementing',
        completed: 'completed',
      };

      await api.put(`/api/v1/spec-tasks/${taskId}`, {
        status: statusMap[phase],
      });

      // Update local state
      setTasks(prev => prev.map(t => 
        t.id === taskId ? { ...t, phase, status: statusMap[phase] } : t
      ));
    } catch (err) {
      console.error('Failed to update task status:', err);
      throw err;
    }
  };

  // Create new SpecTask
  const createTask = async () => {
    try {
      const response = await api.post('/api/v1/spec-tasks/from-prompt', {
        name: newTaskName,
        description: newTaskDescription,
        project_id: projectId,
      });

      if (response.data) {
        // Add to local state
        const newTask: SpecTaskWithExtras = {
          ...response.data,
          hasSpecs: false,
          planningStatus: 'none',
          phase: 'backlog',
          activeSessionsCount: 0,
          completedSessionsCount: 0,
        };
        
        setTasks(prev => [...prev, newTask]);
        setCreateDialogOpen(false);
        setNewTaskName('');
        setNewTaskDescription('');
      }
    } catch (err) {
      console.error('Failed to create task:', err);
      setError('Failed to create task. Please try again.');
    }
  };

  // Get priority color
  const getPriorityColor = (priority: string) => {
    switch (priority) {
      case 'critical': return theme.palette.error.main;
      case 'high': return theme.palette.warning.main;
      case 'medium': return theme.palette.info.main;
      case 'low': return theme.palette.success.main;
      default: return theme.palette.grey[500];
    }
  };

  // Get spec status icon and color
  const getSpecStatusInfo = (task: SpecTaskWithExtras) => {
    if (!task.hasSpecs && task.planningStatus === 'none') {
      return { icon: <SpecIcon />, color: theme.palette.error.main, text: 'No specs' };
    } else if (task.planningStatus === 'active') {
      return { icon: <CircularProgress size={16} />, color: theme.palette.warning.main, text: 'Generating specs' };
    } else if (task.planningStatus === 'pending_review') {
      return { icon: <ViewIcon />, color: theme.palette.info.main, text: 'Review needed' };
    } else if (task.planningStatus === 'completed') {
      return { icon: <ApproveIcon />, color: theme.palette.success.main, text: 'Specs approved' };
    } else if (task.planningStatus === 'failed') {
      return { icon: <CancelIcon />, color: theme.palette.error.main, text: 'Planning failed' };
    }
    return { icon: <SpecIcon />, color: theme.palette.grey[500], text: 'Unknown' };
  };

  // Render task card
  const renderTaskCard = (task: SpecTaskWithExtras, index: number) => {
    const specStatus = getSpecStatusInfo(task);
    const taskId = task.id || `task-${index}`;
    
    return (
      <Card
        key={taskId}
        sx={{
          mb: 1,
          cursor: 'pointer',
          borderLeft: `4px solid ${getPriorityColor(task.priority || 'medium')}`,
          '&:hover': {
            boxShadow: theme.shadows[4],
          },
        }}
        onClick={() => onTaskClick?.(task)}
      >
            <CardContent sx={{ p: 2, '&:last-child': { pb: 2 } }}>
              {/* Task header */}
              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', mb: 1 }}>
                <Typography variant="subtitle2" sx={{ fontWeight: 600, flex: 1 }}>
                  {task.name}
                </Typography>
                <IconButton size="small" onClick={(e) => e.stopPropagation()}>
                  <MoreIcon fontSize="small" />
                </IconButton>
              </Box>

              {/* Task description */}
              <Typography variant="body2" color="text.secondary" sx={{ mb: 1 }}>
                {(task.description || '').length > 100 
                  ? `${(task.description || '').substring(0, 100)}...` 
                  : task.description || 'No description'
                }
              </Typography>

              {/* Status chips */}
              <Box sx={{ display: 'flex', gap: 0.5, flexWrap: 'wrap', mb: 1 }}>
                {/* Spec status */}
                <Chip
                  icon={specStatus.icon}
                  label={specStatus.text}
                  size="small"
                  sx={{ 
                    backgroundColor: specStatus.color + '20',
                    color: specStatus.color,
                  }}
                />

                {/* Priority */}
                <Chip
                  label={task.priority || 'medium'}
                  size="small"
                  sx={{ 
                    backgroundColor: getPriorityColor(task.priority || 'medium') + '20',
                    color: getPriorityColor(task.priority || 'medium'),
                  }}
                />

                {/* Active sessions indicator */}
                {(task.activeSessionsCount || 0) > 0 && (
                  <Chip
                    icon={<CodeIcon />}
                    label={`${task.activeSessionsCount} active`}
                    size="small"
                    color="success"
                  />
                )}

                {/* Git repository indicator */}
                {task.gitRepositoryId && (
                  <Chip
                    icon={<GitIcon />}
                    label="Git repo"
                    size="small"
                    color="primary"
                  />
                )}
              </Box>

              {/* Progress indicator for implementation */}
              {(task as any).phase === 'implementation' && task.multiSessionOverview && (
                <Box sx={{ mt: 1 }}>
                  <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 0.5 }}>
                    <Typography variant="caption">Progress</Typography>
                    <Typography variant="caption">
                      {task.completedSessionsCount || 0}/{(task.activeSessionsCount || 0) + (task.completedSessionsCount || 0)}
                    </Typography>
                  </Box>
                  <LinearProgress
                    variant="determinate"
                    value={
                      (task.completedSessionsCount || 0) / 
                      ((task.activeSessionsCount || 0) + (task.completedSessionsCount || 0)) * 100
                    }
                    sx={{ height: 4, borderRadius: 2 }}
                  />
                </Box>
              )}

              {/* Last activity */}
              <Typography variant="caption" color="text.secondary" sx={{ mt: 1, display: 'block' }}>
                {task.lastActivity ? formatTimeAgo(new Date(task.lastActivity)) : 'No activity'}
              </Typography>
            </CardContent>
      </Card>
    );
  };

  // Render column
  const renderColumn = (column: KanbanColumn) => (
    <Box key={column.id} sx={{ width: 320, mx: 1 }}>
      <Card sx={{ height: '100%', display: 'flex', flexDirection: 'column' }}>
        <CardHeader
          title={
            <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
              <Typography variant="h6" sx={{ color: column.color }}>
                {column.title}
              </Typography>
              <Badge badgeContent={column.tasks.length} color="primary" />
              {column.limit && column.tasks.length >= column.limit && (
                <Chip label="WIP Limit" size="small" color="warning" />
              )}
            </Box>
          }
          subheader={column.description}
          sx={{ 
            backgroundColor: column.backgroundColor,
            borderBottom: `3px solid ${column.color}`,
          }}
        />
        
        <Box
          sx={{
            flex: 1,
            p: 1,
            minHeight: 200,
          }}
        >
          {column.tasks.map((task, index) => renderTaskCard(task, index))}
        </Box>
      </Card>
    </Box>
  );

  if (loading) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: 400 }}>
        <CircularProgress />
      </Box>
    );
  }

  return (
    <Box sx={{ height: '100%', display: 'flex', flexDirection: 'column' }}>
      {/* Header */}
      <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
        <Typography variant="h4" sx={{ fontWeight: 600 }}>
          SpecTask Board
        </Typography>
        
        <Box sx={{ display: 'flex', gap: 1 }}>
          <Button
            variant="outlined"
            startIcon={refreshing ? <CircularProgress size={16} /> : <TimelineIcon />}
            onClick={() => {
              setRefreshing(true);
              loadTasks().finally(() => setRefreshing(false));
            }}
            disabled={refreshing}
          >
            Refresh
          </Button>
          
          <Button
            variant="contained"
            startIcon={<AddIcon />}
            onClick={() => setCreateDialogOpen(true)}
          >
            New Task
          </Button>
        </Box>
      </Box>

      {error && <Alert severity="error" sx={{ mb: 2 }} onClose={() => setError(null)}>{error}</Alert>}

      {/* Kanban Board - Drag and drop temporarily disabled */}
      <Box sx={{ display: 'flex', gap: 1, height: 'calc(100vh - 200px)', overflow: 'auto' }}>
        {columns.map(renderColumn)}
      </Box>

      {/* Create Task Dialog */}
      <Dialog open={createDialogOpen} onClose={() => setCreateDialogOpen(false)} maxWidth="md" fullWidth>
        <DialogTitle>Create New SpecTask</DialogTitle>
        <DialogContent>
          <Stack spacing={2} sx={{ mt: 1 }}>
            <TextField
              label="Task Name"
              fullWidth
              value={newTaskName}
              onChange={(e) => setNewTaskName(e.target.value)}
            />
            <TextField
              label="Description"
              fullWidth
              multiline
              rows={3}
              value={newTaskDescription}
              onChange={(e) => setNewTaskDescription(e.target.value)}
            />
          </Stack>
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setCreateDialogOpen(false)}>Cancel</Button>
          <Button onClick={createTask} variant="contained" disabled={!newTaskName.trim()}>
            Create Task
          </Button>
        </DialogActions>
      </Dialog>

      {/* Planning Dialog */}
      <Dialog open={planningDialogOpen} onClose={() => setPlanningDialogOpen(false)} maxWidth="md" fullWidth>
        <DialogTitle>Start Planning Session</DialogTitle>
        <DialogContent>
          <Stack spacing={2} sx={{ mt: 1 }}>
            <Typography variant="body2" color="text.secondary">
              Start a Zed planning session for: <strong>{selectedTask?.name}</strong>
            </Typography>
            
            <TextField
              label="Requirements"
              fullWidth
              multiline
              rows={4}
              value={newTaskRequirements}
              onChange={(e) => setNewTaskRequirements(e.target.value)}
              helperText="Describe what you want the planning agent to implement"
            />
            
            <FormControl fullWidth>
              <InputLabel>Project Template</InputLabel>
              <Select
                value={selectedSampleType}
                onChange={(e) => setSelectedSampleType(e.target.value)}
              >
                {sampleTypes.map((type: SampleType) => {
                  const category = getSampleTypeCategory(type.id || '');
                  const isBusiness = isBusinessTask(type.id || '');
                  
                  return (
                    <MenuItem key={type.id} value={type.id}>
                      <Box sx={{ display: 'flex', alignItems: 'flex-start', gap: 1, width: '100%' }}>
                        <Typography sx={{ fontSize: '1.2em' }}>
                          {getSampleTypeIcon(type.id || '')}
                        </Typography>
                        <Box sx={{ flex: 1 }}>
                          <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                            <Typography variant="body2" sx={{ fontWeight: 600 }}>
                              {type.name}
                            </Typography>
                            {isBusiness && (
                              <Chip 
                                label="Business" 
                                size="small" 
                                color="primary" 
                                sx={{ height: 16 }}
                              />
                            )}
                          </Box>
                          <Typography variant="caption" color="text.secondary">
                            {isBusiness ? getBusinessTaskDescription(type.id || '') : type.description}
                          </Typography>
                          {type.tech_stack && (
                            <Typography variant="caption" sx={{ display: 'block', fontStyle: 'italic', color: 'primary.main' }}>
                              {type.tech_stack?.join(', ') || ''}
                            </Typography>
                          )}
                        </Box>
                      </Box>
                    </MenuItem>
                  );
                })}
              </Select>
            </FormControl>
          </Stack>
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setPlanningDialogOpen(false)}>Cancel</Button>
          <Button 
            onClick={() => selectedTask && startPlanning(selectedTask, selectedSampleType)}
            variant="contained"
            disabled={!newTaskRequirements.trim() || !selectedSampleType}
          >
            Start Planning
          </Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
};

// Helper function to replace date-fns formatDistanceToNow
function formatTimeAgo(date: Date): string {
  const now = new Date();
  const diffMs = now.getTime() - date.getTime();
  const diffMins = Math.floor(diffMs / 60000);
  const diffHours = Math.floor(diffMs / 3600000);
  const diffDays = Math.floor(diffMs / 86400000);

  if (diffMins < 1) return 'just now';
  if (diffMins < 60) return `${diffMins} minute${diffMins === 1 ? '' : 's'} ago`;
  if (diffHours < 24) return `${diffHours} hour${diffHours === 1 ? '' : 's'} ago`;
  if (diffDays < 30) return `${diffDays} day${diffDays === 1 ? '' : 's'} ago`;
  
  return date.toLocaleDateString();
}

export default SpecTaskKanbanBoard;